---
title: "Web scraping com R"
author: "Curso-R"
date: 2018-07-18
categories: ["R"]
tags: ["webscraping"]
slug: "webscraping"
desc: "Web scraping refere-se ao processo de baixar e estruturar dados diretamente da web. Passaremos pelos princípios básicos de requisições web, como controlá-las por intermédio do R e como obter informações estruturadas de páginas da web."
requisitos: ["r-base", "purrr"]
layout: "article"
---



<div id="pacotes-httr-xml2-e-rvest" class="section level1">
<h1>Pacotes <code>httr</code>, <code>xml2</code> e <code>rvest</code></h1>
<p>Esses são os três pacotes mais modernos do R utilizados para fazer web scraping. O pacote <code>xml2</code> tem a finalidade de estruturar arquivos HTML ou XML de forma eficiente, tornando possível a obtenção de <em>tags</em> e seus atributos dentro de um arquivo. Já o pacote <code>httr</code> é responsável por realizar requisições web para obtenção das páginas de interesse, buscando reduzir ao máximo a complexidade da programação. O pacote <code>rvest</code> é escrito <strong>sobre</strong> os dois anteriores e por isso eleva ainda mais o nível de especialização para raspagem de dados.</p>
<p>As características dos pacotes implicam na seguinte regra de bolso. Para trabalhar com páginas simples, basta carregar o <code>rvest</code> e utilizar suas funcionalidades. Caso o acesso à página exija ações mais complexas e/ou artifícios de ferramentas web, será necessário utilizar o <code>httr</code>. O <code>xml2</code> só será usado explicitamente nos casos raros em que a página está em XML, que pode ser visto como uma generalização do HTML.</p>
<p>Esses pacotes não são suficientes para acessar todo tipo de conteúdo da web. Um exemplo claro disso são páginas em que o conteúdo é produzido por <code>javascript</code>, o que acontece em muitos sites modernos. Para trabalhar com esses sites, é necessário realmente “simular” um navegador que acessa a página web. Uma das melhores ferramentas para isso é o <code>selenium</code>. Não discutiremos <code>selenium</code> nesse curso, mas caso queira se aprofundar, acesse <a href="http://www.seleniumhq.org/">aqui</a>.</p>
<div id="sessoes-e-cookies" class="section level3">
<h3>Sessões e cookies</h3>
<p>No momento que acessamos uma página web, nosso navegador baixa alguns arquivos que “identificam” nosso acesso à página. Esses arquivos são chamados cookies e são usados pelos sites para realizar diversas atividades, como carregar uma página pré-definida pelo usuário caso este acesse o site pela segunda vez.</p>
<p>O <code>httr</code> e por consequência o <code>rvest</code> já guardam esses cookies de forma automática, de forma que o usuário não precise se preocupar com isso. Em casos raros, para construir o web scraper é necessário modificar esses cookies. Nesses casos, estude a função <code>cookies()</code> do <code>httr</code>.</p>
</div>
<div id="get-e-post" class="section level3">
<h3><code>GET</code> e <code>POST</code></h3>
<p>Uma requisição <strong>GET</strong> envia uma <code>url</code> ao servidor, possivelmente com alguns parâmetros nessa <code>url</code> (que ficam no final da <code>url</code> depois do <code>?</code>). O servidor, por sua vez, recebe essa <code>url</code>, processa os parâmetros e retorna uma página HTML para o navegador.</p>
<p>A requisição <strong>POST</strong>, no entanto, envia uma <code>url</code> não modificada para o servidor, mas envia também uma lista de dados preenchidos pelo usuário, que podem ser números, textos ou até imagens. Na maioria dos casos, ao submeter um formulário de um site, fazemos uma requisição POST.</p>
<p>O <code>httr</code> possui os métodos <code>GET</code> e <code>POST</code> implementados e são muito similares. A lista de parâmetros enviados pelo usuário pode ser armazenado numa <code>list</code> nomeada, e adicionado ao <code>GET</code> pelo parâmetro <code>query</code> ou no <code>POST</code> pelo parâmetro <code>body</code>. Veremos exemplos disso mais adiante.</p>
</div>
<div id="outras-funcoes-do-httr" class="section level3">
<h3>Outras funções do <code>httr</code></h3>
<p>Outras funções úteis:</p>
<ul>
<li><code>write_disk()</code> para escrever uma requisição direto em disco, além de guardar na memória RAM.</li>
<li><code>config()</code> para adicionar configurações adicionais. Por exemplo, quando acessar uma página <code>https</code> com certificados inadequados numa requisição GET, rode <code>GET('https://www...', config(ssl_verifypeer=F))</code>.</li>
<li><code>oauth_app()</code> para trabalhar com APIs. Não discutiremos conexão com APIs nesse curso, mas é um importante conceito a ser estudado.</li>
</ul>
</div>
<div id="principais-funcoes-do-rvest" class="section level3">
<h3>Principais funções do <code>rvest</code></h3>
<pre class="r"><code>library(rvest)
## Loading required package: xml2</code></pre>
<p><strong>Para acessar páginas da web:</strong></p>
<ul>
<li><code>html_session()</code> abre uma sessão do usuário (baixa página, carrega cookies etc).</li>
<li><code>follow_link()</code>, <code>jump_to()</code> acessa uma página web a partir de um link (tag <code>&lt;a&gt;</code>) ou url.</li>
<li><code>html_form()</code> carrega todos os formulários contidos numa página.</li>
<li><code>set_value()</code> atribui valores a parâmetros do formulário.</li>
<li><code>submit_form()</code> submete um formulário obtido em <code>html_form</code>.</li>
</ul>
<p><strong>Para trabalhar com arquivos HTML:</strong></p>
<ul>
<li><code>read_html()</code> lê o arquivo HTML de forma estruturada e facilita impressão.</li>
<li><code>html_nodes()</code> cria uma lista com os nós identificados por uma busca em CSS path ou XPath.</li>
<li><code>html_node()</code> é um caso especial que assume que só será encontrado um resultado.</li>
<li><code>html_text()</code> extrai todo o conteúdo de um objeto e retorna um texto.</li>
<li><code>html_table()</code> extrai o conteúdo de uma <code>&lt;table&gt;</code> e transforma em um <code>data_frame</code>.</li>
<li><code>html_attr()</code> extrai um atributo de uma tag, por exemplo <code>href</code> da tag <code>&lt;a&gt;</code>.</li>
</ul>
</div>
<div id="css-path-e-xpath" class="section level3">
<h3>CSS path e XPath</h3>
<p>O CSS path e o XPath são formas distintas de buscar tags dentro de um documento HTML. O CSS path é mais simples de implementar e tem uma sintaxe menos verborrágica, mas o XPath é mais poderoso. A regra de bolso é tentar fazer a seleção primeiro em CSS e, caso não seja possível, implementar em XPath.</p>
<p>Esses paths serão mostrados <em>en passant</em> durante o curso, mas não serão abordados em detalhe. Caso queira se aprofundar no assunto, comece pela ajuda da função <code>?html_nodes</code>.</p>
</div>
<div id="apis-com-httr" class="section level3">
<h3>APIs com <code>httr</code></h3>
<p>O <code>httr</code> foi criado pensando-se nas modernas APIs que vêm sendo desenvolvidas nos últimos anos. O <code>httr</code> já tem métodos apropriados para trabalhar com Facebook, Twitter e Google, entre outros.</p>
<p>Para um guia completo de como utilizar APIs no R, acesse <a href="https://cran.r-project.org/web/packages/httr/vignettes/api-packages.html">esse tutorial</a>. Um exemplo de pacote que utiliza API usando esse tutorial melhores práticas pode ser <a href="https://github.com/jtrecenti/sptrans">acessado aqui</a>.</p>
</div>
</div>
<div id="exemplo-1-chance-de-gol" class="section level1">
<h1>Exemplo 1: chance de gol</h1>
<div id="parte-0-pacotes" class="section level2">
<h2>Parte 0: pacotes</h2>
<pre class="r"><code>library(tibble)
library(httr)
library(rvest)
library(dplyr)
library(ggplot2)</code></pre>
</div>
<div id="parte-1-acessando-a-pagina-de-um-ano" class="section level2">
<h2>Parte 1: acessando a página de um ano</h2>
<pre class="r"><code>ano &lt;- 2015
cdg_url &lt;- sprintf(&#39;http://www.chancedegol.com.br/br%02d.htm&#39;, ano - 2000)

cdg_html &lt;- cdg_url %&gt;%
  httr::GET() %&gt;%
  httr::content(&#39;text&#39;, encoding = &#39;latin1&#39;) %&gt;%
  xml2::read_html() %&gt;%
  rvest::html_node(&#39;table&#39;)</code></pre>
</div>
<div id="parte-2-cores-da-tabela" class="section level2">
<h2>Parte 2: cores da tabela</h2>
<pre class="r"><code>cores &lt;- cdg_html %&gt;%
  html_nodes(xpath = &#39;//font[@color=&quot;#FF0000&quot;]&#39;) %&gt;%
  html_text()</code></pre>
</div>
<div id="parte-3-nomes-e-estrutura-da-tabela" class="section level2">
<h2>Parte 3: nomes e estrutura da tabela</h2>
<pre class="r"><code>cdg_data &lt;- cdg_html %&gt;%
  html_table(header = TRUE) %&gt;%
  setNames(c(&#39;dt_jogo&#39;, &#39;mandante&#39;, &#39;placar&#39;, &#39;visitante&#39;,
             &#39;p_mandante&#39;, &#39;p_empate&#39;, &#39;p_visitante&#39;)) %&gt;% 
  mutate(p_vitorioso = cores) %&gt;% 
  as_tibble() %&gt;% 
  mutate(result = &#39;OK&#39;)</code></pre>
</div>
<div id="parte-4-colocando-dentro-de-uma-funcao" class="section level2">
<h2>Parte 4: colocando dentro de uma função</h2>
<pre class="r"><code>cdg_ano &lt;- function(ano) {
  cdg_url &lt;- sprintf(&#39;http://www.chancedegol.com.br/br%02d.htm&#39;, ano - 2000)
  
  cdg_html &lt;- cdg_url %&gt;%
    GET() %&gt;%
    content(&#39;text&#39;, encoding = &#39;latin1&#39;) %&gt;%
    read_html() %&gt;%
    html_node(&#39;table&#39;)
  
  cores &lt;- cdg_html %&gt;%
    html_nodes(xpath = &#39;//font[@color=&quot;#FF0000&quot;]&#39;) %&gt;%
    html_text()
  
  cdg_data &lt;- cdg_html %&gt;%
    html_table(header = TRUE) %&gt;%
    setNames(c(&#39;dt_jogo&#39;, &#39;mandante&#39;, &#39;placar&#39;, &#39;visitante&#39;,
               &#39;p_mandante&#39;, &#39;p_empate&#39;, &#39;p_visitante&#39;)) %&gt;% 
    mutate(p_vitorioso = cores) %&gt;% 
    as_tibble() %&gt;% 
    mutate(result = &#39;OK&#39;)
  
  cdg_data
}</code></pre>
</div>
<div id="parte-5-vetorizando-anos" class="section level2">
<h2>Parte 5: vetorizando anos</h2>
<pre class="r"><code>cdg_anos &lt;- function(anos) {
  cdg_ano_safe &lt;- failwith(tibble(result = &#39;erro&#39;), cdg_ano)
  anos %&gt;% 
    setNames(anos) %&gt;% 
    purrr::map_df(cdg_ano_safe, .id = &#39;ano&#39;)
}

d_cdg &lt;- cdg_anos(c(2014, 2015))
## Warning: Deprecated: please use `purrr::possibly()` instead</code></pre>
<hr />
</div>
</div>
<div id="exemplo-2-sabesp" class="section level1">
<h1>Exemplo 2: Sabesp</h1>
<div id="passo-0-pacotes" class="section level2">
<h2>Passo 0: pacotes</h2>
<pre class="r"><code>library(tibble)
library(httr)
library(rvest)
library(lubridate)
library(stringr)
library(purrr)
library(dplyr)</code></pre>
</div>
<div id="passo-1-acessa-pagina-principal" class="section level2">
<h2>Passo 1: acessa página principal</h2>
<pre class="r"><code>link &lt;- &#39;http://www2.sabesp.com.br/mananciais/DivulgacaoSiteSabesp.aspx&#39;
txt &lt;- GET(link)</code></pre>
</div>
<div id="passo-2-funcao-que-pega-viewstate-ou-eventvalidation-da-pagina" class="section level2">
<h2>Passo 2: função que pega viewstate ou eventvalidation da página</h2>
<pre class="r"><code># tipo pode ser &quot;#__VIEWSTATE&quot; ou &quot;#__EVENTVALIDATION&quot;
pegar_tags &lt;- function(req, tipo) {
  req %&gt;% 
    content(&#39;text&#39;) %&gt;% 
    read_html() %&gt;% 
    html_node(tipo) %&gt;% 
    html_attr(&#39;value&#39;)
}

# exemplo
viewstate &lt;- pegar_tags(txt, &quot;#__VIEWSTATE&quot;)
eventval &lt;- pegar_tags(txt, &quot;#__EVENTVALIDATION&quot;)</code></pre>
</div>
<div id="passo-3-dados-da-requisicao" class="section level2">
<h2>Passo 3: dados da requisição</h2>
<pre class="r"><code>sabesp_dados &lt;- function(data, vs, ev) {
  data &lt;- as.Date(data)
  dados &lt;- list(cmbDia = lubridate::day(data), 
                cmbMes = lubridate::month(data), 
                cmbAno = lubridate::year(data), 
                Imagebutton1.x = &#39;0&#39;, 
                Imagebutton1.y = &#39;0&#39;, 
                &#39;__VIEWSTATE&#39; = vs, 
                &#39;__EVENTVALIDATION&#39; = ev,
                &#39;__VIEWSTATEENCRYPTED&#39; = &#39;&#39;)
}

# exemplo
data &lt;- &#39;2017-02-14&#39;
form &lt;- sabesp_dados(data, viewstate, eventval)
# requisicao de busca
result &lt;- POST(link, body = form)</code></pre>
</div>
<div id="passo-4-pegar-nomes-dos-sistemas" class="section level2">
<h2>Passo 4: pegar nomes dos sistemas</h2>
<pre class="r"><code>sabesp_nm_sistemas &lt;- function(r) {
  nomes &lt;- r %&gt;% 
    content(&#39;text&#39;) %&gt;% 
    read_html() %&gt;% 
    html_nodes(&#39;img&#39;) %&gt;% 
    html_attr(&#39;src&#39;) %&gt;% 
    keep(~str_detect(.x, &#39;\\.gif$&#39;)) %&gt;% 
    map_chr(~str_match(.x, &#39;/(.+)\\.gif&#39;)[, 2])
}</code></pre>
</div>
<div id="passo-5-pegar-conteudo-da-pagina" class="section level2">
<h2>Passo 5: pegar conteúdo da página</h2>
<pre class="r"><code>sabesp_conteudo &lt;- function(r) {
  nomes &lt;- sabesp_nm_sistemas(r)
  r %&gt;% 
    content(&#39;text&#39;) %&gt;% 
    read_html() %&gt;% 
    html_node(&#39;#tabDados&#39;) %&gt;% 
    html_table(fill = TRUE) %&gt;%
    select(titulo = X1, info = X2) %&gt;%
    filter(titulo != &#39;&#39;) %&gt;%
    mutate(lugar = rep(nomes, each = 4)) %&gt;% #View
    mutate(info = info %&gt;% 
             str_extract(&#39;[-0-9, %m]+$&#39;) %&gt;% 
             str_replace_all(&#39;^[^:]+:&#39;, &#39;&#39;) %&gt;% 
             str_replace_all(&#39;,&#39;, &#39;.&#39;) %&gt;% 
             str_replace_all(&#39;[^0-9.]&#39;, &#39;&#39;) %&gt;%
             as.numeric()) %&gt;% 
    as_tibble()
}

# exemplo
sabesp_conteudo(result)
## Warning: package &#39;bindrcpp&#39; was built under R version 3.4.4
## # A tibble: 24 x 3
##    titulo                               info lugar              
##    &lt;chr&gt;                               &lt;dbl&gt; &lt;chr&gt;              
##  1 índice armazenado                    62.5 sistemaCantareira  
##  2 pluviometria do dia                   0   sistemaCantareira  
##  3 pluviometria acumulada no mês        50.1 sistemaCantareira  
##  4 pluviometria média histórica do mês 203.  sistemaCantareira  
##  5 índice armazenado                    53.9 sistemaAltoTiete   
##  6 pluviometria do dia                   0   sistemaAltoTiete   
##  7 pluviometria acumulada no mês        54   sistemaAltoTiete   
##  8 pluviometria média histórica do mês 195.  sistemaAltoTiete   
##  9 índice armazenado                    78.9 sistemaGuarapiranga
## 10 pluviometria do dia                   3.4 sistemaGuarapiranga
## # ... with 14 more rows</code></pre>
</div>
<div id="passo-5-colocar-tudo-numa-funcao" class="section level2">
<h2>Passo 5: colocar tudo numa função</h2>
<pre class="r"><code>sabesp_dia &lt;- function(data) {
  link &lt;- &#39;http://www2.sabesp.com.br/mananciais/DivulgacaoSiteSabesp.aspx&#39;
  txt &lt;- GET(link)
  viewstate &lt;- pegar_tags(txt, &quot;#__VIEWSTATE&quot;)
  eventval &lt;- pegar_tags(txt, &quot;#__EVENTVALIDATION&quot;)
  form &lt;- sabesp_dados(data, viewstate, eventval)
  result &lt;- POST(link, body = form)
  d_res &lt;- sabesp_conteudo(result) %&gt;% 
    mutate(result = &#39;OK&#39;)
  return(d_res)
}

# exemplo
sabesp_dia(&#39;2017-02-14&#39;)
## # A tibble: 24 x 4
##    titulo                               info lugar               result
##    &lt;chr&gt;                               &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt; 
##  1 índice armazenado                    62.5 sistemaCantareira   OK    
##  2 pluviometria do dia                   0   sistemaCantareira   OK    
##  3 pluviometria acumulada no mês        50.1 sistemaCantareira   OK    
##  4 pluviometria média histórica do mês 203.  sistemaCantareira   OK    
##  5 índice armazenado                    53.9 sistemaAltoTiete    OK    
##  6 pluviometria do dia                   0   sistemaAltoTiete    OK    
##  7 pluviometria acumulada no mês        54   sistemaAltoTiete    OK    
##  8 pluviometria média histórica do mês 195.  sistemaAltoTiete    OK    
##  9 índice armazenado                    78.9 sistemaGuarapiranga OK    
## 10 pluviometria do dia                   3.4 sistemaGuarapiranga OK    
## # ... with 14 more rows</code></pre>
<pre class="r"><code>sabesp_dias &lt;- function(datas) {
  sabesp_dia_safe &lt;- failwith(tibble(result = &#39;erro&#39;), sabesp_dia)
  datas %&gt;% 
    setNames(as.character(datas)) %&gt;% 
    purrr::map_df(sabesp_dia_safe, .id = &#39;data&#39;)
}

# exemplo
dts &lt;- as.Date(&#39;2017-02-14&#39;) - lubridate::days(0:13 * 30)
d_sabesp &lt;- sabesp_dias(dts)
## Warning: Deprecated: please use `purrr::possibly()` instead

library(ggplot2)
d_sabesp %&gt;% 
  filter(titulo == &#39;índice armazenado&#39;) %&gt;%
  mutate(data = ymd(data)) %&gt;% 
  ggplot(aes(x = data, y = info, colour = lugar)) +
  geom_line() +
  theme_bw()</code></pre>
<p><img src="/material/webscraping/_index_files/figure-html/unnamed-chunk-15-1.png" width="75%" /></p>
<hr />
</div>
</div>
<div id="case-study-camaras-tjsp-jurimetria" class="section level1">
<h1>Case study: câmaras TJSP (jurimetria)</h1>
<div id="melhores-praticas-para-web-scraping" class="section level2">
<h2>Melhores práticas para web scraping</h2>
<p>Esta seção contém algumas melhores práticas na contrução de ferramentas no R que baixam e processam informações de sites disponíveis na web. O objetivo é ajudar o jurimetrista a desenvolver programas que sejam fáceis de adaptar no tempo.</p>
<p>É importante ressaltar que só estamos trabalhando com páginas que são acessíveis publicamente. Caso tenha interesse e “raspar” páginas que precisam de autenticação, recomendamos que estude os termos de uso do site.</p>
<p>Para ilustrar este texto, usaremos como exemplo o código utilizado no trabalho das câmaras, que acessa o site do Tribunal de Justiça de São Paulo para obter informações de processos judiciais. Trabalharemos principalmente com a <a href="https://esaj.tjsp.jus.br/cjsg/consultaCompleta.do">Consulta de Jurisprudência</a> e a <a href="https://esaj.tjsp.jus.br/cpo/sg/open.do">Consulta de de Processos de Segundo Grau</a> do TJSP.</p>
<p>Sugerimos como melhores práticas dividir todas as atividades em três tarefas principais: i) <em>buscar</em>; ii) <em>coletar</em> e iii) <em>processar</em>. Quando já sabemos de antemão quais são as URLs que vamos acessar, a etapa de busca é desnecessária.</p>
<p>Na maior parte dos casos, deixar os algoritmos de <em>coleta</em> e <em>processamento</em> dos dados em funções distintas é uma boa prática pois aumenta o controle sobre o que as ferramentas estão fazendo, facilita o debug e a atualização. Por outro lado, em alguns casos isso pode tornar o código mais ineficiente e os arquivos obtidos podem ficar pesados.</p>
<div id="diferenca-entre-buscar-baixar-e-processar." class="section level3">
<h3>Diferença entre buscar, baixar e processar.</h3>
<p>Buscar documentos significa, de uma forma geral, utilizar ferramentas de busca (ou acessar links de um site) para obter informações de uma nova requisição a ser realizada. Ou seja, essa etapa do scraper serve para “procurar links” que não sabíamos que existiam previamente. Isso será resolvido através da função <code>cjsg</code>.</p>
<p>Baixar documentos, no entando, significa simplesmente acessar páginas pré-estabelecidas e salvá-las em disco. Em algumas situações, os documentos baixados (depois de limpos) podem conter uma nova lista de páginas a serem baixadas, formando iterações de coletas. A tarefa de baixar documentos pré-estabelecidos será realizada pela função <code>cposg</code>.</p>
<p>Finalmente, processar documentos significa carregar dados acessíveis em disco e transformar os dados brutos uma base <em>tidy</em>. Usualmente separamos a estruturação em duas etapas: i) transformar arquivos não-estruturados em um arquivos semi-estruturados (e.g. um arquivo HTML em uma tabela mais um conjunto de textos livres) e ii) transformar arquivos semi-estruturados em uma base analítica (estruturada). A tarefa de processar as páginas HTML será realizada pelas funções <code>parse_cjsg</code> e <code>parse_cpopg</code>.</p>
<p>Na pesquisa das câmaras, seguimos o fluxo</p>
<pre><code>buscar -&gt; coletar -&gt; processar -&gt; coletar -&gt; processar</code></pre>
<p>para conseguir nossos dados.</p>
</div>
</div>
<div id="buscar-documentos" class="section level2">
<h2>Buscar documentos</h2>
<p>A tarefa de listar os documentos de interesse é realizada acessando resultados de um formulário. Dependendo do site, será necessário realizar:</p>
<ul>
<li>Uma busca e uma paginação;</li>
<li>Uma busca e muitas paginações;</li>
<li>Muitas buscas e uma paginação por busca;</li>
<li>Muitas buscas e muitas paginações por busca.</li>
</ul>
<p>No TJSP temos <em>uma busca e muitas paginações</em>. Acesse a página do <a href="http://esaj.tjsp.jus.br/cjsg/consultaCompleta.do">e-SAJ</a>, digite “acordam” no campo “Pesquisa Livre” e clique em “Pesquisar”, para ter uma ideia de como é essa página.</p>
<p>A página (acessada no dia 2018-08-06) é uma ferramenta de busca com vários campos, que não permite pesquisa com dados em branco. Na parte de baixo o site mostra uma série de documentos, organizados em páginas de vinte em vinte resultados.</p>
<p>Para realizar a coleta, precisamos de duas funções principais, uma que faz a busca e outra que acessa uma página específica (que será executada várias vezes). Utilizaremos as funções <code>cjsg</code> e <code>cjsg_pag</code>.</p>
<pre class="r"><code>cjsg_session &lt;- function() {
  rvest::html_session(&#39;http://esaj.tjsp.jus.br/cjsg/consultaCompleta.do&#39;)
}</code></pre>
<pre class="r"><code>cjsg &lt;- function(s, parms = cjsg_parms(s), path = &#39;./cjsg&#39;, 
                 max_pag = 10, overwrite = FALSE,
                 verbose = TRUE, p = .05) {
  dir.create(path, recursive = TRUE, showWarnings = FALSE)
  if (!file.exists(path)) stop(sprintf(&#39;Pasta não &quot;%s&quot; pôde ser criada&#39;, path))
  r0 &lt;- s %&gt;% 
    rvest::submit_form(parms)
  n_pags &lt;- if (is.na(max_pag) || is.infinite(max_pag)) cjsg_npags(r0) else max_pag
  abjutils::dvec(cjsg_pag, 1:n_pags, path = path, ow = overwrite, s = s)
}</code></pre>
<pre class="r"><code>cjsg_pag &lt;- function(pag, path, ow, s) {
  Sys.sleep(1)
  u &lt;- &#39;http://esaj.tjsp.jus.br/cjsg/trocaDePagina.do?tipoDeDecisao=A&amp;pagina=%d&#39;
  u_pag &lt;- sprintf(u, pag)
  arq &lt;- sprintf(&#39;%s/%05d.html&#39;, path, pag)
  if (!file.exists(arq) || ow) {
    httr::GET(u_pag, httr::write_disk(arq, overwrite = ow), 
              handle = s$handle)
    tibble::data_frame(result = &#39;OK&#39;)
  } else {
    tibble::data_frame(result = &#39;já existe&#39;)
  }
}</code></pre>
<p>A função <code>cjsg_pag</code> precisa ser capaz de realizar uma pesquisa e retornar a resposta do servidoe que contém a primeira página dos resultados. Para isso, ela recebe uma lista com dados da busca (do formulário) a url base e um método para realizar a requisição, podendo ser ‘get’ ou ‘post’. Caso a pesquisa seja mais complicada, é possível adicionar também uma função que sobrepõe a busca padrão.</p>
<p>É possível visualizar a página baixada com a função <code>BROWSE</code> do pacote <code>httr</code>.</p>
<pre class="r"><code>arqs &lt;- dir(&#39;data/cjsg&#39;, full.names = TRUE)
httr::BROWSE(arqs[1])</code></pre>
<p><strong>OBS:</strong> A imagem fica “feia” pois está sem a folha de estilos e as imagens.</p>
<p>Note que criamos uma função que facilita a entrada de parâmetros de busca. No nosso exemplo, existem parâmetros necessários na requisição que não precisam ser preenchidos, e parâmetros que precisam ser preenchidos de uma maneira específica, como as datas, que precisam ser inseridas no formato <code>%d/%m/%Y</code>. Assim, incluimos uma função de “ajuda”.</p>
<pre class="r"><code>cjsg_parms &lt;- function(s, livre = &#39;&#39;, data_inicial = NULL, data_final = NULL, secoes = &#39;&#39;) {
  secoes &lt;- paste(secoes, collapse = &#39;,&#39;)
  dt_inicial &lt;- &#39;&#39;
  if (!is.null(data_inicial)) {
    dt_inicial &lt;- sprintf(&#39;%02d/%02d/%d&#39;, lubridate::day(data_inicial),
                          lubridate::month(data_inicial),
                          lubridate::year(data_inicial))
  }
  dt_final &lt;- &#39;&#39;
  if (!is.null(data_final)) {
    dt_final &lt;- sprintf(&#39;%02d/%02d/%d&#39;, lubridate::day(data_final),
                        lubridate::month(data_final),
                        lubridate::year(data_final))
  }
  suppressWarnings({
    s %&gt;% 
      rvest::html_form() %&gt;% 
      dplyr::first() %&gt;% 
      rvest::set_values(&#39;dados.buscaInteiroTeor&#39; = livre,
                        &#39;secoesTreeSelection.values&#39; = secoes,
                        &#39;dados.dtJulgamentoInicio&#39; = dt_inicial,
                        &#39;dados.dtJulgamentoFim&#39; = dt_final)
  })
}</code></pre>
<p>Também foi necessário realizar um pequeno processamento na primeira requisição, quando o usuário não souber a priori quantas páginas deseja baixar. Nesse caso, a função <code>cjsg_npags</code> identifica o número de paginações necessárias.</p>
<pre class="r"><code>cjsg_npags &lt;- function(req, parms = NULL) {
  if (!is.null(parms)) req &lt;- req %&gt;% rvest::submit_form(parms)
  num &lt;- req$response %&gt;% 
    httr::content(&#39;text&#39;) %&gt;% 
    xml2::read_html() %&gt;%
    rvest::html_node(&#39;#nomeAba-A&#39;) %&gt;% 
    rvest::html_text() %&gt;% 
    tidyr::extract_numeric()
  (num %/% 20) + 1
}</code></pre>
<p>A função <code>dvec</code> é uma função genérica que ajuda a aplicar uma função a cada elemento de determinados itens, como um <code>lapply</code>, mas que o faz de forma mais verborrágica e não resulta em erro caso um elemento dê erro.</p>
<pre class="r"><code>#&#39; Vetorizando scrapers
#&#39;
#&#39; Vetoriza um scraper (função) para um vetor de itens
#&#39;
#&#39; @param fun função a ser aplicada em cada arquivo.
#&#39; @param itens character vector dos caminhos de arquivos a serem transformados.
#&#39; @param ... outros parâmetros a serem passados para \code{fun}
#&#39; @param verbose se \code{TRUE} (default), mostra o item com probabilidade p.
#&#39; @param p probabilidade de imprimir mensagem.
#&#39; 
#&#39; @export
dvec &lt;- function(fun, itens, ..., verbose = TRUE, p = .05) {
  f &lt;- dplyr::failwith(tibble::data_frame(result = &#39;erro&#39;), fun)
  tibble::data_frame(item = itens) %&gt;%
    dplyr::distinct(item) %&gt;%
    dplyr::group_by(item) %&gt;%
    dplyr::do({
      if (runif(1) &lt; p &amp;&amp; verbose) print(.$item)
      d &lt;- f(.$item, ...)
      if (tibble::has_name(d, &#39;result&#39;)) d$result &lt;- &#39;OK&#39;
      d
    }) %&gt;%
    dplyr::ungroup()
}</code></pre>
<p>No projeto das câmaras, rodamos o seguinte código:</p>
<pre class="r"><code>library(tjsp)

sec &lt;- list_secoes_2inst() %&gt;% 
  dplyr::filter(stringr::str_detect(secao, &#39;[Cc]rim&#39;),
                stringr::str_detect(pai, &#39;CRIM&#39;)) %&gt;% 
  with(cod)

session &lt;- cjsg_session()
parms &lt;- session %&gt;% 
  cjsg_parms(secoes = sec, 
             data_inicial = &#39;2015-01-01&#39;, 
             data_final = &#39;2015-12-31&#39;)

# numero de paginas a serem baixadas
session %&gt;% cjsg_npags(parms)

d_result &lt;- session %&gt;% 
  cjsg(parms, path = &#39;data/cjsg&#39;, max_pag = 10)</code></pre>
<p><strong>Onde guardar os dados?</strong> Ao construir um scraper, é importante guardar os dados brutos na máquina ou num servidor, para reprodutibilidade e manutenção do scraper. Se estiver construindo um pacote do R, o melhor lugar para guardar esses dados é na pasta <code>data</code>, como sugerido no livro <a href="http://r-pkgs.had.co.nz">r-pkgs</a>.</p>
<p>Se os dados forem muito volumosos, pode ser necessário colocar esses documentos numa pasta externa ao pacote. Para garantir a reprodutibilidade, recomendamos a criação de um pacote no R cujo objetivo é somente baixar e processar esses dados, além da criação de um repositório na nuvem (Dropbox, por exemplo). No pacote que contém as funções de extração, guarde os dados já processados (se couberem) num arquivo <code>.rda</code> dentro da pasta <code>data</code> do pacote.</p>
</div>
<div id="coletar-processos" class="section level2">
<h2>Coletar processos</h2>
<p>Antes de coletar os processos, é necessário ler os arquivos HTML baixados na etapa anterior.</p>
<pre class="r"><code>parse_cjsg_um &lt;- function(i, nodes) {
  node &lt;- nodes[[i]]
  trim &lt;- stringr::str_trim
  id &lt;- node %&gt;%
    rvest::html_node(&#39;.ementaClass&#39;) %&gt;%
    rvest::html_text() %&gt;%
    trim() %&gt;%
    stringr::str_replace_all(&#39;[^0-9]&#39;, &#39;&#39;)
  infos &lt;- node %&gt;%
    rvest::html_node(&#39;.downloadEmenta&#39;) %&gt;% {
      tibble::tibble(n_processo = trim(rvest::html_text(.)),
                     cd_acordao = rvest::html_attr(., &#39;cdacordao&#39;))
    }
  ca &lt;- node %&gt;%
    rvest::html_node(&#39;.assuntoClasse&#39;) %&gt;%
    rvest::html_text() %&gt;%
    trim()
  tsf &lt;- node %&gt;%
    rvest::html_node(&#39;textarea&#39;) %&gt;%
    rvest::html_text()
  tab_infos &lt;- node %&gt;%
    rvest::html_nodes(&#39;.ementaClass2&#39;) %&gt;%
    rvest::html_text() %&gt;%
    stringr::str_split_fixed(&#39;:&#39;, 2) %&gt;%
    data.frame(stringsAsFactors = FALSE) %&gt;%
    setNames(c(&#39;key&#39;, &#39;val&#39;)) %&gt;%
    dplyr::mutate_all(dplyr::funs(trim(.))) %&gt;%
    dplyr::mutate(key = tolower(abjutils::rm_accent(key)),
                  key = stringr::str_replace_all(key, &#39; +&#39;, &#39;_&#39;),
                  key = stringr::str_replace_all(key, &#39;[^a-z_]&#39;, &#39;&#39;),
                  key = stringr::str_replace_all(key, &#39;_d[eo]_&#39;, &#39;_&#39;)) %&gt;%
    tidyr::spread(key, val) %&gt;%
    dplyr::bind_cols(infos) %&gt;%
    dplyr::mutate(id = id, classe_assunto = ca, txt_ementa = tsf) %&gt;%
    dplyr::select(id, cd_acordao, n_processo, dplyr::everything(), txt_ementa)
  tab_infos
}

parse_cjsg_arq &lt;- function(arq) {
  itens &lt;- xml2::read_html(arq, encoding = &#39;UTF-8&#39;) %&gt;%
    rvest::html_nodes(&#39;.fundocinza1&#39;)
  abjutils::dvec(parse_cjsg_um, 1:length(itens), nodes = itens, verbose = FALSE) %&gt;%
    dplyr::select(-item)
}

parse_cjsg &lt;- function(arqs) {
  abjutils::dvec(parse_cjsg_arq, arqs) %&gt;%
    dplyr::rename(arq = item)
}</code></pre>
<p>Rodando a função criada.</p>
<pre class="r"><code>arqs &lt;- dir(&#39;data/cjsg&#39;, full.names = TRUE)
d_cjsg &lt;- tjsp::parse_cjsg(arqs)
saveRDS(d_cjsg, &#39;data/d_cjsg.rds&#39;)</code></pre>
<pre class="r"><code>d_cjsg &lt;- readRDS(&#39;data/d_cjsg.rds&#39;)
d_cjsg
## # A tibble: 200 x 14
##    arq   id    cd_acordao n_processo comarca data_julgamento data_registro
##    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;   &lt;chr&gt;           &lt;chr&gt;        
##  1 data… 1     10120659   0053149-4… São Pa… 26/02/2015      02/02/2017   
##  2 data… 2     10092189   0011582-5… Ibitin… 10/06/2015      09/01/2017   
##  3 data… 3     10040923   0035263-7… Atibaia 25/08/2015      06/12/2016   
##  4 data… 4     10039029   0019944-6… Soroca… 30/06/2015      06/12/2016   
##  5 data… 5     10039023   0041547-9… Soroca… 15/09/2015      06/12/2016   
##  6 data… 6     10027377   0003710-9… Atibaia 15/09/2015      01/12/2016   
##  7 data… 7     9983410    7004537-0… Presid… 30/07/2015      18/11/2016   
##  8 data… 8     9956156    0004870-3… Sumaré  19/10/2015      08/11/2016   
##  9 data… 9     9901809    7007051-3… Araçat… 03/12/2015      19/10/2016   
## 10 data… 10    9899013    0087445-2… São Pa… 28/10/2015      18/10/2016   
## # ... with 190 more rows, and 7 more variables: ementa &lt;chr&gt;,
## #   orgao_julgador &lt;chr&gt;, relatora &lt;chr&gt;, classe_assunto &lt;chr&gt;,
## #   txt_ementa &lt;chr&gt;, result &lt;chr&gt;, outros_numeros &lt;chr&gt;</code></pre>
<p>Agora criamos a função que baixa processos.</p>
<pre class="r"><code>dados_cposg &lt;- function(p) {
  list(&#39;conversationId&#39; = &#39;&#39;,
       &#39;paginaConsulta&#39; = &#39;1&#39;,
       &#39;localPesquisa.cdLocal&#39; = &#39;-1&#39;,
       &#39;cbPesquisa&#39; = &#39;NUMPROC&#39;,
       &#39;tipoNuProcesso&#39; = &#39;UNIFICADO&#39;,
       &#39;numeroDigitoAnoUnificado&#39; = stringr::str_sub(p, 1, 11),
       &#39;foroNumeroUnificado&#39; = stringr::str_sub(p, -4, -1),
       &#39;dePesquisaNuUnificado&#39; = p,
       &#39;dePesquisaNuAntigo&#39; = &#39;&#39;)
}

cposg_um &lt;- function(p, path, ow) {
  Sys.sleep(1)
  arq &lt;- sprintf(&#39;%s/%s.html&#39;, path, p)
  if (!file.exists(arq) || ow) {
    httr::GET(&#39;https://esaj.tjsp.jus.br/cposg/search.do&#39;,
              query = dados_cposg(p),
              config = httr::config(ssl_verifypeer = FALSE),
              httr::write_disk(arq, overwrite = ow))
    tibble::tibble(result = &#39;OK&#39;)
  } else {
    tibble::tibble(result = &#39;já existe&#39;)
  }
}

cposg &lt;- function(processos, path = &#39;data/cposg&#39;, overwrite = FALSE) {
  suppressWarnings(dir.create(path, recursive = TRUE))
  processos &lt;- gsub(&#39;[^0-9]&#39;, &#39;&#39;, processos)
  abjutils::dvec(cposg_um, processos, path = path, ow = overwrite)
}</code></pre>
<p>Rodando a função criada.</p>
<pre class="r"><code>d_cjsg %&gt;% 
  distinct(n_processo) %&gt;% 
  with(n_processo) %&gt;% 
  tjsp::cposg(path = &#39;data/cposg&#39;)</code></pre>
<p>Extraindo as partes do arquivo HTML.</p>
<pre class="r"><code>partes_cposg_um &lt;- function(arq) {
  h &lt;- arq %&gt;% xml2::read_html(encoding = &#39;UTF-8&#39;)
  todas_partes &lt;- h %&gt;% rvest::html_nodes(&#39;#tableTodasPartes&#39;) %&gt;% length()
  if (todas_partes &gt; 0) {
    nodes &lt;- h %&gt;% 
      rvest::html_nodes(&#39;#tableTodasPartes &gt; .fundoClaro&#39;)
  } else {
    nodes &lt;- h %&gt;% 
      rvest::html_nodes(&#39;#tablePartesPrincipais &gt; .fundoClaro&#39;)
  }
  purrr::map_df(seq_along(nodes), function(i) {
    node &lt;- nodes[[i]]
    titulos &lt;- node %&gt;% 
      rvest::html_nodes(&#39;.mensagemExibindo&#39;) %&gt;% 
      rvest::html_text() %&gt;% 
      stringr::str_trim() %&gt;% 
      stringr::str_replace_all(&#39;&amp;nbsp&#39;, &#39;&#39;)
    tirar &lt;- paste(titulos, collapse = &#39;|&#39;)
    nomes &lt;- titulos %&gt;% 
      tolower() %&gt;% 
      abjutils::rm_accent() %&gt;% 
      stringr::str_replace_all(&#39;[^a-z]&#39;, &#39;&#39;) %&gt;% 
      paste(sprintf(&#39;%02d&#39;, 1:length(.)), sep = &#39;_&#39;)
    node %&gt;% 
      rvest::html_text() %&gt;% 
      stringr::str_trim() %&gt;% 
      stringr::str_replace_all(&#39;&amp;nbsp&#39;, &#39;&#39;) %&gt;% 
      stringr::str_replace_all(tirar, &#39;&#39;) %&gt;% 
      stringr::str_trim() %&gt;%
      stringr::str_split(&#39;[\n\t\r ]{2,}&#39;, simplify = TRUE) %&gt;% 
      data.frame(stringsAsFactors = FALSE) %&gt;% 
      setNames(nomes) %&gt;% 
      tidyr::gather() %&gt;% 
      tibble::as_data_frame() %&gt;% 
      tidyr::separate(key, c(&#39;tipo&#39;, &#39;id_tipo&#39;), sep = &#39;_&#39;) %&gt;% 
      dplyr::mutate(id = i) %&gt;% 
      dplyr::select(id, id_tipo, tipo, nome = value) %&gt;% 
      dplyr::mutate(result = &#39;OK&#39;)
  })
}

partes_cposg &lt;- function(arqs, verbose = FALSE) {
  abjutils::dvec(partes_cposg_um, arqs, verbose = verbose) %&gt;% 
    rename(arq = item)
}</code></pre>
<pre class="r"><code>arqs &lt;- dir(&#39;data/cposg&#39;, full.names = TRUE)
d_partes &lt;-  partes_cposg(arqs)
saveRDS(d_partes, &#39;data/d_partes.rds&#39;)
d_partes</code></pre>
<pre class="r"><code>d_partes &lt;- readRDS(&#39;data/d_partes.rds&#39;)
d_partes
## # A tibble: 762 x 6
##    arq                      id id_tipo tipo   nome                  result
##    &lt;chr&gt;                 &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;                 &lt;chr&gt; 
##  1 data-raw/cposg/00000…     1 01      aptea… Ministério Público d… OK    
##  2 data-raw/cposg/00000…     2 01      apdoa… Maycon Grolla dos Sa… OK    
##  3 data-raw/cposg/00000…     2 02      advog… João Ricardo Meira A… OK    
##  4 data-raw/cposg/00000…     3 01      apdoa… Bruno dos Santos Ara… OK    
##  5 data-raw/cposg/00000…     3 02      advog… João Ricardo Meira A… OK    
##  6 data-raw/cposg/00000…     1 01      apela… Lucas Fernando Franc… OK    
##  7 data-raw/cposg/00000…     1 02      advog… Jose Carlos Santao    OK    
##  8 data-raw/cposg/00000…     2 01      apela… Ministério Público d… OK    
##  9 data-raw/cposg/00000…     1 01      apela… Walter Alves de Arau… OK    
## 10 data-raw/cposg/00000…     1 02      advog… Geraldo Sebastiao Pa… OK    
## # ... with 752 more rows</code></pre>
<p>Extraindo as decisões.</p>
<pre class="r"><code>decisoes_cposg_um &lt;- function(arq) {
  html &lt;- xml2::read_html(arq, encoding = &#39;UTF-8&#39;)
  xpath &lt;- &#39;(//table[@width=&quot;98%&quot; and @align=&quot;center&quot;])[last()]&#39;
  r &lt;- rvest::html_node(html, xpath = xpath)
  tab &lt;- rvest::html_table(r)
  names(tab) &lt;- c(&#39;data&#39;, &#39;situacao&#39;, &#39;decisao&#39;)
  tab$result &lt;- &#39;OK&#39;
  return(tab)
}

decisoes_cposg &lt;- function(arqs, verbose = FALSE) {
  abjutils::dvec(decisoes_cposg_um, arqs, verbose = verbose) %&gt;% 
    dplyr::rename(arq = item)
}</code></pre>
<pre class="r"><code>arqs &lt;- dir(&#39;data/cposg&#39;, full.names = TRUE)
d_decisoes &lt;- decisoes_cposg(arqs)
saveRDS(d_decisoes, &#39;data/d_decisoes.rds&#39;)
d_decisoes</code></pre>
<pre><code>## # A tibble: 361 x 5
##    arq             data    situacao       decisao                   result
##    &lt;chr&gt;           &lt;chr&gt;   &lt;chr&gt;          &lt;chr&gt;                     &lt;chr&gt; 
##  1 data-raw/cposg… 16/12/… Julgado        Por votação unanime,  de… OK    
##  2 data-raw/cposg… 03/12/… Julgado        Por maioria de votos, DE… OK    
##  3 data-raw/cposg… 08/10/… Julgado        Por maioria de votos, de… OK    
##  4 data-raw/cposg… 24/09/… Adiado a pedi… Após os votos do Relator… OK    
##  5 data-raw/cposg… 17/09/… Adiado a pedi… Após o voto do Relator, … OK    
##  6 data-raw/cposg… 16/12/… Julgado        Negaram provimento ao re… OK    
##  7 data-raw/cposg… 03/12/… Julgado        por votação unânime,  de… OK    
##  8 data-raw/cposg… 29/10/… Julgado        Por maioria de votos, de… OK    
##  9 data-raw/cposg… 12/05/… Retirado de P… &quot;&quot;                        OK    
## 10 data-raw/cposg… 14/04/… Retificação d… Por unanimidade, julgara… OK    
## # ... with 351 more rows</code></pre>
<p>Visualizando!</p>
<pre class="r"><code>tipos_decisao &lt;- function(decisoes) {
  negaram &lt;- regex(&#39;negaram&#39;, ignore_case = TRUE)
  parcial &lt;- regex(&#39;parcial&#39;, ignore_case = TRUE)
  deram &lt;- regex(&#39;deram&#39;, ignore_case = TRUE)
  ifelse(
    str_detect(decisoes, negaram), &#39;negado&#39;, ifelse(
      str_detect(decisoes, parcial), &#39;parcial&#39;, ifelse(
        str_detect(decisoes, deram), &#39;provido&#39;, &#39;outros&#39;
    ))
  )
}

partes_apelacoes &lt;- d_partes %&gt;% 
  filter(tipo == &#39;apelado&#39;, str_detect(nome, &#39;[Mm]inist&#39;)) %&gt;% 
  mutate(n_processo = str_replace_all(arq, &#39;[^0-9]&#39;, &#39;&#39;)) %&gt;% 
  dplyr::select(n_processo)

decisoes &lt;- d_decisoes %&gt;% 
  mutate(n_processo = str_replace_all(arq, &#39;[^0-9]&#39;, &#39;&#39;)) %&gt;% 
  inner_join(partes_apelacoes, &#39;n_processo&#39;) %&gt;% 
  filter(situacao == &#39;Julgado&#39;) %&gt;% 
  distinct(n_processo, decisao) %&gt;%
  mutate(tipo_decisao = tipos_decisao(decisao)) %&gt;% 
  dplyr::select(n_processo, tipo_decisao)

library(ggplot2)
d_cjsg %&gt;%
  mutate(n_processo = str_replace_all(n_processo, &#39;[^0-9]&#39;, &#39;&#39;)) %&gt;% 
  inner_join(decisoes, &#39;n_processo&#39;) %&gt;% 
  filter(tipo_decisao != &#39;outros&#39;) %&gt;% 
  count(orgao_julgador, tipo_decisao) %&gt;%
  mutate(ntot = sum(n), prop = n / ntot) %&gt;%
  filter(ntot &gt; 5) %&gt;% 
  ungroup() %&gt;%
  mutate(num = readr::parse_number(orgao_julgador),
         num = sprintf(&#39;%02d&#39;, num)) %&gt;% 
  ggplot(aes(x = num, fill = tipo_decisao, y = prop)) +
  geom_bar(stat = &#39;identity&#39;, colour = &#39;black&#39;, position = &#39;dodge&#39;) +
  theme_bw() +
  scale_y_continuous(labels = scales::percent) +
  xlab(&#39;Órgão julgador&#39;) +
  ylab(&#39;Proporção de processos por tipo de decisão&#39;) +
  theme(legend.position = &quot;bottom&quot;)</code></pre>
<p><img src="/material/webscraping/_index_files/figure-html/unnamed-chunk-35-1.png" width="75%" /></p>
</div>
</div>
