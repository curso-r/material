---
title: "Manipulação"
author: "Curso-R"
date: 2018-07-18
categories: ["R"]
tags: ["Manipulação"]
slug: "manipulacao"
desc: "Em muitos projetos de ciência de dados a maior parte do trabalho está em transformar os dados para um formato que seja útil para fazer as análises. Neste tutorial vamos discutir os pacotes dplyr e tidyr que facilitam (e muito) a realização dessa tarefa."
requisitos: ["r-base"]
layout: "article"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

# Introdução

> "(...) The fact that data science exists as a field is a colossal failure of statistics. To me, what I do is what statistics is all about. It is gaining insight from data using modelling and visualization. Data munging and manipulation is hard and statistics has just said that’s not our domain."
> 
> Hadley Wickham

Esta seção trata do tema *transformação de dados*. Trata-se de uma tarefa dolorosa e demorada, tomando muitas vezes a maior parte do tempo de uma análise estatística. Essa etapa é essencial em qualquer análise de dados e, apesar de negligenciada pela academia, é decisiva para o sucesso de estudos aplicados.

Usualmente, o cientista de dados parte de uma base "crua" e a transforma até obter uma base de dados analítica. A base crua pode ser não estruturada, semi-estruturada ou estruturada. Já a base analítica é necessariamente estruturada e, a menos de transformações simples, está preparada para passar por análises estatísticas.

A figura abaixo mostra a fase de "disputa" com os dados (*data wrangling*) para deixá-los no formato analítico.

```{r transform, echo=FALSE, fig.cap='Transformação no ciclo da ciência de dados.'}
knitr::include_graphics('http://r4ds.had.co.nz/diagrams/data-science-wrangle.png')
```

Um conceito importante para obtenção de uma base analítica é o *data tidying*, ou arrumação de dados. Uma base é considerada *tidy* se

1. Cada linha da base representa uma observação.
2. Cada coluna da base representa uma variável.
3. ~~Cada tabela considera informações de uma unidade amostral.~~

A base de dados analítica é estruturada de tal forma que pode ser colocada diretamente em ambientes de modelagem estatística ou de visualização. Nem sempre uma base de dados analítica está no formato *tidy*, mas usualmente são necessários poucos passos para migrar de uma para outra. A filosofia *tidy* é a base do [tidyverse](https://www.tidyverse.org/).

Os principais pacotes encarregados da tarefa de estruturar os dados são o `dplyr` e o `tidyr`. Eles serão o tema desse tópico. Instale e carregue os pacotes utilizando:

```{r, eval=FALSE}
install.packages("dplyr")
install.packages("tidyr")

library(dplyr)
library(tidyr)
```


Mas antes de apresentar as principais funções do `dplyr` e do `tidyr`, precisamos falar sobre o conceito de `tibbles`.

```{r echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(tidyr)
library(abjData)
```

# Trabalhando com tibbles

Uma `tibble` nada mais é do que um `data.frame`, mas com um método de impressão mais adequado. 

As `tibbles` são parte do pacote `tibble`. Assim, para começar a usá-las, instale e carregue o pacote.

```{r, eval = FALSE}
install.packages("tibble")
library(tibble)
```

Mais informações sobre `tibbles` podem ser encontradas [neste link](http://r4ds.had.co.nz/tibbles.html).

Nessa seção, vamos trabalhar com uma base simplificada do [PNUD (Programa das Nações Unidas para o Desenvolvimento)](http://www.atlasbrasil.org.br/2013/pt/download/base/), contendo informações socioeconômicas de todos os municípios do país. Os resultados foram obtidos a partir dos Censos de 1991, 2000 e 2010.

A base contém `r nrow(pnud_min)` linhas e `r ncol(pnud_min)` colunas, descritas abaixo:

- `ano` - Ano do Censo utilizado como base para cálculo do IDH-Municipal e outras métricas.
- `muni` - Nome do município. Cada município aparece três vezes, um para cada ano.
- `uf` - Unidade Federativa.
- `regiao` - Região brasileira.
- `idhm` - IDH municipal, dividido em
    - `idhm_e` - IDH municipal - educação.
    - `idhm_l` - IDH municipal - longevidade.
    - `idhm_r` - IDH municipal - renda.
- `espvida` - Expectativa de vida.
- `rdpc` - Renda *per capita*.
- `gini` - Coeficiente de gini municipal (mede desigualdade social).
- `pop` - População residente do município.
- `lat`, `lon` - Latitude e longitude do município (ponto médio).

Para acessar esta base, instale e carregue o pacote `abjData` da seguinte maneira:

```{r, eval=FALSE}
devtools::install_github("abjur/abjData")
library(abjData)
```

Assim, utilizaremos o objeto `pnud_min` para acessar os dados.

```{r}
pnud_min
```

Veja que, por padrão, apenas as dez primeiras linhas da `tibble` são impressas na tela. Além disso, as colunas que não couberem na largura do console serão omitidas. Também são apresentadas a dimensão da tabela e as classes de cada coluna.

# O pacote `dplyr`

O `dplyr` é o pacote mais útil para realizar transformação de dados, aliando simplicidade e eficiência de uma forma elegante. Os scripts em R que fazem uso inteligente dos verbos `dplyr` e as facilidades do operador _pipe_ tendem a ficar mais legíveis e organizados sem perder velocidade de execução.

As principais funções do `dplyr` são:

- `filter()` - filtra linhas
- `select()` - seleciona colunas
- `mutate()` - cria/modifica colunas
- `arrange()` - ordena a base
- `summarise()` - sumariza a base

Todas essas funções seguem as mesmas características:

- O _input_  é sempre uma `tibble` e o _output_  é sempre um `tibble`.
- Colocamos o `tibble` no primeiro argumento e o que queremos fazer nos outros argumentos.
- A utilização é facilitada com o emprego do operador `%>%`.
- O pacote faz uso extensivo de NSE (*non standard evaluation*).

As principais vantagens de se usar o `dplyr` em detrimento das funções do R base são:

- Manipular dados se torna uma tarefa muito mais simples.
- O código fica mais intuitivo de ser escrito e mais simples de ser lido.
- O pacote `dplyr` utiliza `C` e `C++` por trás da maioria das funções, o que geralmente torna o código mais eficiente.
- É possível trabalhar com diferentes fontes de dados, como bases relacionais (SQL) e `data.table`.

Agora, vamos avaliar com mais detalhes os principais verbos do pacote `dplyr`.

-----------------------------------------------------

## `select()`

A função `select()` seleciona colunas (variáveis). É possível utilizar nomes, índices, intervalos de variáveis ou utilizar as funções `starts_with(x)`, `contains(x)`, `matches(x)`, `one_of(x)` para selecionar as variáveis.

```{r}
pnud_min %>% 
  select(ano, regiao, muni)
```

```{r}
pnud_min %>% 
  select(ano:regiao, rdpc)
```

```{r}
pnud_min %>% 
  select(ano, starts_with('idhm'))
```

-----------------------------------------------------

## `filter()`

A função `filter()` filtra linhas. Ela é semelhante à função `subset()`, do R base.

```{r}
pnud_min %>% 
  select(ano, muni, uf) %>% 
  filter(uf == 'AC')
```

Para fazer várias condições, use os operadores lógicos `&` e `|` ou separe filtros entre vírgulas.

```{r}
pnud_min %>% 
  select(ano, regiao, uf, idhm) %>% 
  filter(uf %in% c('SP', 'MG') | idhm > .5, ano == 2010)
```

Repare que o operador `%in%` é muito útil para trabalhar com vetores. O resultado da operação é um vetor lógico o tamanho do vetor do elemento da esquerda, identificando quais elementos da esquerda batem com algum elemento da direita.

Também podemos usar funções que retornam valores lógicos, como a `str_detect()`.

```{r}
library(stringr)

pnud_min %>% 
  select(muni, ano, uf) %>% 
  filter(str_detect(muni, '^[HG]|S$'), 
         ano == 1991)
```

-----------------------------------------------------

## `mutate()`

A função `mutate()` cria ou modifica colunas. Ela é equivalente à função `transform()`, mas aceita várias novas colunas iterativamente. Novas variáveis devem ter o mesmo número de linhas da base original (ou terem comprimento 1).

```{r}
pnud_min %>% 
  select(muni, rdpc, pop, idhm_l, espvida) %>% 
  mutate(renda = rdpc * pop, 
         razao = idhm_l / espvida)
  
```

-----------------------------------------------------

## `arrange()`

A função `arrange()` ordena a base. O argumento `desc=` pode ser utilizado para gerar uma ordem decrescente.

```{r}
pnud_min %>% 
  filter(ano == 2010) %>% 
  arrange(desc(espvida))
```

-----------------------------------------------------

## `summarise`

A função `summarise()` sumariza a base. Ela aplica uma função às variáveis, retornando um vetor de tamanho `1`. Geralmente ela é utilizada em conjunto da função `group_by()`.


```{r}
pnud_min %>% 
  group_by(regiao, uf) %>% 
  summarise(n = n(), espvida = mean(espvida)) %>% 
  arrange(regiao, desc(espvida))

# A função n() costuma ser bastante utilizada com a função summarise().
```

A função `count()` também pode ser usada para sumarizar em relação à frequência.

```{r}
pnud_min %>% 
  filter(ano == 2010) %>% 
  count(regiao, sort = TRUE) %>% 
  mutate(prop = n / sum(n), prop = scales::percent(prop))
```

## Outras funções do `dplyr`

- Para retirar duplicatas, utilizar `distinct()`.
- Para realizar operações mais gerais, usar `do`.
- Para juntar tabelas, usar `inner_join()`, `left_join()`, `anti_join()` etc.

**Exercício**: estudar o `help()` dessas funções e criar exemplos com elas utilizando a base `pnud_min`.

# O pacote `tidyr`

O pacote `tidyr` dispõe de funções úteis para deixar os seus dados no formato que você precisa para a análise. Na maioria das vezes, utilizamos para deixá-los _tidy_. Outras, precisamos "bagunçá-los" um pouco para poder aplicar alguma função.

Nesse sentido, as principais funções são a `gather()` e a `spread()`

-----------------------------------------------------

## `gather()`

A função `gather()` "empilha" o banco de dados. Ela é utilizada principalmente quando as colunas da base não representam nomes de variáveis, mas sim seus valores.

```{r warning=FALSE, message=FALSE}
pnud_min %>% 
  select(uf, muni, ano, starts_with('idhm_')) %>% 
  gather(tipo_idhm, idhm, starts_with('idhm_')) %>% 
  arrange(desc(idhm))
```

-----------------------------------------------------

## `spread()`

A função `spread()` é essencialmente o inverso da `gather()`. Ela espalha uma variável nas colunas.

```{r}
pnud_min %>% 
  select(muni, uf, ano, starts_with('idhm_')) %>% 
  gather(tipo_idhm, idhm, starts_with('idhm_')) %>% 
  spread(ano, idhm)
```

-----------------------------------------------------

## Outras funções do `tidyr`

- A função `unite()` junta duas ou mais colunas usando algum separador (`_`, por exemplo).
- A função `separate()` faz o inverso de `unite()`: transforma uma coluna em várias usando um separador.

```{r}
pnud_min %>% 
  select(muni, uf, ano, starts_with('idhm_')) %>% 
  gather(tipo_idhm, idhm, starts_with('idhm_')) %>% 
  separate(tipo_idhm, c('idhm_nm', 'tipo'), sep = '_') %>% 
  select(-idhm_nm) %>% 
  filter(ano == 2010) %>% 
  group_by(tipo) %>% 
  summarise(maior = muni[which.max(idhm)], idhm = max(idhm)) %>% 
  arrange(tipo, desc(idhm))
```
