---
title: "Pipe: %>%"
author: "Curso-R"
date: 2018-07-16
categories: ["R"]
tags: ["Pipe"]
slug: "pipe"
desc: "O pipe (%>%) é uma das funções do R com maior importância na atualidade. Seu uso revolucionou a forma com que usamos o R e influencia a criação de pacotes com interface intuitiva."
requisitos: ["r-base"]
layout: "article"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

```{r, include=FALSE}
library(magrittr)
```

# O operador `%>%`

O operador `%>%` (*pipe*) foi uma das grandes revoluções recentes do R, tornando a leitura de códigos mais lógica, fácil e compreensível. Ele foi introduzido por [Stefan Milton Bache](https://github.com/smbache) no pacote `magrittr` e já existem diversos pacotes construidos para facilitar a sua utilizaçăo.

Para começar a utilizar o *pipe*, instale e carregue o pacote `magrittr`.

```{r eval=FALSE}
install.packages("magrittr")
library(magrittr)
```

A ideia do operador `%>%` (*pipe*) é bem simples: usar o valor resultante da expressão do lado esquerdo como primeiro argumento da função do lado direito. 

```{r, eval=FALSE}
# As duas linhas abaixo são equivalentes.

f(x, y)
x %>% f(y)
```

Nos casos mais simples, o *pipe* parece não trazer grandes vantagens. Agora, veja como fica um caso mais etapas.

```{r}
# Vamos calcular a raiz quadrada da soma dos valores de 1 a 4. Primeiro, sem o pipe.

x <- c(1, 2, 3, 4)
sqrt(sum(x))

# Agora com o pipe.

x %>% sum %>% sqrt
```

O caminho que o código `x %>% sum %>% sqrt` seguiu foi enviar o objeto `x` como argumento da função `sum()` e, em seguida, enviar a saida da expressão `sum(x)` como argumento da função `sqrt()`. Observe que escrevemos o código na mesma ordem das operações e que não é necessário colocar os parênteses após o nome das funções.

Se você ainda não está convencido com o poder do *pipe*, fica que vai ter bolo!

No exemplo abaixo, vamos ilustrar um caso em que temos um grande número de funções aninhadas. Veja como a utilização do *pipe* transforma um código confuso e difícil de ser lido em algo simples e intuitivo.


```{r, eval=FALSE}
# Receita de bolo sem pipe. Tente entender o que é preciso fazer.

esfrie(asse(coloque(bata(acrescente(recipiente(rep("farinha", 2), "água", "fermento", "leite", "óleo"), "farinha", até = "macio"), duração = "3min"), lugar = "forma", tipo = "grande", untada = TRUE), duração = "50min"), "geladeira", "20min")


# Veja como o código acima pode ser reescrito utilizando-se o pipe. Agora realmente se parece com uma receita de bolo.

recipiente(rep("farinha", 2), "água", "fermento", "leite", "óleo") %>%
  acrescente("farinha", até = "macio") %>%
  bata(duração = "3min") %>%
  coloque(lugar = "forma", tipo = "grande", untada = TRUE) %>%
  asse(duração = "50min") %>%
  esfrie("geladeira", "20min")

```

Às vezes, queremos que o resultado do lado esquerdo vá para outro argumento do lado direito que não o primeiro. Para isso, utilizamos um `.` como marcador.

```{r}
# Queremos que o dataset seja recebido pelo segundo argumento (data=) da função "lm".

airquality %>%
  na.omit %>% 
  lm(Ozone ~ Wind + Temp + Solar.R, data = .) %>% 
  summary
```

O *pipe* é a força da gravidade dentro do `tidyverse`. Veremos nas próximas seções como as funções de diferentes pacotes interagem perfeitamente graças a esse operador.

Para mais informações sobre o `pipe`, outros operadores relacionados e exemplos de utilização, visite a página [Ceci n'est pas un pipe](http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html).

# Exercícios

--------------------------------------------------------------------------------

**1.**

Reescreva a expressão abaixo utilizando o `%>%`.

```{r, collapse = TRUE, eval = FALSE}
round(mean(sum(1:10)/3), digits = 1)
```

**Dica**: utilize a função `magrittr::divide_by()`. Veja o help da função para mais informações.

--------------------------------------------------------------------------------

**2.**

Reescreva o código abaixo utilizando o `%>%`.

```{r, collapse = TRUE, eval = FALSE}

x <- rnorm(100)

x.pos <- x[x>0]

media <- mean(x.pos)

saida <- round(media, 1)

```

--------------------------------------------------------------------------------

**3.**

Sem rodar, diga qual a saída do código abaixo. Consulte o help das funções caso precise.

```{r, collapse = TRUE, eval = FALSE}
2 %>% 
  add(2) %>% 
  c(6, NA) %>% 
  mean(na.rm = T) %>% 
  equals(5)
```

--------------------------------------------------------------------------------

**4.**

Leia o capítulo sobre *pipes* do [R for data science](http://r4ds.had.co.nz/pipes.html). É curto e vale muito a pena.

--------------------------------------------------------------------------------

**5.**

Pegue algum script que você já tenha programado em R e o reescreva utilizando o operador *pipe*. Se você não tiver nenhum, não se preocupe. Utilizaremos **bastante** o *pipe* daqui pra frente.

# Respostas

<div class='admonition note'>
<p class='admonition-title'>
Nota
</p>
<p>
Não há apenas uma maneira de resolver os exercícios. Você pode encontrar soluções diferentes das nossas, algumas vezes mais eficientes, outras vezes menos. Quando estiver fazendo suas análises, tente buscar o equilíbrio entre eficiência e praticidade. Economizar 1 hora com a execução do código pode não valer a pena se você demorou 2 horas a mais para programá-lo.
</p>
</div>

--------------------------------------------------------------------------------

**1.**

Reescreva a expressão abaixo utilizando o `%>%`.

```{r, collapse = TRUE}
round(mean(sum(1:10)/3), digits = 1)

1:10 %>% 
  sum %>% 
  divide_by(3) %>% 
  round(digits = 1)
```

--------------------------------------------------------------------------------

**2.**

Reescreva o código abaixo utilizando o `%>%`.

```{r, collapse = TRUE}

# Setamos a semente que gera números aleatórios para deixar o resultado reprodutível

set.seed(137)

x <- rnorm(100)
x.pos <- x[x>0]
media <- mean(x.pos)
saida <- round(media, 2)
saida

set.seed(137)

rnorm(100) %>% 
  extract(. > 0) %>% 
  mean %>%
  round(digits = 2)

```

--------------------------------------------------------------------------------

**3.**

Sem rodar, diga qual a saída do código abaixo. Consulte o help das funções caso precise.

```{r, eval = FALSE, collapse = TRUE}
2 %>% 
  add(2) %>% 
  c(6, NA) %>% 
  mean(na.rm = T) %>% 
  equals(5)
```

- Primeiro, somamos 2 com 2, gerando o valor 4.
- Então colocamos esse valor em um vetor com os valores 6 e `NA`.
- Em seguida, tiramos a média desse vetor, desconsiderando o `NA`, obtendo o valor 5.
- Por fim, testemos se o valor é igual a 5, obtendo o valor `TRUE`.