<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Curso-R</title>
    <link>/index.xml</link>
    <description>Recent content on Curso-R</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <copyright>Disponível sobre Licença MIT</copyright>
    <lastBuildDate>Fri, 10 Mar 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Instalação</title>
      <link>/instalacao/</link>
      <pubDate>Fri, 10 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/instalacao/</guid>
      <description>

&lt;p&gt;A seguir teremos alguns tutoriais de instalação do R, RStudio e alguns pacotes
nos principais sistemas operacionais.&lt;/p&gt;

&lt;h2 id=&#34;instalação-no-windows&#34;&gt;Instalação no Windows&lt;/h2&gt;

&lt;h3 id=&#34;instalação-do-r&#34;&gt;Instalação do R&lt;/h3&gt;

&lt;p&gt;Para instalar o R no Windows, o primeiro passo é fazer o download do instalador.
Entre &lt;a href=&#34;https://cran.r-project.org/bin/windows/base/&#34;&gt;neste link&lt;/a&gt; e clique em
&amp;ldquo;Download R 3.3.3 for Windows (71 megabytes, &lt;sup&gt;32&lt;/sup&gt;&amp;frasl;&lt;sub&gt;64&lt;/sub&gt; bit)&amp;rdquo; (a versão pode não ser
a mesma.).&lt;/p&gt;

&lt;p&gt;Salve este arquivo em qualquer pasta do seu computador. No meu caso salvei na pasta
&amp;ldquo;Downloads&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/01-r-salvo.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Clique duas vezes com o botão esquerdo neste arquivo. Ele pedirá para você selecionar
a linguagem da instalação. Selecione o idioma do seu interesse e clique em OK.
Em seguida é só ir clicando em avançar, como em uma instalação comum. Preste a atenção
apenas na tela em que ele pede para você escolher a pasta de instalação. Se você escolher
uma pasta que não está dentro da pasta do seu usuário, você precisará de acesso de
administrador. Se escolher uma pasta dentro do seu usuário (como na imagem abaixo),
não precisará.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/06-r-pasta.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Clique em avançar até o final e depois em concluir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/09-conclusao.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pronto! Agora o R está instalado!&lt;/p&gt;

&lt;h3 id=&#34;instalação-do-rstudio&#34;&gt;Instalação do RStudio&lt;/h3&gt;

&lt;p&gt;Agora vamos instalar o RStudio, a IDE que usamos para editar e executar códigos em
R. Para fazer o download, entre &lt;a href=&#34;https://www.rstudio.com/products/rstudio/download/&#34;&gt;nesta página&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/rstudio-download-opt.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nessa página você tem duas opções:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Se você tiver acesso administrador, baixe a versão que está na lista de &lt;em&gt;Installers for Supported Platforms&lt;/em&gt;.  Em seguida a instalação
será bem simples: fazer o download, abrir o instalador e ir clicando no botão
avançar.&lt;/li&gt;
&lt;li&gt;Se você não tiver acesso de administrador na máquina faça o download da versão
que está na lista &lt;em&gt;Zip/Tarballs&lt;/em&gt;. (veja imagem acima)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;1-instalando-se-você-for-administrador&#34;&gt;1.  Instalando se você for administrador&lt;/h4&gt;

&lt;p&gt;Clique duas vezes no arquivo que você fez o download da página do RStudio (ver
imagem abaixo) e siga as instruções de instalação.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/rstudio-instalador.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-instalação-se-você-não-for-administrador&#34;&gt;2. Instalação se você não for administrador&lt;/h4&gt;

&lt;p&gt;Se você não for administrador, você deve ter feito o download de um arquivo do tipo
&lt;em&gt;.zip&lt;/em&gt; que contém o código do RStudio. É o arquivo selecionado na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/rstudio-zip.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Clique com o botão direito neste arquivo e dedpois em &lt;em&gt;Extrair Tudo&lt;/em&gt; conforme a
imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/rstudio-extrair.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Você verá uma tela como a imagem a seguir. Não mude nada e clique em extrair.
Espere o Windows completar a extração.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/extrair-tudo-rstudio.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora na pasta &lt;em&gt;Downloads&lt;/em&gt; (a pasta que deixamos como local de extração - imagem acima)
você terá uma pasta chamada: &lt;code&gt;RStudio-1.0.136&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Abra essa pasta e entre na subpasta com nome &lt;code&gt;bin&lt;/code&gt;. Em seguida procure pelo arquivo]chamado &lt;code&gt;rstudio&lt;/code&gt;
e clique duas vezes. Isso abrirá o RStudio. Recomendo fixar o programa na barra de tarefas
para não ter que ficar procurando nessa pasta sempre que quiser abrí-la.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: se você excluir a pasta que extraimos, o RStudio irá parar de funcionar.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/rstudio-bin.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;instalação-de-pacotes-do-r&#34;&gt;Instalação de pacotes do R&lt;/h3&gt;

&lt;p&gt;Com o RStudio aberto, você verá a seguinte tela. Digite &lt;code&gt;install.packages(&amp;quot;tidyverse&amp;quot;)&lt;/code&gt; no console e aperte &lt;code&gt;Enter&lt;/code&gt;, como está na imagem abaixo. Isso irá instalar uma série de pacotes muito
utilizados no R. Ao rodar este código uma série de comandos aparecerá no console,
no final de tudo você deve encontrar algo do tipo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package ‘tidyverse’ successfully unpacked and MD5 sums checked

The downloaded binary packages are in
	C:\Users\dfigueiredo\AppData\Local\Temp\Rtmpym4SPN\downloaded_packages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Indicando que o pacote foi instalado corretamente.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/rstudio-tidyverse.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introdução</title>
      <link>/scrape/</link>
      <pubDate>Wed, 15 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/scrape/</guid>
      <description>

&lt;h2 id=&#34;pacotes-httr-xml2-e-rvest&#34;&gt;Pacotes &lt;code&gt;httr&lt;/code&gt;, &lt;code&gt;xml2&lt;/code&gt; e &lt;code&gt;rvest&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Esses são os três pacotes mais modernos do R utilizados para fazer web scraping.
O pacote &lt;code&gt;xml2&lt;/code&gt; tem a finalidade de estruturar arquivos HTML ou XML de forma eficiente,
tornando possível a obtenção de &lt;em&gt;tags&lt;/em&gt; e seus atributos dentro de um arquivo.
Já o pacote &lt;code&gt;httr&lt;/code&gt; é responsável por realizar requisições web para
obtenção das páginas de interesse,
buscando reduzir ao máximo a complexidade da programação.
O pacote &lt;code&gt;rvest&lt;/code&gt; é escrito &lt;strong&gt;sobre&lt;/strong&gt; os dois anteriores e por isso
eleva ainda mais o nível de especialização para raspagem de dados.&lt;/p&gt;

&lt;p&gt;As características dos pacotes implicam na seguinte regra de bolso.
Para trabalhar com páginas simples,
basta carregar o &lt;code&gt;rvest&lt;/code&gt; e utilizar suas funcionalidades.
Caso o acesso à página exija ações mais complexas e/ou
artifícios de ferramentas web, será necessário utilizar o &lt;code&gt;httr&lt;/code&gt;.
O &lt;code&gt;xml2&lt;/code&gt; só será usado explicitamente nos casos raros em que
a página está em XML, que pode ser visto como uma generalização do HTML.&lt;/p&gt;

&lt;p&gt;Esses pacotes não são suficientes para acessar todo tipo de conteúdo da web.
Um exemplo claro disso são páginas em que o conteúdo é produzido por &lt;code&gt;javascript&lt;/code&gt;,
o que acontece em muitos sites modernos.
Para trabalhar com esses sites, é necessário realmente &amp;ldquo;simular&amp;rdquo; um navegador que
acessa a página web. Uma das melhores ferramentas para isso é o &lt;code&gt;selenium&lt;/code&gt;.
Não discutiremos &lt;code&gt;selenium&lt;/code&gt; nesse curso, mas caso queira se aprofundar, acesse
&lt;a href=&#34;http://www.seleniumhq.org/&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sessões-e-cookies&#34;&gt;Sessões e cookies&lt;/h3&gt;

&lt;p&gt;No momento que acessamos uma página web,
nosso navegador baixa alguns arquivos que &amp;ldquo;identificam&amp;rdquo; nosso acesso à página.
Esses arquivos são chamados cookies e
são usados pelos sites para realizar diversas atividades,
como carregar uma página pré-definida pelo usuário caso este acesse o site pela segunda vez.&lt;/p&gt;

&lt;p&gt;O &lt;code&gt;httr&lt;/code&gt; e por consequência o &lt;code&gt;rvest&lt;/code&gt; já guardam esses cookies de forma automática,
de forma que o usuário não precise se preocupar com isso.
Em casos raros, para construir o web scraper é necessário modificar esses cookies.
Nesses casos, estude a função &lt;code&gt;cookies()&lt;/code&gt; do &lt;code&gt;httr&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;get-e-post&#34;&gt;&lt;code&gt;GET&lt;/code&gt; e &lt;code&gt;POST&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Uma requisição &lt;strong&gt;GET&lt;/strong&gt; envia uma &lt;code&gt;url&lt;/code&gt; ao servidor, possivelmente com alguns parâmetros nessa &lt;code&gt;url&lt;/code&gt;
(que ficam no final da &lt;code&gt;url&lt;/code&gt; depois do &lt;code&gt;?&lt;/code&gt;). O servidor, por sua vez, recebe essa &lt;code&gt;url&lt;/code&gt;,
processa os parâmetros e retorna uma página HTML para o navegador.&lt;/p&gt;

&lt;p&gt;A requisição &lt;strong&gt;POST&lt;/strong&gt;, no entanto, envia uma &lt;code&gt;url&lt;/code&gt; não modificada para o servidor,
mas envia também uma lista de dados preenchidos pelo usuário,
que podem ser números, textos ou até imagens.
Na maioria dos casos, ao submeter um formulário de um site,
fazemos uma requisição POST.&lt;/p&gt;

&lt;p&gt;O &lt;code&gt;httr&lt;/code&gt; possui os métodos &lt;code&gt;GET&lt;/code&gt; e &lt;code&gt;POST&lt;/code&gt; implementados e são muito similares.
A lista de parâmetros enviados pelo usuário pode ser armazenado numa &lt;code&gt;list&lt;/code&gt; nomeada,
e adicionado ao &lt;code&gt;GET&lt;/code&gt; pelo parâmetro &lt;code&gt;query&lt;/code&gt; ou no &lt;code&gt;POST&lt;/code&gt; pelo parâmetro &lt;code&gt;body&lt;/code&gt;.
Veremos exemplos disso mais adiante.&lt;/p&gt;

&lt;h3 id=&#34;outras-funções-do-httr&#34;&gt;Outras funções do &lt;code&gt;httr&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Outras funções úteis:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;write_disk()&lt;/code&gt; para escrever uma requisição direto em disco, além de guardar na memória RAM.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config()&lt;/code&gt; para adicionar configurações adicionais. Por exemplo, quando acessar uma página &lt;code&gt;https&lt;/code&gt; com certificados inadequados numa requisição GET, rode &lt;code&gt;GET(&#39;https://www...&#39;, config(ssl_verifypeer=F))&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oauth_app()&lt;/code&gt; para trabalhar com APIs. Não discutiremos conexão com APIs nesse curso, mas é um importante conceito a ser estudado.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;principais-funções-do-rvest&#34;&gt;Principais funções do &lt;code&gt;rvest&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(rvest)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Loading required package: xml2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Para acessar páginas da web:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;html_session()&lt;/code&gt; abre uma sessão do usuário (baixa página, carrega cookies etc).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;follow_link()&lt;/code&gt;, &lt;code&gt;jump_to()&lt;/code&gt; acessa uma página web a partir de um link (tag &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;) ou url.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;html_form()&lt;/code&gt; carrega todos os formulários contidos numa página.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set_value()&lt;/code&gt; atribui valores a parâmetros do formulário.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;submit_form()&lt;/code&gt; submete um formulário obtido em &lt;code&gt;html_form&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Para trabalhar com arquivos HTML:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;read_html()&lt;/code&gt; lê o arquivo HTML de forma estruturada e facilita impressão.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;html_nodes()&lt;/code&gt; cria uma lista com os nós identificados por uma busca em CSS path ou XPath.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;html_node()&lt;/code&gt; é um caso especial que assume que só será encontrado um resultado.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;html_text()&lt;/code&gt; extrai todo o conteúdo de um objeto e retorna um texto.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;html_table()&lt;/code&gt; extrai o conteúdo de uma &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; e transforma em um &lt;code&gt;data_frame&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;html_attr()&lt;/code&gt; extrai um atributo de uma tag, por exemplo &lt;code&gt;href&lt;/code&gt; da tag &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;css-path-e-xpath&#34;&gt;CSS path e XPath&lt;/h3&gt;

&lt;p&gt;O CSS path e o XPath são formas distintas de buscar tags dentro de um documento HTML.
O CSS path é mais simples de implementar e tem uma sintaxe menos verborrágica,
mas o XPath é mais poderoso. A regra de bolso é tentar fazer a seleção primeiro em CSS e,
caso não seja possível, implementar em XPath.&lt;/p&gt;

&lt;p&gt;Esses paths serão mostrados &lt;em&gt;en passant&lt;/em&gt; durante o curso,
mas não serão abordados em detalhe.
Caso queira se aprofundar no assunto,
comece pela ajuda da função &lt;code&gt;?html_nodes&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;apis-com-httr&#34;&gt;APIs com &lt;code&gt;httr&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;O &lt;code&gt;httr&lt;/code&gt; foi criado pensando-se nas modernas APIs que vêm sendo desenvolvidas
nos últimos anos. O &lt;code&gt;httr&lt;/code&gt; já tem métodos apropriados para trabalhar com
Facebook, Twitter e Google, entre outros.&lt;/p&gt;

&lt;p&gt;Para um guia completo de como utilizar APIs no R,
acesse &lt;a href=&#34;https://cran.r-project.org/web/packages/httr/vignettes/api-packages.html&#34;&gt;esse tutorial&lt;/a&gt;.
Um exemplo de pacote que utiliza API usando esse tutorial melhores práticas pode ser
&lt;a href=&#34;https://github.com/jtrecenti/sptrans&#34;&gt;acessado aqui&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;exemplo-1-chance-de-gol&#34;&gt;Exemplo 1: chance de gol&lt;/h1&gt;

&lt;h2 id=&#34;parte-0-pacotes&#34;&gt;Parte 0: pacotes&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(tibble)
library(httr)
library(rvest)
library(dplyr)
library(ggplot2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parte-1-acessando-a-página-de-um-ano&#34;&gt;Parte 1: acessando a página de um ano&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ano &amp;lt;- 2015
cdg_url &amp;lt;- sprintf(&#39;http://www.chancedegol.com.br/br%02d.htm&#39;, ano - 2000)

cdg_html &amp;lt;- cdg_url %&amp;gt;%
  httr::GET() %&amp;gt;%
  httr::content(&#39;text&#39;, encoding = &#39;latin1&#39;) %&amp;gt;%
  xml2::read_html() %&amp;gt;%
  rvest::html_node(&#39;table&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parte-2-cores-da-tabela&#34;&gt;Parte 2: cores da tabela&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cores &amp;lt;- cdg_html %&amp;gt;%
  html_nodes(xpath = &#39;//font[@color=&amp;quot;#FF0000&amp;quot;]&#39;) %&amp;gt;%
  html_text()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parte-3-nomes-e-estrutura-da-tabela&#34;&gt;Parte 3: nomes e estrutura da tabela&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cdg_data &amp;lt;- cdg_html %&amp;gt;%
  html_table(header = TRUE) %&amp;gt;%
  setNames(c(&#39;dt_jogo&#39;, &#39;mandante&#39;, &#39;placar&#39;, &#39;visitante&#39;,
             &#39;p_mandante&#39;, &#39;p_empate&#39;, &#39;p_visitante&#39;)) %&amp;gt;% 
  mutate(p_vitorioso = cores) %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  mutate(result = &#39;OK&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parte-4-colocando-dentro-de-uma-função&#34;&gt;Parte 4: colocando dentro de uma função&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cdg_ano &amp;lt;- function(ano) {
  cdg_url &amp;lt;- sprintf(&#39;http://www.chancedegol.com.br/br%02d.htm&#39;, ano - 2000)
  
  cdg_html &amp;lt;- cdg_url %&amp;gt;%
    GET() %&amp;gt;%
    content(&#39;text&#39;, encoding = &#39;latin1&#39;) %&amp;gt;%
    read_html() %&amp;gt;%
    html_node(&#39;table&#39;)
  
  cores &amp;lt;- cdg_html %&amp;gt;%
    html_nodes(xpath = &#39;//font[@color=&amp;quot;#FF0000&amp;quot;]&#39;) %&amp;gt;%
    html_text()
  
  cdg_data &amp;lt;- cdg_html %&amp;gt;%
    html_table(header = TRUE) %&amp;gt;%
    setNames(c(&#39;dt_jogo&#39;, &#39;mandante&#39;, &#39;placar&#39;, &#39;visitante&#39;,
               &#39;p_mandante&#39;, &#39;p_empate&#39;, &#39;p_visitante&#39;)) %&amp;gt;% 
    mutate(p_vitorioso = cores) %&amp;gt;% 
    as_tibble() %&amp;gt;% 
    mutate(result = &#39;OK&#39;)
  
  cdg_data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parte-5-vetorizando-anos&#34;&gt;Parte 5: vetorizando anos&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cdg_anos &amp;lt;- function(anos) {
  cdg_ano_safe &amp;lt;- failwith(tibble(result = &#39;erro&#39;), cdg_ano)
  anos %&amp;gt;% 
    setNames(anos) %&amp;gt;% 
    purrr::map_df(cdg_ano_safe, .id = &#39;ano&#39;)
}

d_cdg &amp;lt;- cdg_anos(c(2014, 2015))
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;exemplo-2-sabesp&#34;&gt;Exemplo 2: Sabesp&lt;/h1&gt;

&lt;h2 id=&#34;passo-0-pacotes&#34;&gt;Passo 0: pacotes&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(tibble)
library(httr)
library(rvest)
library(lubridate)
library(stringr)
library(purrr)
library(dplyr)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;passo-1-acessa-página-principal&#34;&gt;Passo 1: acessa página principal&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;link &amp;lt;- &#39;http://www2.sabesp.com.br/mananciais/DivulgacaoSiteSabesp.aspx&#39;
txt &amp;lt;- GET(link)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;passo-2-função-que-pega-viewstate-ou-eventvalidation-da-página&#34;&gt;Passo 2: função que pega viewstate ou eventvalidation da página&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# tipo pode ser &amp;quot;#__VIEWSTATE&amp;quot; ou &amp;quot;#__EVENTVALIDATION&amp;quot;
pegar_tags &amp;lt;- function(req, tipo) {
  req %&amp;gt;% 
    content(&#39;text&#39;) %&amp;gt;% 
    read_html() %&amp;gt;% 
    html_node(tipo) %&amp;gt;% 
    html_attr(&#39;value&#39;)
}

# exemplo
viewstate &amp;lt;- pegar_tags(txt, &amp;quot;#__VIEWSTATE&amp;quot;)
eventval &amp;lt;- pegar_tags(txt, &amp;quot;#__EVENTVALIDATION&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;passo-3-dados-da-requisição&#34;&gt;Passo 3: dados da requisição&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sabesp_dados &amp;lt;- function(data, vs, ev) {
  data &amp;lt;- as.Date(data)
  dados &amp;lt;- list(cmbDia = lubridate::day(data), 
                cmbMes = lubridate::month(data), 
                cmbAno = lubridate::year(data), 
                Imagebutton1.x = &#39;0&#39;, 
                Imagebutton1.y = &#39;0&#39;, 
                &#39;__VIEWSTATE&#39; = vs, 
                &#39;__EVENTVALIDATION&#39; = ev,
                &#39;__VIEWSTATEENCRYPTED&#39; = &#39;&#39;)
}

# exemplo
data &amp;lt;- &#39;2017-02-14&#39;
form &amp;lt;- sabesp_dados(data, viewstate, eventval)
# requisicao de busca
result &amp;lt;- POST(link, body = form)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;passo-4-pegar-nomes-dos-sistemas&#34;&gt;Passo 4: pegar nomes dos sistemas&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sabesp_nm_sistemas &amp;lt;- function(r) {
  nomes &amp;lt;- r %&amp;gt;% 
    content(&#39;text&#39;) %&amp;gt;% 
    read_html() %&amp;gt;% 
    html_nodes(&#39;img&#39;) %&amp;gt;% 
    html_attr(&#39;src&#39;) %&amp;gt;% 
    keep(~str_detect(.x, &#39;\\.gif$&#39;)) %&amp;gt;% 
    map_chr(~str_match(.x, &#39;/(.+)\\.gif&#39;)[, 2])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;passo-5-pegar-conteúdo-da-página&#34;&gt;Passo 5: pegar conteúdo da página&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sabesp_conteudo &amp;lt;- function(r) {
  nomes &amp;lt;- sabesp_nm_sistemas(r)
  r %&amp;gt;% 
    content(&#39;text&#39;) %&amp;gt;% 
    read_html() %&amp;gt;% 
    html_node(&#39;#tabDados&#39;) %&amp;gt;% 
    html_table(fill = TRUE) %&amp;gt;%
    select(titulo = X1, info = X2) %&amp;gt;%
    filter(titulo != &#39;&#39;) %&amp;gt;%
    mutate(lugar = rep(nomes, each = 4)) %&amp;gt;% #View
    mutate(info = info %&amp;gt;% 
             str_extract(&#39;[-0-9, %m]+$&#39;) %&amp;gt;% 
             str_replace_all(&#39;^[^:]+:&#39;, &#39;&#39;) %&amp;gt;% 
             str_replace_all(&#39;,&#39;, &#39;.&#39;) %&amp;gt;% 
             str_replace_all(&#39;[^0-9.]&#39;, &#39;&#39;) %&amp;gt;%
             as.numeric()) %&amp;gt;% 
    as_tibble()
}

# exemplo
sabesp_conteudo(result)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## # A tibble: 24 × 3
##                           titulo  info               lugar
##                            &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;               &amp;lt;chr&amp;gt;
## 1              volume armazenado  62.5   sistemaCantareira
## 2            pluviometria do dia   0.0   sistemaCantareira
## 3  pluviometria acumulada no mês  50.1   sistemaCantareira
## 4         média histórica do mês 203.4   sistemaCantareira
## 5              volume armazenado  53.9    sistemaAltoTiete
## 6            pluviometria do dia   0.0    sistemaAltoTiete
## 7  pluviometria acumulada no mês  54.0    sistemaAltoTiete
## 8         média histórica do mês 194.9    sistemaAltoTiete
## 9              volume armazenado  78.9 sistemaGuarapiranga
## 10           pluviometria do dia   3.4 sistemaGuarapiranga
## # ... with 14 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;passo-5-colocar-tudo-numa-função&#34;&gt;Passo 5: colocar tudo numa função&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sabesp_dia &amp;lt;- function(data) {
  link &amp;lt;- &#39;http://www2.sabesp.com.br/mananciais/DivulgacaoSiteSabesp.aspx&#39;
  txt &amp;lt;- GET(link)
  viewstate &amp;lt;- pegar_tags(txt, &amp;quot;#__VIEWSTATE&amp;quot;)
  eventval &amp;lt;- pegar_tags(txt, &amp;quot;#__EVENTVALIDATION&amp;quot;)
  form &amp;lt;- sabesp_dados(data, viewstate, eventval)
  result &amp;lt;- POST(link, body = form)
  d_res &amp;lt;- sabesp_conteudo(result) %&amp;gt;% 
    mutate(result = &#39;OK&#39;)
  return(d_res)
}

# exemplo
sabesp_dia(&#39;2017-02-14&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## # A tibble: 24 × 4
##                           titulo  info               lugar result
##                            &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;               &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;
## 1              volume armazenado  62.5   sistemaCantareira     OK
## 2            pluviometria do dia   0.0   sistemaCantareira     OK
## 3  pluviometria acumulada no mês  50.1   sistemaCantareira     OK
## 4         média histórica do mês 203.4   sistemaCantareira     OK
## 5              volume armazenado  53.9    sistemaAltoTiete     OK
## 6            pluviometria do dia   0.0    sistemaAltoTiete     OK
## 7  pluviometria acumulada no mês  54.0    sistemaAltoTiete     OK
## 8         média histórica do mês 194.9    sistemaAltoTiete     OK
## 9              volume armazenado  78.9 sistemaGuarapiranga     OK
## 10           pluviometria do dia   3.4 sistemaGuarapiranga     OK
## # ... with 14 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sabesp_dias &amp;lt;- function(datas) {
  sabesp_dia_safe &amp;lt;- failwith(tibble(result = &#39;erro&#39;), sabesp_dia)
  datas %&amp;gt;% 
    setNames(as.character(datas)) %&amp;gt;% 
    purrr::map_df(sabesp_dia_safe, .id = &#39;data&#39;)
}

# exemplo
dts &amp;lt;- as.Date(&#39;2017-02-14&#39;) - lubridate::days(0:13 * 30)
d_sabesp &amp;lt;- sabesp_dias(dts)

library(ggplot2)
d_sabesp %&amp;gt;% 
  filter(titulo == &#39;volume armazenado&#39;) %&amp;gt;% 
  mutate(data = ymd(data)) %&amp;gt;% 
  ggplot(aes(x = data, y = info, colour = lugar)) +
  geom_line() +
  theme_bw()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-16-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-16&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;case-study-câmaras-tjsp-jurimetria&#34;&gt;Case study: câmaras TJSP (jurimetria)&lt;/h1&gt;

&lt;h2 id=&#34;melhores-práticas-para-web-scraping&#34;&gt;Melhores práticas para web scraping&lt;/h2&gt;

&lt;p&gt;Esta seção contém algumas melhores práticas na contrução de ferramentas no R
que baixam e processam informações de sites disponíveis na web.
O objetivo é ajudar o jurimetrista a desenvolver programas que sejam fáceis
de adaptar no tempo.&lt;/p&gt;

&lt;p&gt;É importante ressaltar que só estamos trabalhando com páginas que
são acessíveis publicamente. Caso tenha interesse e &amp;ldquo;raspar&amp;rdquo; páginas que
precisam de autenticação, recomendamos que estude os termos de uso do site.&lt;/p&gt;

&lt;p&gt;Para ilustrar este texto, usaremos como exemplo o código utilizado no trabalho das câmaras,
que acessa o site do Tribunal de Justiça de São Paulo para obter informações de
processos judiciais.
Trabalharemos principalmente com a
&lt;a href=&#34;https://esaj.tjsp.jus.br/cjsg/consultaCompleta.do&#34;&gt;Consulta de Jurisprudência&lt;/a&gt; e a
&lt;a href=&#34;https://esaj.tjsp.jus.br/cpo/sg/open.do&#34;&gt;Consulta de de Processos de Segundo Grau&lt;/a&gt;
do TJSP.&lt;/p&gt;

&lt;p&gt;Sugerimos como melhores práticas dividir todas as atividades em três tarefas
principais: i) &lt;em&gt;buscar&lt;/em&gt;; ii) &lt;em&gt;coletar&lt;/em&gt; e iii) &lt;em&gt;processar&lt;/em&gt;.
Quando já sabemos de antemão quais são as URLs que vamos acessar,
a etapa de busca é desnecessária.&lt;/p&gt;

&lt;p&gt;Na maior parte dos casos,
deixar os algoritmos de &lt;em&gt;coleta&lt;/em&gt; e &lt;em&gt;processamento&lt;/em&gt; dos dados
em funções distintas é uma boa prática pois aumenta o
controle sobre o que as ferramentas estão fazendo,
facilita o debug e a atualização.
Por outro lado, em alguns casos
isso pode tornar o código mais ineficiente e os
arquivos obtidos podem ficar pesados.&lt;/p&gt;

&lt;h3 id=&#34;diferença-entre-buscar-baixar-e-processar&#34;&gt;Diferença entre buscar, baixar e processar.&lt;/h3&gt;

&lt;p&gt;Buscar documentos significa, de uma forma geral, utilizar ferramentas de
busca (ou acessar links de um site) para obter informações de uma nova
requisição a ser realizada. Ou seja, essa etapa do scraper serve para
&amp;ldquo;procurar links&amp;rdquo; que não sabíamos que existiam previamente. Isso será
resolvido através da função &lt;code&gt;cjsg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Baixar documentos, no entando, significa simplesmente acessar páginas
pré-estabelecidas e salvá-las em disco. Em algumas situações, os documentos
baixados (depois de limpos) podem conter uma nova lista de páginas a serem
baixadas, formando iterações de coletas. A tarefa de baixar documentos
pré-estabelecidos será realizada pela função &lt;code&gt;cposg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finalmente, processar documentos significa carregar dados acessíveis em disco e
transformar os dados brutos uma base &lt;em&gt;tidy&lt;/em&gt;.
Usualmente separamos a estruturação em duas etapas:
i) transformar arquivos não-estruturados em um arquivos semi-estruturados
(e.g. um arquivo HTML em uma tabela mais um conjunto de textos livres) e
ii) transformar arquivos semi-estruturados em uma base analítica (estruturada).
A tarefa de processar as páginas HTML será realizada pelas
funções &lt;code&gt;parse_cjsg&lt;/code&gt; e &lt;code&gt;parse_cpopg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Na pesquisa das câmaras, seguimos o fluxo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buscar -&amp;gt; coletar -&amp;gt; processar -&amp;gt; coletar -&amp;gt; processar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;para conseguir nossos dados.&lt;/p&gt;

&lt;h2 id=&#34;buscar-documentos&#34;&gt;Buscar documentos&lt;/h2&gt;

&lt;p&gt;A tarefa de listar os documentos de interesse é realizada
acessando resultados de um formulário.
Dependendo do site, será necessário realizar:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Uma busca e uma paginação;&lt;/li&gt;
&lt;li&gt;Uma busca e muitas paginações;&lt;/li&gt;
&lt;li&gt;Muitas buscas e uma paginação por busca;&lt;/li&gt;
&lt;li&gt;Muitas buscas e muitas paginações por busca.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;No TJSP temos &lt;em&gt;uma busca e muitas paginações&lt;/em&gt;.
Acesse a página do &lt;a href=&#34;http://esaj.tjsp.jus.br/cjsg/consultaCompleta.do&#34;&gt;e-SAJ&lt;/a&gt;,
digite &amp;ldquo;acordam&amp;rdquo; no campo &amp;ldquo;Pesquisa Livre&amp;rdquo; e clique em &amp;ldquo;Pesquisar&amp;rdquo;,
para ter uma ideia de como é essa página.&lt;/p&gt;

&lt;p&gt;A página (acessada no dia 2017-02-15)
é uma ferramenta de busca com vários campos,
que não permite pesquisa com dados em branco.
Na parte de baixo o site mostra uma série de documentos,
organizados em páginas de vinte em vinte resultados.&lt;/p&gt;

&lt;p&gt;Para realizar a coleta, precisamos de duas funções principais,
uma que faz a busca e outra que acessa uma página específica
(que será executada várias vezes).
Utilizaremos as funções &lt;code&gt;cjsg&lt;/code&gt; e &lt;code&gt;cjsg_pag&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cjsg_session &amp;lt;- function() {
  rvest::html_session(&#39;http://esaj.tjsp.jus.br/cjsg/consultaCompleta.do&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cjsg &amp;lt;- function(s, parms = cjsg_parms(s), path = &#39;./cjsg&#39;, 
                 max_pag = 10, overwrite = FALSE,
                 verbose = TRUE, p = .05) {
  dir.create(path, recursive = TRUE, showWarnings = FALSE)
  if (!file.exists(path)) stop(sprintf(&#39;Pasta não &amp;quot;%s&amp;quot; pôde ser criada&#39;, path))
  r0 &amp;lt;- s %&amp;gt;% 
    rvest::submit_form(parms)
  n_pags &amp;lt;- if (is.na(max_pag) || is.infinite(max_pag)) cjsg_npags(r0) else max_pag
  abjutils::dvec(cjsg_pag, 1:n_pags, path = path, ow = overwrite, s = s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cjsg_pag &amp;lt;- function(pag, path, ow, s) {
  Sys.sleep(1)
  u &amp;lt;- &#39;http://esaj.tjsp.jus.br/cjsg/trocaDePagina.do?tipoDeDecisao=A&amp;amp;pagina=%d&#39;
  u_pag &amp;lt;- sprintf(u, pag)
  arq &amp;lt;- sprintf(&#39;%s/%05d.html&#39;, path, pag)
  if (!file.exists(arq) || ow) {
    httr::GET(u_pag, httr::write_disk(arq, overwrite = ow), 
              handle = s$handle)
    tibble::data_frame(result = &#39;OK&#39;)
  } else {
    tibble::data_frame(result = &#39;já existe&#39;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A função &lt;code&gt;cjsg_pag&lt;/code&gt; precisa ser capaz de realizar uma pesquisa e retornar
a resposta do servidoe que contém a primeira página dos resultados. Para
isso, ela recebe uma lista com dados da busca (do formulário) a url base e um
método para realizar a requisição, podendo ser &amp;lsquo;get&amp;rsquo; ou &amp;lsquo;post&amp;rsquo;. Caso a pesquisa
seja mais complicada, é possível adicionar também uma função que sobrepõe a
busca padrão.&lt;/p&gt;

&lt;p&gt;É possível visualizar a página baixada com a função &lt;code&gt;BROWSE&lt;/code&gt; do pacote &lt;code&gt;httr&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;arqs &amp;lt;- dir(&#39;data/cjsg&#39;, full.names = TRUE)
httr::BROWSE(arqs[1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OBS:&lt;/strong&gt; A imagem fica &amp;ldquo;feia&amp;rdquo; pois está sem a folha de estilos e as imagens.&lt;/p&gt;

&lt;p&gt;Note que criamos uma função que facilita a entrada
de parâmetros de busca. No nosso exemplo, existem parâmetros necessários na
requisição que não precisam ser preenchidos, e parâmetros que precisam ser
preenchidos de uma maneira específica, como as datas, que precisam ser
inseridas no formato &lt;code&gt;%d/%m/%Y&lt;/code&gt;. Assim, incluimos uma função de &amp;ldquo;ajuda&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cjsg_parms &amp;lt;- function(s, livre = &#39;&#39;, data_inicial = NULL, data_final = NULL, secoes = &#39;&#39;) {
  secoes &amp;lt;- paste(secoes, collapse = &#39;,&#39;)
  dt_inicial &amp;lt;- &#39;&#39;
  if (!is.null(data_inicial)) {
    dt_inicial &amp;lt;- sprintf(&#39;%02d/%02d/%d&#39;, lubridate::day(data_inicial),
                          lubridate::month(data_inicial),
                          lubridate::year(data_inicial))
  }
  dt_final &amp;lt;- &#39;&#39;
  if (!is.null(data_final)) {
    dt_final &amp;lt;- sprintf(&#39;%02d/%02d/%d&#39;, lubridate::day(data_final),
                        lubridate::month(data_final),
                        lubridate::year(data_final))
  }
  suppressWarnings({
    s %&amp;gt;% 
      rvest::html_form() %&amp;gt;% 
      dplyr::first() %&amp;gt;% 
      rvest::set_values(&#39;dados.buscaInteiroTeor&#39; = livre,
                        &#39;secoesTreeSelection.values&#39; = secoes,
                        &#39;dados.dtJulgamentoInicio&#39; = dt_inicial,
                        &#39;dados.dtJulgamentoFim&#39; = dt_final)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Também foi necessário realizar um pequeno processamento na primeira requisição,
quando o usuário não souber a priori quantas páginas deseja baixar.
Nesse caso, a função &lt;code&gt;cjsg_npags&lt;/code&gt; identifica o número de paginações necessárias.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cjsg_npags &amp;lt;- function(req, parms = NULL) {
  if (!is.null(parms)) req &amp;lt;- req %&amp;gt;% rvest::submit_form(parms)
  num &amp;lt;- req$response %&amp;gt;% 
    httr::content(&#39;text&#39;) %&amp;gt;% 
    xml2::read_html() %&amp;gt;%
    rvest::html_node(&#39;#nomeAba-A&#39;) %&amp;gt;% 
    rvest::html_text() %&amp;gt;% 
    tidyr::extract_numeric()
  (num %/% 20) + 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A função &lt;code&gt;dvec&lt;/code&gt; é uma função genérica que ajuda a
aplicar uma função a cada elemento de determinados itens,
como um &lt;code&gt;lapply&lt;/code&gt;, mas que o faz de forma mais verborrágica e
não resulta em erro caso um elemento dê erro.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#&#39; Vetorizando scrapers
#&#39;
#&#39; Vetoriza um scraper (função) para um vetor de itens
#&#39;
#&#39; @param fun função a ser aplicada em cada arquivo.
#&#39; @param itens character vector dos caminhos de arquivos a serem transformados.
#&#39; @param ... outros parâmetros a serem passados para \code{fun}
#&#39; @param verbose se \code{TRUE} (default), mostra o item com probabilidade p.
#&#39; @param p probabilidade de imprimir mensagem.
#&#39; 
#&#39; @export
dvec &amp;lt;- function(fun, itens, ..., verbose = TRUE, p = .05) {
  f &amp;lt;- dplyr::failwith(tibble::data_frame(result = &#39;erro&#39;), fun)
  tibble::data_frame(item = itens) %&amp;gt;%
    dplyr::distinct(item) %&amp;gt;%
    dplyr::group_by(item) %&amp;gt;%
    dplyr::do({
      if (runif(1) &amp;lt; p &amp;amp;&amp;amp; verbose) print(.$item)
      d &amp;lt;- f(.$item, ...)
      if (tibble::has_name(d, &#39;result&#39;)) d$result &amp;lt;- &#39;OK&#39;
      d
    }) %&amp;gt;%
    dplyr::ungroup()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No projeto das câmaras, rodamos o seguinte código:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(tjsp)

sec &amp;lt;- list_secoes_2inst() %&amp;gt;% 
  dplyr::filter(stringr::str_detect(secao, &#39;[Cc]rim&#39;),
                stringr::str_detect(pai, &#39;CRIM&#39;)) %&amp;gt;% 
  with(cod)

session &amp;lt;- cjsg_session()
parms &amp;lt;- session %&amp;gt;% 
  cjsg_parms(secoes = sec, 
             data_inicial = &#39;2015-01-01&#39;, 
             data_final = &#39;2015-12-31&#39;)

# numero de paginas a serem baixadas
session %&amp;gt;% cjsg_npags(parms)

d_result &amp;lt;- session %&amp;gt;% 
  cjsg(parms, path = &#39;data/cjsg&#39;, max_pag = 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Onde guardar os dados?&lt;/strong&gt; Ao construir um scraper,
é importante guardar os dados brutos na máquina ou num servidor,
para reprodutibilidade e manutenção do scraper.
Se estiver construindo um pacote do R, o melhor lugar para guardar esses
dados é na pasta &lt;code&gt;data&lt;/code&gt;, como sugerido no livro &lt;a href=&#34;http://r-pkgs.had.co.nz&#34;&gt;r-pkgs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Se os dados forem muito volumosos,
pode ser necessário colocar esses documentos numa pasta externa ao pacote.
Para garantir a reprodutibilidade, recomendamos a criação de um
pacote no R cujo objetivo é somente baixar e processar esses dados,
além da criação de um repositório na nuvem (Dropbox, por exemplo).
No pacote que contém as funções de extração,
guarde os dados já processados (se couberem) num arquivo &lt;code&gt;.rda&lt;/code&gt; dentro da pasta
&lt;code&gt;data&lt;/code&gt; do pacote.&lt;/p&gt;

&lt;h2 id=&#34;coletar-processos&#34;&gt;Coletar processos&lt;/h2&gt;

&lt;p&gt;Antes de coletar os processos, é necessário ler os arquivos HTML baixados na etapa anterior.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;parse_cjsg_um &amp;lt;- function(i, nodes) {
  node &amp;lt;- nodes[[i]]
  trim &amp;lt;- stringr::str_trim
  id &amp;lt;- node %&amp;gt;%
    rvest::html_node(&#39;.ementaClass&#39;) %&amp;gt;%
    rvest::html_text() %&amp;gt;%
    trim() %&amp;gt;%
    stringr::str_replace_all(&#39;[^0-9]&#39;, &#39;&#39;)
  infos &amp;lt;- node %&amp;gt;%
    rvest::html_node(&#39;.downloadEmenta&#39;) %&amp;gt;% {
      tibble::tibble(n_processo = trim(rvest::html_text(.)),
                     cd_acordao = rvest::html_attr(., &#39;cdacordao&#39;))
    }
  ca &amp;lt;- node %&amp;gt;%
    rvest::html_node(&#39;.assuntoClasse&#39;) %&amp;gt;%
    rvest::html_text() %&amp;gt;%
    trim()
  tsf &amp;lt;- node %&amp;gt;%
    rvest::html_node(&#39;textarea&#39;) %&amp;gt;%
    rvest::html_text()
  tab_infos &amp;lt;- node %&amp;gt;%
    rvest::html_nodes(&#39;.ementaClass2&#39;) %&amp;gt;%
    rvest::html_text() %&amp;gt;%
    stringr::str_split_fixed(&#39;:&#39;, 2) %&amp;gt;%
    data.frame(stringsAsFactors = FALSE) %&amp;gt;%
    setNames(c(&#39;key&#39;, &#39;val&#39;)) %&amp;gt;%
    dplyr::mutate_all(dplyr::funs(trim(.))) %&amp;gt;%
    dplyr::mutate(key = tolower(abjutils::rm_accent(key)),
                  key = stringr::str_replace_all(key, &#39; +&#39;, &#39;_&#39;),
                  key = stringr::str_replace_all(key, &#39;[^a-z_]&#39;, &#39;&#39;),
                  key = stringr::str_replace_all(key, &#39;_d[eo]_&#39;, &#39;_&#39;)) %&amp;gt;%
    tidyr::spread(key, val) %&amp;gt;%
    dplyr::bind_cols(infos) %&amp;gt;%
    dplyr::mutate(id = id, classe_assunto = ca, txt_ementa = tsf) %&amp;gt;%
    dplyr::select(id, cd_acordao, n_processo, dplyr::everything(), txt_ementa)
  tab_infos
}

parse_cjsg_arq &amp;lt;- function(arq) {
  itens &amp;lt;- xml2::read_html(arq, encoding = &#39;UTF-8&#39;) %&amp;gt;%
    rvest::html_nodes(&#39;.fundocinza1&#39;)
  abjutils::dvec(parse_cjsg_um, 1:length(itens), nodes = itens, verbose = FALSE) %&amp;gt;%
    dplyr::select(-item)
}

parse_cjsg &amp;lt;- function(arqs) {
  abjutils::dvec(parse_cjsg_arq, arqs) %&amp;gt;%
    dplyr::rename(arq = item)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rodando a função criada.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;arqs &amp;lt;- dir(&#39;data/cjsg&#39;, full.names = TRUE)
d_cjsg &amp;lt;- tjsp::parse_cjsg(arqs)
saveRDS(d_cjsg, &#39;data/d_cjsg.rds&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;d_cjsg &amp;lt;- readRDS(&#39;data/d_cjsg.rds&#39;)
d_cjsg
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## # A tibble: 200 × 14
##                         arq    id cd_acordao                n_processo
##                       &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;                     &amp;lt;chr&amp;gt;
## 1  data-raw/cjsg/00001.html     1   10120659 0053149-48.2006.8.26.0050
## 2  data-raw/cjsg/00001.html     2   10092189 0011582-56.2009.8.26.0236
## 3  data-raw/cjsg/00001.html     3   10040923 0035263-74.2015.8.26.0000
## 4  data-raw/cjsg/00001.html     4   10039029 0019944-66.2015.8.26.0000
## 5  data-raw/cjsg/00001.html     5   10039023 0041547-98.2015.8.26.0000
## 6  data-raw/cjsg/00001.html     6   10027377 0003710-93.2014.8.26.0048
## 7  data-raw/cjsg/00001.html     7    9983410 7004537-07.2015.8.26.0482
## 8  data-raw/cjsg/00001.html     8    9956156 0004870-37.2014.8.26.0604
## 9  data-raw/cjsg/00001.html     9    9901809 7007051-30.2015.8.26.0482
## 10 data-raw/cjsg/00001.html    10    9899013 0087445-23.2011.8.26.0050
## # ... with 190 more rows, and 10 more variables: comarca &amp;lt;chr&amp;gt;,
## #   data_julgamento &amp;lt;chr&amp;gt;, data_registro &amp;lt;chr&amp;gt;, ementa &amp;lt;chr&amp;gt;,
## #   orgao_julgador &amp;lt;chr&amp;gt;, relatora &amp;lt;chr&amp;gt;, classe_assunto &amp;lt;chr&amp;gt;,
## #   txt_ementa &amp;lt;chr&amp;gt;, result &amp;lt;chr&amp;gt;, outros_numeros &amp;lt;chr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora criamos a função que baixa processos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados_cposg &amp;lt;- function(p) {
  list(&#39;conversationId&#39; = &#39;&#39;,
       &#39;paginaConsulta&#39; = &#39;1&#39;,
       &#39;localPesquisa.cdLocal&#39; = &#39;-1&#39;,
       &#39;cbPesquisa&#39; = &#39;NUMPROC&#39;,
       &#39;tipoNuProcesso&#39; = &#39;UNIFICADO&#39;,
       &#39;numeroDigitoAnoUnificado&#39; = stringr::str_sub(p, 1, 11),
       &#39;foroNumeroUnificado&#39; = stringr::str_sub(p, -4, -1),
       &#39;dePesquisaNuUnificado&#39; = p,
       &#39;dePesquisaNuAntigo&#39; = &#39;&#39;)
}

cposg_um &amp;lt;- function(p, path, ow) {
  Sys.sleep(1)
  arq &amp;lt;- sprintf(&#39;%s/%s.html&#39;, path, p)
  if (!file.exists(arq) || ow) {
    httr::GET(&#39;https://esaj.tjsp.jus.br/cposg/search.do&#39;,
              query = dados_cposg(p),
              config = httr::config(ssl_verifypeer = FALSE),
              httr::write_disk(arq, overwrite = ow))
    tibble::tibble(result = &#39;OK&#39;)
  } else {
    tibble::tibble(result = &#39;já existe&#39;)
  }
}

cposg &amp;lt;- function(processos, path = &#39;data/cposg&#39;, overwrite = FALSE) {
  suppressWarnings(dir.create(path, recursive = TRUE))
  processos &amp;lt;- gsub(&#39;[^0-9]&#39;, &#39;&#39;, processos)
  abjutils::dvec(cposg_um, processos, path = path, ow = overwrite)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rodando a função criada.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;d_cjsg %&amp;gt;% 
  distinct(n_processo) %&amp;gt;% 
  with(n_processo) %&amp;gt;% 
  tjsp::cposg(path = &#39;data/cposg&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extraindo as partes do arquivo HTML.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;partes_cposg_um &amp;lt;- function(arq) {
  h &amp;lt;- arq %&amp;gt;% xml2::read_html(encoding = &#39;UTF-8&#39;)
  todas_partes &amp;lt;- h %&amp;gt;% rvest::html_nodes(&#39;#tableTodasPartes&#39;) %&amp;gt;% length()
  if (todas_partes &amp;gt; 0) {
    nodes &amp;lt;- h %&amp;gt;% 
      rvest::html_nodes(&#39;#tableTodasPartes &amp;gt; .fundoClaro&#39;)
  } else {
    nodes &amp;lt;- h %&amp;gt;% 
      rvest::html_nodes(&#39;#tablePartesPrincipais &amp;gt; .fundoClaro&#39;)
  }
  purrr::map_df(seq_along(nodes), function(i) {
    node &amp;lt;- nodes[[i]]
    titulos &amp;lt;- node %&amp;gt;% 
      rvest::html_nodes(&#39;.mensagemExibindo&#39;) %&amp;gt;% 
      rvest::html_text() %&amp;gt;% 
      stringr::str_trim() %&amp;gt;% 
      stringr::str_replace_all(&#39;&amp;amp;nbsp&#39;, &#39;&#39;)
    tirar &amp;lt;- paste(titulos, collapse = &#39;|&#39;)
    nomes &amp;lt;- titulos %&amp;gt;% 
      tolower() %&amp;gt;% 
      abjutils::rm_accent() %&amp;gt;% 
      stringr::str_replace_all(&#39;[^a-z]&#39;, &#39;&#39;) %&amp;gt;% 
      paste(sprintf(&#39;%02d&#39;, 1:length(.)), sep = &#39;_&#39;)
    node %&amp;gt;% 
      rvest::html_text() %&amp;gt;% 
      stringr::str_trim() %&amp;gt;% 
      stringr::str_replace_all(&#39;&amp;amp;nbsp&#39;, &#39;&#39;) %&amp;gt;% 
      stringr::str_replace_all(tirar, &#39;&#39;) %&amp;gt;% 
      stringr::str_trim() %&amp;gt;%
      stringr::str_split(&#39;[\n\t\r ]{2,}&#39;, simplify = TRUE) %&amp;gt;% 
      data.frame(stringsAsFactors = FALSE) %&amp;gt;% 
      setNames(nomes) %&amp;gt;% 
      tidyr::gather() %&amp;gt;% 
      tibble::as_data_frame() %&amp;gt;% 
      tidyr::separate(key, c(&#39;tipo&#39;, &#39;id_tipo&#39;), sep = &#39;_&#39;) %&amp;gt;% 
      dplyr::mutate(id = i) %&amp;gt;% 
      dplyr::select(id, id_tipo, tipo, nome = value) %&amp;gt;% 
      dplyr::mutate(result = &#39;OK&#39;)
  })
}

partes_cposg &amp;lt;- function(arqs, verbose = FALSE) {
  abjutils::dvec(partes_cposg_um, arqs, verbose = verbose) %&amp;gt;% 
    rename(arq = item)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;arqs &amp;lt;- dir(&#39;data/cposg&#39;, full.names = TRUE)
d_partes &amp;lt;-  partes_cposg(arqs)
saveRDS(d_partes, &#39;data/d_partes.rds&#39;)
d_partes
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;d_partes &amp;lt;- readRDS(&#39;data/d_partes.rds&#39;)
d_partes
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## # A tibble: 762 × 6
##                                         arq    id id_tipo     tipo
##                                       &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;   &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;
## 1  data-raw/cposg/00000179520148260050.html     1      01 apteapdo
## 2  data-raw/cposg/00000179520148260050.html     2      01 apdoapte
## 3  data-raw/cposg/00000179520148260050.html     2      02 advogado
## 4  data-raw/cposg/00000179520148260050.html     3      01 apdoapte
## 5  data-raw/cposg/00000179520148260050.html     3      02 advogado
## 6  data-raw/cposg/00000201120148260451.html     1      01 apelante
## 7  data-raw/cposg/00000201120148260451.html     1      02 advogado
## 8  data-raw/cposg/00000201120148260451.html     2      01  apelado
## 9  data-raw/cposg/00000636120138260457.html     1      01 apelante
## 10 data-raw/cposg/00000636120138260457.html     1      02 advogado
## # ... with 752 more rows, and 2 more variables: nome &amp;lt;chr&amp;gt;, result &amp;lt;chr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extraindo as decisões.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;decisoes_cposg_um &amp;lt;- function(arq) {
  html &amp;lt;- xml2::read_html(arq, encoding = &#39;UTF-8&#39;)
  xpath &amp;lt;- &#39;(//table[@width=&amp;quot;98%&amp;quot; and @align=&amp;quot;center&amp;quot;])[last()]&#39;
  r &amp;lt;- rvest::html_node(html, xpath = xpath)
  tab &amp;lt;- rvest::html_table(r)
  names(tab) &amp;lt;- c(&#39;data&#39;, &#39;situacao&#39;, &#39;decisao&#39;)
  tab$result &amp;lt;- &#39;OK&#39;
  return(tab)
}

decisoes_cposg &amp;lt;- function(arqs, verbose = FALSE) {
  abjutils::dvec(decisoes_cposg_um, arqs, verbose = verbose) %&amp;gt;% 
    dplyr::rename(arq = item)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;arqs &amp;lt;- dir(&#39;data/cposg&#39;, full.names = TRUE)
d_decisoes &amp;lt;- decisoes_cposg(arqs)
saveRDS(d_decisoes, &#39;data/d_decisoes.rds&#39;)
d_decisoes
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;d_decisoes &amp;lt;- readRDS(&#39;data/d_decisoes.rds&#39;)
d_decisoes
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## # A tibble: 361 × 5
##                                         arq       data
##                                       &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;
## 1  data-raw/cposg/00000179520148260050.html 16/12/2015
## 2  data-raw/cposg/00000201120148260451.html 03/12/2015
## 3  data-raw/cposg/00000636120138260457.html 08/10/2015
## 4  data-raw/cposg/00000636120138260457.html 24/09/2015
## 5  data-raw/cposg/00000636120138260457.html 17/09/2015
## 6  data-raw/cposg/00000681720138260576.html 16/12/2015
## 7  data-raw/cposg/00001064420148260495.html 03/12/2015
## 8  data-raw/cposg/00001241620138260361.html 29/10/2015
## 9  data-raw/cposg/00001939320158260000.html 12/05/2015
## 10 data-raw/cposg/00001939320158260000.html 14/04/2015
## # ... with 351 more rows, and 3 more variables: situacao &amp;lt;chr&amp;gt;,
## #   decisao &amp;lt;chr&amp;gt;, result &amp;lt;chr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Visualizando!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tipos_decisao &amp;lt;- function(decisoes) {
  negaram &amp;lt;- regex(&#39;negaram&#39;, ignore_case = TRUE)
  parcial &amp;lt;- regex(&#39;parcial&#39;, ignore_case = TRUE)
  deram &amp;lt;- regex(&#39;deram&#39;, ignore_case = TRUE)
  ifelse(
    str_detect(decisoes, negaram), &#39;negado&#39;, ifelse(
      str_detect(decisoes, parcial), &#39;parcial&#39;, ifelse(
        str_detect(decisoes, deram), &#39;provido&#39;, &#39;outros&#39;
    ))
  )
}

partes_apelacoes &amp;lt;- d_partes %&amp;gt;% 
  filter(tipo == &#39;apelado&#39;, str_detect(nome, &#39;[Mm]inist&#39;)) %&amp;gt;% 
  mutate(n_processo = str_replace_all(arq, &#39;[^0-9]&#39;, &#39;&#39;)) %&amp;gt;% 
  dplyr::select(n_processo)

decisoes &amp;lt;- d_decisoes %&amp;gt;% 
  mutate(n_processo = str_replace_all(arq, &#39;[^0-9]&#39;, &#39;&#39;)) %&amp;gt;% 
  inner_join(partes_apelacoes, &#39;n_processo&#39;) %&amp;gt;% 
  filter(situacao == &#39;Julgado&#39;) %&amp;gt;% 
  distinct(n_processo, decisao) %&amp;gt;%
  mutate(tipo_decisao = tipos_decisao(decisao)) %&amp;gt;% 
  dplyr::select(n_processo, tipo_decisao)

library(ggplot2)
d_cjsg %&amp;gt;%
  mutate(n_processo = str_replace_all(n_processo, &#39;[^0-9]&#39;, &#39;&#39;)) %&amp;gt;% 
  inner_join(decisoes, &#39;n_processo&#39;) %&amp;gt;% 
  filter(tipo_decisao != &#39;outros&#39;) %&amp;gt;% 
  count(orgao_julgador, tipo_decisao) %&amp;gt;%
  mutate(ntot = sum(n), prop = n / ntot) %&amp;gt;%
  filter(ntot &amp;gt; 5) %&amp;gt;% 
  ungroup() %&amp;gt;%
  mutate(num = readr::parse_number(orgao_julgador),
         num = sprintf(&#39;%02d&#39;, num)) %&amp;gt;% 
  ggplot(aes(x = num, fill = tipo_decisao, y = prop)) +
  geom_bar(stat = &#39;identity&#39;, colour = &#39;black&#39;, position = &#39;dodge&#39;) +
  theme_bw() +
  scale_y_continuous(labels = scales::percent) +
  xlab(&#39;Órgão julgador&#39;) +
  ylab(&#39;Proporção de processos por tipo de decisão&#39;) +
  theme(legend.position = &amp;quot;bottom&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-36-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-36&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introdução</title>
      <link>/manip/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/manip/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&amp;rdquo;(&amp;hellip;) The fact that data science exists as a field is a colossal failure of statistics. To me, what I do is what statistics is all about. It is gaining insight from data using modelling and visualization. Data munging and manipulation is hard and statistics has just said that’s not our domain.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Hadley Wickham&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Esta seção trata do tema &lt;em&gt;transformação de dados&lt;/em&gt;. Trata-se de uma tarefa dolorosa e demorada, tomando muitas vezes a maior parte do tempo de uma análise estatística. Essa etapa é essencial em qualquer análise de dados e, apesar de negligenciada pela academia, é decisiva para o sucesso de estudos aplicados.&lt;/p&gt;

&lt;p&gt;Usualmente, o cientista de dados parte de uma base &amp;ldquo;crua&amp;rdquo; e a transforma até obter uma base de dados analítica. A base crua pode ser não estruturada, semi-estruturada ou estruturada. Já a base analítica é necessariamente estruturada e está preparada para passar por análises estatísticas a menos de transformações simples.&lt;/p&gt;

&lt;p&gt;Um conceito importante para obtenção de uma base analítica é o &lt;em&gt;data tidying&lt;/em&gt;, ou arrumação de dados. Uma base é considerada &lt;em&gt;tidy&lt;/em&gt; se&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Cada linha da base representa uma observação.&lt;/li&gt;
&lt;li&gt;Cada coluna da base representa uma variável.&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Cada tabela considera informações de uma unidade amostral.&lt;/del&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A base de dados analítica é estruturada de tal forma que pode ser colocada diretamente em sistemas de modelagem estatística ou de visualização. Nem sempre uma base de dados analítica está no formato &lt;em&gt;tidy&lt;/em&gt;, mas usualmente são necessários poucos passos para migrar de uma para outra.&lt;/p&gt;

&lt;p&gt;A Figura abaixo mostra a fase de &amp;ldquo;disputa&amp;rdquo; com os dados (&lt;em&gt;data wrangling&lt;/em&gt;) para deixá-los no formato analítico.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://r4ds.had.co.nz/diagrams/data-science-wrangle.png&#34; title=&#34;Transformação no ciclo da ciência de dados.&#34; alt=&#34;Transformação no ciclo da ciência de dados.&#34; width=&#34;60%&#34; height=&#34;60%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;pacotes-dplyr-e-tidyr&#34;&gt;Pacotes &lt;code&gt;dplyr&lt;/code&gt; e &lt;code&gt;tidyr&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;O &lt;code&gt;dplyr&lt;/code&gt; é o pacote mais útil para realizar transformação de dados, aliando simplicidade e eficiência de uma forma elegante. Os scripts em &lt;code&gt;R&lt;/code&gt; que fazem uso inteligente dos verbos &lt;code&gt;dplyr&lt;/code&gt; e as facilidades do operador &lt;em&gt;pipe&lt;/em&gt; tendem a ficar mais legíveis e organizados sem perder velocidade de execução.&lt;/p&gt;

&lt;p&gt;Antes de apresentar as principais funções do &lt;code&gt;dplyr&lt;/code&gt; e do &lt;code&gt;tidyr&lt;/code&gt;, precisamos trabalhar com o conceito de &lt;code&gt;tibbles&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;trabalhando-com-tibble-s&#34;&gt;Trabalhando com &lt;code&gt;tibble&lt;/code&gt;&amp;rsquo;s&lt;/h3&gt;

&lt;p&gt;Uma &lt;code&gt;tibble&lt;/code&gt; nada mais é do que um &lt;code&gt;data.frame&lt;/code&gt;, mas com um método de impressão mais adequado. Outras diferenças podem ser estudadas &lt;a href=&#34;http://r4ds.had.co.nz/tibbles.html&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Considere a seguinte base de dados.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min
## # A tibble: 16,686 × 14
##      ano                  muni    uf regiao  idhm idhm_e idhm_l idhm_r
##    &amp;lt;int&amp;gt;                 &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1   1991 ALTA FLORESTA D&#39;OESTE    RO  Norte 0.329  0.112  0.617  0.516
## 2   1991             ARIQUEMES    RO  Norte 0.432  0.199  0.684  0.593
## 3   1991                CABIXI    RO  Norte 0.309  0.108  0.636  0.430
## 4   1991                CACOAL    RO  Norte 0.407  0.171  0.667  0.593
## 5   1991            CEREJEIRAS    RO  Norte 0.386  0.167  0.629  0.547
## 6   1991     COLORADO DO OESTE    RO  Norte 0.376  0.151  0.658  0.536
## 7   1991            CORUMBIARA    RO  Norte 0.203  0.039  0.572  0.373
## 8   1991         COSTA MARQUES    RO  Norte 0.425  0.220  0.629  0.553
## 9   1991       ESPIGÃO D&#39;OESTE    RO  Norte 0.388  0.159  0.653  0.561
## 10  1991         GUAJARÁ-MIRIM    RO  Norte 0.468  0.247  0.662  0.625
## # ... with 16,676 more rows, and 6 more variables: espvida &amp;lt;dbl&amp;gt;,
## #   rdpc &amp;lt;dbl&amp;gt;, gini &amp;lt;dbl&amp;gt;, pop &amp;lt;int&amp;gt;, lat &amp;lt;dbl&amp;gt;, lon &amp;lt;dbl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;base-idh-municipal-pnud&#34;&gt;Base IDH-Municipal - PNUD&lt;/h2&gt;

&lt;p&gt;Nessa seção, vamos trabalhar com uma base simplificada do &lt;a href=&#34;http://www.atlasbrasil.org.br/2013/pt/download/base/&#34;&gt;PNUD (Programa das Nações Unidas para o Desenvolvimento)&lt;/a&gt;, contendo informações socioeconômicas de todos os municípios do país. Os resultados foram obtidos a partir dos Censos de 1991, 2000 e 2010.&lt;/p&gt;

&lt;p&gt;A base contém 16686 linhas e 14 colunas, descritas abaixo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ano&lt;/code&gt; - Ano do Censo utilizado como base para cálculo do IDH-Municipal e outras métricas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;muni&lt;/code&gt; - Nome do município. Cada município aparece três vezes, um para cada ano.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uf&lt;/code&gt; - Unidade Federativa.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;regiao&lt;/code&gt; - Região brasileira.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idhm&lt;/code&gt; - IDH municipal, dividido em

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;idhm_e&lt;/code&gt; - IDH municipal - educação.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idhm_l&lt;/code&gt; - IDH municipal - longevidade.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idhm_r&lt;/code&gt; - IDH municipal - renda.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;espvida&lt;/code&gt; - Expectativa de vida.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rdpc&lt;/code&gt; - Renda &lt;em&gt;per capita&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gini&lt;/code&gt; - Coeficiente de gini municipal (mede desigualdade social).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt; - População residente do município.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lat&lt;/code&gt;, &lt;code&gt;lon&lt;/code&gt; - Latitude e longitude do município (ponto médio).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;os-cinco-verbos-do-dplyr&#34;&gt;Os cinco verbos do &lt;code&gt;dplyr&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;As funções principais do &lt;code&gt;dplyr&lt;/code&gt; são:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;filter&lt;/code&gt; - filtra linhas&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select&lt;/code&gt; - seleciona colunas&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mutate&lt;/code&gt; - cria/modifica colunas&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arrange&lt;/code&gt; - ordena a base&lt;/li&gt;
&lt;li&gt;&lt;code&gt;summarise&lt;/code&gt; - sumariza a base&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;características&#34;&gt;Características&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;O &lt;em&gt;input&lt;/em&gt;  é sempre uma &lt;code&gt;tibble&lt;/code&gt; e o &lt;em&gt;output&lt;/em&gt;  é sempre um &lt;code&gt;tibble&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Colocamos o &lt;code&gt;tibble&lt;/code&gt; no primeiro argumento e o que queremos fazer nos outros argumentos.&lt;/li&gt;
&lt;li&gt;A utilização é facilitada com o emprego do operador &lt;code&gt;%&amp;gt;%&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;O pacote faz uso extensivo de NSE (&lt;em&gt;non standard evaluation&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;vantagens&#34;&gt;Vantagens&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Utiliza &lt;code&gt;C&lt;/code&gt; e &lt;code&gt;C++&lt;/code&gt; por trás da maioria das funções, o que geralmente torna o código mais eficiente.&lt;/li&gt;
&lt;li&gt;Pode trabalhar com diferentes fontes de dados, como bases relacionais (SQL) e &lt;code&gt;data.table&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;select&#34;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Utilizar as funções &lt;code&gt;starts_with(x)&lt;/code&gt;, &lt;code&gt;contains(x)&lt;/code&gt;, &lt;code&gt;matches(x)&lt;/code&gt;, &lt;code&gt;one_of(x)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Possível colocar nomes, índices e intervalos de variáveis com &lt;code&gt;:&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(ano, regiao, muni)
## # A tibble: 16,686 × 3
##      ano regiao                  muni
##    &amp;lt;int&amp;gt;  &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;
## 1   1991  Norte ALTA FLORESTA D&#39;OESTE
## 2   1991  Norte             ARIQUEMES
## 3   1991  Norte                CABIXI
## 4   1991  Norte                CACOAL
## 5   1991  Norte            CEREJEIRAS
## 6   1991  Norte     COLORADO DO OESTE
## 7   1991  Norte            CORUMBIARA
## 8   1991  Norte         COSTA MARQUES
## 9   1991  Norte       ESPIGÃO D&#39;OESTE
## 10  1991  Norte         GUAJARÁ-MIRIM
## # ... with 16,676 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(ano:regiao, rdpc)
## # A tibble: 16,686 × 5
##      ano                  muni    uf regiao   rdpc
##    &amp;lt;int&amp;gt;                 &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt;
## 1   1991 ALTA FLORESTA D&#39;OESTE    RO  Norte 198.46
## 2   1991             ARIQUEMES    RO  Norte 319.47
## 3   1991                CABIXI    RO  Norte 116.38
## 4   1991                CACOAL    RO  Norte 320.24
## 5   1991            CEREJEIRAS    RO  Norte 240.10
## 6   1991     COLORADO DO OESTE    RO  Norte 224.82
## 7   1991            CORUMBIARA    RO  Norte  81.38
## 8   1991         COSTA MARQUES    RO  Norte 250.08
## 9   1991       ESPIGÃO D&#39;OESTE    RO  Norte 263.03
## 10  1991         GUAJARÁ-MIRIM    RO  Norte 391.37
## # ... with 16,676 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(ano, starts_with(&#39;idhm&#39;))
## # A tibble: 16,686 × 5
##      ano  idhm idhm_e idhm_l idhm_r
##    &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1   1991 0.329  0.112  0.617  0.516
## 2   1991 0.432  0.199  0.684  0.593
## 3   1991 0.309  0.108  0.636  0.430
## 4   1991 0.407  0.171  0.667  0.593
## 5   1991 0.386  0.167  0.629  0.547
## 6   1991 0.376  0.151  0.658  0.536
## 7   1991 0.203  0.039  0.572  0.373
## 8   1991 0.425  0.220  0.629  0.553
## 9   1991 0.388  0.159  0.653  0.561
## 10  1991 0.468  0.247  0.662  0.625
## # ... with 16,676 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;filter&#34;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Parecido com &lt;code&gt;subset&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Condições separadas por vírgulas equivalem a separar por &lt;code&gt;&amp;amp;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(ano, muni, uf) %&amp;gt;% 
  filter(uf == &#39;AC&#39;)
## # A tibble: 66 × 3
##      ano            muni    uf
##    &amp;lt;int&amp;gt;           &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1   1991      ACRELÂNDIA    AC
## 2   1991    ASSIS BRASIL    AC
## 3   1991       BRASILÉIA    AC
## 4   1991          BUJARI    AC
## 5   1991        CAPIXABA    AC
## 6   1991 CRUZEIRO DO SUL    AC
## 7   1991  EPITACIOLÂNDIA    AC
## 8   1991           FEIJÓ    AC
## 9   1991          JORDÃO    AC
## 10  1991     MÂNCIO LIMA    AC
## # ... with 56 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para fazer várias condições, use os operadores lógicos &lt;code&gt;&amp;amp;&lt;/code&gt; e &lt;code&gt;|&lt;/code&gt; ou separe filtros entre vírgulas.&lt;/p&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
%in%
&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;%in%&lt;/b&gt; é um operador muito útil para trabalhar com vetores. O resultado da operação é um vetor lógico do tamanho do vetor do elemento da esquerda, identificando quais elementos da esquerda batem com algum elemento da direita.
&lt;/p&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(ano, regiao, uf, idhm) %&amp;gt;% 
  filter(uf %in% c(&#39;SP&#39;, &#39;MG&#39;) | idhm &amp;gt; .5, ano == 2010)
## # A tibble: 5,527 × 4
##      ano regiao    uf  idhm
##    &amp;lt;int&amp;gt;  &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1   2010  Norte    RO 0.641
## 2   2010  Norte    RO 0.702
## 3   2010  Norte    RO 0.650
## 4   2010  Norte    RO 0.718
## 5   2010  Norte    RO 0.692
## 6   2010  Norte    RO 0.685
## 7   2010  Norte    RO 0.613
## 8   2010  Norte    RO 0.611
## 9   2010  Norte    RO 0.672
## 10  2010  Norte    RO 0.657
## # ... with 5,517 more rows
  # é igual a
  # filter(uf %in% c(&#39;SP&#39;, &#39;MG&#39;) | idhm &amp;gt; .5 &amp;amp; ano == 2010)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(stringr)
pnud_min %&amp;gt;% 
  select(muni, ano, uf) %&amp;gt;% 
  filter(str_detect(muni, &#39;^[HG]|S$&#39;), 
         ano == 1991)
## # A tibble: 970 × 3
##                         muni   ano    uf
##                        &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;
## 1                  ARIQUEMES  1991    RO
## 2                 CEREJEIRAS  1991    RO
## 3              COSTA MARQUES  1991    RO
## 4              GUAJARÁ-MIRIM  1991    RO
## 5    ALTO ALEGRE DOS PARECIS  1991    RO
## 6                    BURITIS  1991    RO
## 7               CASTANHEIRAS  1991    RO
## 8  GOVERNADOR JORGE TEIXEIRA  1991    RO
## 9                    PARECIS  1991    RO
## 10              SERINGUEIRAS  1991    RO
## # ... with 960 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;mutate&#34;&gt;&lt;code&gt;mutate&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Parecido com &lt;code&gt;transform&lt;/code&gt;, mas aceita várias novas colunas iterativamente.&lt;/li&gt;
&lt;li&gt;Novas variáveis devem ter o mesmo &lt;code&gt;length&lt;/code&gt; que o &lt;code&gt;nrow&lt;/code&gt; do bd oridinal ou &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(muni, rdpc, pop, idhm_l, espvida) %&amp;gt;% 
  mutate(renda = rdpc * pop, 
         razao = idhm_l / espvida)
## # A tibble: 16,686 × 7
##                     muni   rdpc   pop idhm_l espvida      renda
##                    &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1  ALTA FLORESTA D&#39;OESTE 198.46 22835  0.617   62.01  4531834.1
## 2              ARIQUEMES 319.47 55018  0.684   66.02 17576600.5
## 3                 CABIXI 116.38  5846  0.636   63.16   680357.5
## 4                 CACOAL 320.24 66534  0.667   65.03 21306848.2
## 5             CEREJEIRAS 240.10 19030  0.629   62.73  4569103.0
## 6      COLORADO DO OESTE 224.82 25070  0.658   64.46  5636237.4
## 7             CORUMBIARA  81.38 10737  0.572   59.32   873777.1
## 8          COSTA MARQUES 250.08  6902  0.629   62.76  1726052.2
## 9        ESPIGÃO D&#39;OESTE 263.03 22505  0.653   64.18  5919490.1
## 10         GUAJARÁ-MIRIM 391.37 31240  0.662   64.71 12226398.8
## # ... with 16,676 more rows, and 1 more variables: razao &amp;lt;dbl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;arrange&#34;&gt;&lt;code&gt;arrange&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Simplesmente ordena de acordo com as opções.&lt;/li&gt;
&lt;li&gt;Utilizar &lt;code&gt;desc&lt;/code&gt; para ordem decrescente.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  filter(ano == 2010) %&amp;gt;% 
  arrange(desc(espvida))
## # A tibble: 5,562 × 14
##      ano               muni    uf regiao  idhm idhm_e idhm_l idhm_r
##    &amp;lt;int&amp;gt;              &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1   2010           BLUMENAU    SC    Sul 0.806  0.722  0.894  0.812
## 2   2010            BRUSQUE    SC    Sul 0.795  0.707  0.894  0.794
## 3   2010 BALNEÁRIO CAMBORIÚ    SC    Sul 0.845  0.789  0.894  0.854
## 4   2010         RIO DO SUL    SC    Sul 0.802  0.727  0.894  0.793
## 5   2010    RANCHO QUEIMADO    SC    Sul 0.753  0.644  0.893  0.743
## 6   2010       RIO DO OESTE    SC    Sul 0.754  0.625  0.892  0.769
## 7   2010             IOMERÊ    SC    Sul 0.795  0.749  0.891  0.754
## 8   2010            JOAÇABA    SC    Sul 0.827  0.771  0.891  0.823
## 9   2010        NOVA TRENTO    SC    Sul 0.748  0.628  0.891  0.749
## 10  2010        PORTO UNIÃO    SC    Sul 0.786  0.724  0.891  0.752
## # ... with 5,552 more rows, and 6 more variables: espvida &amp;lt;dbl&amp;gt;,
## #   rdpc &amp;lt;dbl&amp;gt;, gini &amp;lt;dbl&amp;gt;, pop &amp;lt;int&amp;gt;, lat &amp;lt;dbl&amp;gt;, lon &amp;lt;dbl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;summarise&#34;&gt;&lt;code&gt;summarise&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Retorna um vetor de tamanho &lt;code&gt;1&lt;/code&gt; a partir de uma conta com as variáveis.&lt;/li&gt;
&lt;li&gt;Geralmente é utilizado em conjunto com &lt;code&gt;group_by&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Algumas funções importantes: &lt;code&gt;n()&lt;/code&gt;, &lt;code&gt;n_distinct()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  group_by(regiao, uf) %&amp;gt;% 
  summarise(n = n(), espvida = mean(espvida)) %&amp;gt;% 
  arrange(regiao, desc(espvida))
## Source: local data frame [27 x 4]
## Groups: regiao [5]
## 
##          regiao    uf     n  espvida
##           &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;
## 1  Centro-Oeste    DF     3 73.36000
## 2  Centro-Oeste    GO   735 69.95346
## 3  Centro-Oeste    MS   234 69.94291
## 4  Centro-Oeste    MT   423 69.42915
## 5      Nordeste    CE   552 65.60627
## 6      Nordeste    RN   501 65.11439
## 7      Nordeste    PE   555 64.92721
## 8      Nordeste    BA  1251 64.62361
## 9      Nordeste    SE   225 64.26031
## 10     Nordeste    PI   672 64.04028
## # ... with 17 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  filter(ano == 2010) %&amp;gt;% 
  count(regiao, sort = TRUE) %&amp;gt;% 
  mutate(prop = n / sum(n), prop = scales::percent(prop))
## # A tibble: 5 × 3
##         regiao     n  prop
##          &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;
## 1     Nordeste  1794 32.3%
## 2      Sudeste  1667 30.0%
## 3          Sul  1187 21.3%
## 4 Centro-Oeste   465  8.4%
## 5        Norte   449  8.1%
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;gather&#34;&gt;&lt;code&gt;gather&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Empilha&amp;rdquo; o banco de dados&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(uf, muni, ano, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  gather(tipo_idhm, idhm, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  arrange(desc(idhm))
## # A tibble: 50,058 × 5
##       uf               muni   ano tipo_idhm  idhm
##    &amp;lt;chr&amp;gt;              &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1     SC BALNEÁRIO CAMBORIÚ  2010    idhm_l 0.894
## 2     SC           BLUMENAU  2010    idhm_l 0.894
## 3     SC            BRUSQUE  2010    idhm_l 0.894
## 4     SC         RIO DO SUL  2010    idhm_l 0.894
## 5     SC    RANCHO QUEIMADO  2010    idhm_l 0.893
## 6     SC       RIO DO OESTE  2010    idhm_l 0.892
## 7     SC             IOMERÊ  2010    idhm_l 0.891
## 8     SC            JOAÇABA  2010    idhm_l 0.891
## 9     SC        NOVA TRENTO  2010    idhm_l 0.891
## 10    SC        PORTO UNIÃO  2010    idhm_l 0.891
## # ... with 50,048 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;spread&#34;&gt;&lt;code&gt;spread&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Joga&amp;rdquo; uma variável nas colunas&lt;/li&gt;
&lt;li&gt;É essencialmente a função inversa de &lt;code&gt;gather&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(muni, uf, ano, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  gather(tipo_idhm, idhm, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  spread(ano, idhm)
## # A tibble: 16,686 × 6
##                   muni    uf tipo_idhm `1991` `2000` `2010`
## *                &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1      ABADIA DE GOIÁS    GO    idhm_e  0.183  0.386  0.622
## 2      ABADIA DE GOIÁS    GO    idhm_l  0.658  0.765  0.830
## 3      ABADIA DE GOIÁS    GO    idhm_r  0.563  0.623  0.687
## 4  Abadia dos Dourados    MG    idhm_e  0.225  0.387  0.563
## 5  Abadia dos Dourados    MG    idhm_l  0.728  0.799  0.839
## 6  Abadia dos Dourados    MG    idhm_r  0.551  0.616  0.693
## 7            ABADIÂNIA    GO    idhm_e  0.188  0.292  0.579
## 8            ABADIÂNIA    GO    idhm_l  0.656  0.730  0.841
## 9            ABADIÂNIA    GO    idhm_r  0.560  0.598  0.671
## 10              Abaeté    MG    idhm_e  0.180  0.385  0.556
## # ... with 16,676 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;funções-auxiliares&#34;&gt;Funções auxiliares&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unite&lt;/code&gt; junta duas ou mais colunas usando algum separador (&lt;code&gt;_&lt;/code&gt;, por exemplo).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;separate&lt;/code&gt; faz o inverso de &lt;code&gt;unite&lt;/code&gt;, transforma uma coluna em várias usando um separador.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(muni, uf, ano, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  gather(tipo_idhm, idhm, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  separate(tipo_idhm, c(&#39;idhm_nm&#39;, &#39;tipo&#39;), sep = &#39;_&#39;) %&amp;gt;% 
  select(-idhm_nm) %&amp;gt;% 
  filter(ano == 2010) %&amp;gt;% 
  group_by(tipo) %&amp;gt;% 
  summarise(maior = muni[which.max(idhm)], idhm = max(idhm)) %&amp;gt;% 
  arrange(tipo, desc(idhm))
## # A tibble: 3 × 3
##    tipo              maior  idhm
##   &amp;lt;chr&amp;gt;              &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1     e ÁGUAS DE SÃO PEDRO 0.825
## 2     l BALNEÁRIO CAMBORIÚ 0.894
## 3     r SÃO CAETANO DO SUL 0.891
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;um-pouco-mais-de-transformação-de-dados&#34;&gt;Um pouco mais de transformação de dados&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Para juntar tabelas, usar &lt;code&gt;inner_join&lt;/code&gt;, &lt;code&gt;left_join&lt;/code&gt;, &lt;code&gt;anti_join&lt;/code&gt; etc.&lt;/li&gt;
&lt;li&gt;Para realizar operações mais gerais, usar &lt;code&gt;do&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Para retirar duplicatas, utilizar &lt;code&gt;distinct&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Modelagem</title>
      <link>/modelos/</link>
      <pubDate>Mon, 06 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/modelos/</guid>
      <description>

&lt;h2 id=&#34;aprendizado-estatístico&#34;&gt;Aprendizado Estatístico&lt;/h2&gt;

&lt;p&gt;O termos &lt;em&gt;Aprendizado Estatístico&lt;/em&gt; refere-se a uma vasta quantidade de ferramentas
que são utilizadas para entender dados. Essas ferramentas são classificadas em
&lt;strong&gt;supervisionadas&lt;/strong&gt; e &lt;strong&gt;não-supervisionadas&lt;/strong&gt;. De forma geral, aprendizado
supervisionado envolve a construção de um modelo estatístico para prever ou estimar
uma &lt;strong&gt;resposta&lt;/strong&gt; de acordo com uma ou mais informações de entrada. No aprendizado
não-supervisionado existem variáveis de entrada mas não existe uma variável resposta.
Neste caso, o objetivo é entender a estrutura e a relação entre as variáveis. Existe
uma terceira classificação para as ferramentas de aprendizado estatístico chamada
&lt;a href=&#34;https://en.wikipedia.org/wiki/Reinforcement_learning&#34;&gt;Reinforcement Learning&lt;/a&gt;, mas
não abordaremos este tema neste material.&lt;/p&gt;

&lt;h3 id=&#34;exemplos&#34;&gt;Exemplos&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Um estudo estatístico cujo objetivo é estimar a probabilidade de uma transação
ser uma fraude e são fornecidos dados relativos a transações passadas bem como se
estas foram uma fraude ou não. É considerado um estudo de aprendizado supervisionado.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Um estudo em que são fornecidas diversas informações sobre os hábitos de compras
dos clientes e deseja-se identificar diferentes segmentos, é um
estudo de aprendizado não-supervisionado.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;Neste material vamos abordar inicialmente algumas técnicas de aprendizado supervisionado.
Em seguida abordaremos superficialmente alguns conceitos de aprendizado
não-supervisionado. Todos esses conceitos serão apresentados com exemplos práticos
usando o R.&lt;/p&gt;

&lt;p&gt;Uma introdução bem interessante ao tema pode ser encontrada &lt;a href=&#34;http://www.r2d3.us/visual-intro-to-machine-learning-part-1/&#34;&gt;aqui&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Para se aprofundar mais no assunto os seguintes links são ótimas referências.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www-bcf.usc.edu/~gareth/ISL/ISLR%20Sixth%20Printing.pdf&#34;&gt;An Introduction to Statistical Learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.coursera.org/learn/practical-machine-learning&#34;&gt;Coursera - Practical Machine Learning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;aprendizado-supervisionado&#34;&gt;Aprendizado Supervisionado&lt;/h2&gt;

&lt;p&gt;Em aprendizado supervisionado é necessário em primeiro lugar definir qual é a sua variável
resposta ou variável dependente (Frequentemente chamada de $Y$). Deve-se tomar muito
cuidado ao definí-la para que o modelo responda exatamente o que você está
querendo saber.&lt;/p&gt;

&lt;p&gt;A variável resposta pode ser a quantidade de compras que um cliente fará no
próximo mês, o preço do aluguel de uma casa, uma variável binária indicando se
um cliente não pagará a fatura no próximo mês. Existem variáveis resposta que
não são preditivas também, por exemplo: dada uma imagem de um número escrito a
mão, qual número está escrito nela.&lt;/p&gt;

&lt;p&gt;Em seguida, definimos quais serão as informações que auxiliarão a prever essa
variável resposta. Essas variáveis são chamadas de variáveis explicativas, variáveis
independentes ou simplesmente $X$.&lt;/p&gt;

&lt;p&gt;Para a quantidade de compras que um cliente fará no próximo mês essas variáveis
podem ser quantidade de compras que o cliente fez neste mês, o gasto que ele teve neste mês,
quantas vezes ele frequentou a minha loja no último ano, etc.&lt;/p&gt;

&lt;p&gt;Um vetor da forma $(Y, X_1, X_2, &amp;hellip;, X_p)$ representa uma observação. Para usar
qualquer algoritmo de aprendizado de máquina, você precisará de um número suficiente
de observações. O número de observações vai depender da complexidade do algoritmo
que você quiser utilizar, da disponibilidade de observações entre outros motivos.&lt;/p&gt;

&lt;p&gt;De uma forma um pouco mais formal, podemos explciar o Aprendizado Supervisionado
da seguinte forma. Suponha que você observou uma variável resposta $Y$ e $p$
diferentes variáveis explicativas $X_1, X_2, &amp;hellip;, X_p$. Assumimos que existe alguma
relação entre $Y$ e $X = (X_1, X_2, &amp;hellip;, X_p)$. Podemos denotar matematicamente
esta relação como na seguinte equação:&lt;/p&gt;

&lt;p&gt;$$Y = f(X) + \epsilon$$&lt;/p&gt;

&lt;p&gt;O objetivo geral do aprendizado supervisionado é estimar a função $f$.
Nessa formulação, $\epsilon$ é um termo de erro aleatório com média 0. $f$ representa
a informação sistemática que $X$ fornece sobre $Y$.&lt;/p&gt;

&lt;p&gt;Existem diversas maneiras de estimar essa função. Em alguns casos assumimos uma
forma paramétrica para ela, em outros não. Alguns exemplos de algoritmos são:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Regressão Linear&lt;/li&gt;
&lt;li&gt;Regressão Logística&lt;/li&gt;
&lt;li&gt;Árvore de Decisão&lt;/li&gt;
&lt;li&gt;Florestas Aleatórias (&lt;em&gt;Random Forest&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Gradient Boosting&lt;/li&gt;
&lt;li&gt;Redes Neurais&lt;/li&gt;
&lt;li&gt;Etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cada um dos algoritmos possui as suas vantagens e desvantagens, e problemas em
que trazem melhores resultados ou não.&lt;/p&gt;

&lt;h2 id=&#34;regressão-linear&#34;&gt;Regressão Linear&lt;/h2&gt;

&lt;p&gt;Na introdução ao aprendizado supervisionado, vimos que o objetivo é sempre estimar
uma função $f$ tal que $y = f(x) + \epsilon$.&lt;/p&gt;

&lt;p&gt;O modelo linear assume que a função $f$ é uma função linear de modo que a formulação
do apredizado supervisionado pode ser reescrita da seguinte forma:&lt;/p&gt;

&lt;p&gt;$$Y = \alpha + X\beta + \epsilon$$
Em que $\alpha$ e $\beta$ são coeficientes que serão estimados. Esses valores são
calculados de forma a minimizar uma &lt;strong&gt;função de perda&lt;/strong&gt; na sua amostra. A função
mais utilizada é a perda quadrática na sua amostra. Considere $(y_1, x_1)$, $(y_2, x_2)$, &amp;hellip;, $(y_n, x_n)$ uma amostra de tamanho $n$.&lt;/p&gt;

&lt;p&gt;$\alpha$ e $\beta$ são escolhidos de tal forma que:&lt;/p&gt;

&lt;p&gt;$$\sum_{i = 1}^{n} [y_i - (\alpha + \beta x_i)]^2$$
seja o menor possível. Isto é, estamos minimizando o &lt;em&gt;erro quadrático&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Na ótica da estatística, assumimos também que $Y \sim Normal(\alpha + X \beta, \sigma^2)$,
escolhemos $\alpha$ e $\beta$ de forma que maximize uma função que chamamos de &lt;a href=&#34;https://pt.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_de_verossimilhan%C3%A7a&#34;&gt;verossimilhança&lt;/a&gt;.
Essa suposição é útil quando queremos fazer testes de hipóteses e intervalos de
confiança. Por enquanto, não estamos interessados nisso e portanto vamos
apresentar uma visão menos complexa.&lt;/p&gt;

&lt;h3 id=&#34;exemplo&#34;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Considere o banco de dados &lt;em&gt;BodyFat&lt;/em&gt; obtido &lt;a href=&#34;http://www2.stetson.edu/~jrasp/data.htm&#34;&gt;aqui&lt;/a&gt;.
Esses são dados do percentual de gordura corporal em uma amostra de 252 homens junto com
diversas outras medidas corporais. O percentual de gordura corporal é medido pesando
a pessoa sob a água, um procedimento trabalhoso. O objetivo é fazer um modelo linear
que permita obter o percentual de gordura usando medidas do corpo fáceis de serem obtidas.
Os dados são do site do Journal of Statistics Education.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(readxl)
library(dplyr)
library(ggplot2)
bodyfat &amp;lt;- read_excel(&#39;data/BodyFat.xls&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(bodyfat, aes(x = WEIGHT, y = BODYFAT)) + geom_point()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-11-1.png&#34; title=&#34;plot of chunk unnamed-chunk-11&#34; alt=&#34;plot of chunk unnamed-chunk-11&#34; width=&#34;50%&#34; height=&#34;50%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A partir do gráfico de dispersão, vemos que o peso do indivíduo parece ser &lt;strong&gt;linearmente&lt;/strong&gt;
relacionado ao percentual de gordura corporal. Vamos então ajustar um modelo linear
usando o R. Para ajustar o modelo, usamos a função &lt;code&gt;lm&lt;/code&gt; (de &lt;em&gt;&lt;strong&gt;l&lt;/strong&gt;inear &lt;strong&gt;m&lt;/strong&gt;odel&lt;/em&gt;).
A função &lt;code&gt;lm&lt;/code&gt;, assim como muitas outras que ajustam modelo no R, recebe como argumentos
uma formula e um banco de dados.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;formula&lt;/code&gt; é um tipo especial de objeto no R que ajuda muito na especificação dos modelos.
Ela tem a forma &lt;code&gt;y ~ x1 + x2 + ... + xn&lt;/code&gt; em que &lt;code&gt;y&lt;/code&gt; é o nome da variável resposta e &lt;code&gt;x1&lt;/code&gt;,
&lt;code&gt;x2&lt;/code&gt;, &amp;hellip;, &lt;code&gt;xn&lt;/code&gt; são os nomes das variáveis que serão utilizadas como explicativas.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ajuste &amp;lt;- lm(BODYFAT ~ WEIGHT, data = bodyfat)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Com essa chamada da função criamos o objeto &lt;code&gt;ajuste&lt;/code&gt;. Esse objeto abriga informações
relacionadas ao ajuste do modelo.&lt;/p&gt;

&lt;p&gt;$$bodyfat = \alpha + \beta*weight + \epsilon$$
As estimativas de $\alpha$ e $\beta$ podem ser encontradas usando a função &lt;code&gt;summary&lt;/code&gt;.
A estimativa de $\alpha$ é o valor da coluna &lt;code&gt;Estimate&lt;/code&gt; na linha &lt;code&gt;(Intercept)&lt;/code&gt;: -9.99515
e a estimativa de $\beta$ é o valor logo abaixo: 0.16171.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;summary(ajuste)
## 
## Call:
## lm(formula = BODYFAT ~ WEIGHT, data = bodyfat)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -16.434  -4.315   0.079   4.540  19.681 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept) -9.99515    2.38906  -4.184 3.97e-05 ***
## WEIGHT       0.16171    0.01318  12.273  &amp;lt; 2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 6.135 on 250 degrees of freedom
## Multiple R-squared:  0.376,	Adjusted R-squared:  0.3735 
## F-statistic: 150.6 on 1 and 250 DF,  p-value: &amp;lt; 2.2e-16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Em R, o ajuste de um modelo estatístico é salvo em um objeto. Esse objeto é uma
&lt;code&gt;list&lt;/code&gt; que armazena diversas informações sobre o ajuste. Você pode ver algumas
informações disponíveis quando vê a estrutura do objeto &lt;code&gt;ajuste&lt;/code&gt; usando a função
&lt;code&gt;str&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str(ajuste, max.level = 1)
## List of 12
##  $ coefficients : Named num [1:2] -9.995 0.162
##   ..- attr(*, &amp;quot;names&amp;quot;)= chr [1:2] &amp;quot;(Intercept)&amp;quot; &amp;quot;WEIGHT&amp;quot;
##  $ residuals    : Named num [1:252] -2.35 -11.12 9.69 -8.98 8 ...
##   ..- attr(*, &amp;quot;names&amp;quot;)= chr [1:252] &amp;quot;1&amp;quot; &amp;quot;2&amp;quot; &amp;quot;3&amp;quot; &amp;quot;4&amp;quot; ...
##  $ effects      : Named num [1:252] -300.64 75.29 10.38 -9.01 7.98 ...
##   ..- attr(*, &amp;quot;names&amp;quot;)= chr [1:252] &amp;quot;(Intercept)&amp;quot; &amp;quot;WEIGHT&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; ...
##  $ rank         : int 2
##  $ fitted.values: Named num [1:252] 14.9 18 14.9 19.9 19.8 ...
##   ..- attr(*, &amp;quot;names&amp;quot;)= chr [1:252] &amp;quot;1&amp;quot; &amp;quot;2&amp;quot; &amp;quot;3&amp;quot; &amp;quot;4&amp;quot; ...
##  $ assign       : int [1:2] 0 1
##  $ qr           :List of 5
##   ..- attr(*, &amp;quot;class&amp;quot;)= chr &amp;quot;qr&amp;quot;
##  $ df.residual  : int 250
##  $ xlevels      : Named list()
##  $ call         : language lm(formula = BODYFAT ~ WEIGHT, data = bodyfat)
##  $ terms        :Classes &#39;terms&#39;, &#39;formula&#39;  language BODYFAT ~ WEIGHT
##   .. ..- attr(*, &amp;quot;variables&amp;quot;)= language list(BODYFAT, WEIGHT)
##   .. ..- attr(*, &amp;quot;factors&amp;quot;)= int [1:2, 1] 0 1
##   .. .. ..- attr(*, &amp;quot;dimnames&amp;quot;)=List of 2
##   .. ..- attr(*, &amp;quot;term.labels&amp;quot;)= chr &amp;quot;WEIGHT&amp;quot;
##   .. ..- attr(*, &amp;quot;order&amp;quot;)= int 1
##   .. ..- attr(*, &amp;quot;intercept&amp;quot;)= int 1
##   .. ..- attr(*, &amp;quot;response&amp;quot;)= int 1
##   .. ..- attr(*, &amp;quot;.Environment&amp;quot;)=&amp;lt;environment: 0x1928660&amp;gt; 
##   .. ..- attr(*, &amp;quot;predvars&amp;quot;)= language list(BODYFAT, WEIGHT)
##   .. ..- attr(*, &amp;quot;dataClasses&amp;quot;)= Named chr [1:2] &amp;quot;numeric&amp;quot; &amp;quot;numeric&amp;quot;
##   .. .. ..- attr(*, &amp;quot;names&amp;quot;)= chr [1:2] &amp;quot;BODYFAT&amp;quot; &amp;quot;WEIGHT&amp;quot;
##  $ model        :&#39;data.frame&#39;:	252 obs. of  2 variables:
##   ..- attr(*, &amp;quot;terms&amp;quot;)=Classes &#39;terms&#39;, &#39;formula&#39;  language BODYFAT ~ WEIGHT
##   .. .. ..- attr(*, &amp;quot;variables&amp;quot;)= language list(BODYFAT, WEIGHT)
##   .. .. ..- attr(*, &amp;quot;factors&amp;quot;)= int [1:2, 1] 0 1
##   .. .. .. ..- attr(*, &amp;quot;dimnames&amp;quot;)=List of 2
##   .. .. ..- attr(*, &amp;quot;term.labels&amp;quot;)= chr &amp;quot;WEIGHT&amp;quot;
##   .. .. ..- attr(*, &amp;quot;order&amp;quot;)= int 1
##   .. .. ..- attr(*, &amp;quot;intercept&amp;quot;)= int 1
##   .. .. ..- attr(*, &amp;quot;response&amp;quot;)= int 1
##   .. .. ..- attr(*, &amp;quot;.Environment&amp;quot;)=&amp;lt;environment: 0x1928660&amp;gt; 
##   .. .. ..- attr(*, &amp;quot;predvars&amp;quot;)= language list(BODYFAT, WEIGHT)
##   .. .. ..- attr(*, &amp;quot;dataClasses&amp;quot;)= Named chr [1:2] &amp;quot;numeric&amp;quot; &amp;quot;numeric&amp;quot;
##   .. .. .. ..- attr(*, &amp;quot;names&amp;quot;)= chr [1:2] &amp;quot;BODYFAT&amp;quot; &amp;quot;WEIGHT&amp;quot;
##  - attr(*, &amp;quot;class&amp;quot;)= chr &amp;quot;lm&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por exemplo você pode acessar os coeficientes do modelo usando &lt;code&gt;ajuste$coefficients&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Outra função que existe para a maior parte dos modelos que podem ser ajustados usando o R
a &lt;code&gt;predict&lt;/code&gt;. Usamos a função &lt;code&gt;predict&lt;/code&gt; para obter as estimativas do modelo ajustado para
uma base de dados (nova ou não).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bodyfat$predito_modelo1 &amp;lt;- predict(ajuste, newdata = bodyfat)
bodyfat %&amp;gt;% select(WEIGHT, BODYFAT, predito_modelo1) %&amp;gt;% head() %&amp;gt;% knitr::kable()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;WEIGHT&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;BODYFAT&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;predito_modelo1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;154.25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;14.94842&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;173.25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;18.02089&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;154.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;24.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;14.90800&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;184.75&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;19.88054&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;184.25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;27.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;19.79969&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;210.25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;24.00412&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Nessa tabela, vemos o valor predito pelo modelo para cada observação bem como o
valor verdadeiro de gordura corporal daquele indivíduo. Nosso modelo não parece
estar muito bom. Uma possível medida de erro é o MSE (Erro quadrático médio).
Podemos calculá-lo fazendo contas simples no R.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;mse &amp;lt;- mean((bodyfat$BODYFAT - bodyfat$predito_modelo1)^2)
mse
## [1] 37.34089
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É mais fácil identificar se esse erro é baixo ou não comparando-o com o erro se
usássemos a média da variável como valor predito para todas as observações e
tirando a raíz quadrada dos dois.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;erro_usando_media &amp;lt;- mean((bodyfat$BODYFAT - mean(bodyfat$BODYFAT))^2)
erro_usando_media
## [1] 59.83737

sqrt(mse)
## [1] 6.110719
sqrt(erro_usando_media)
## [1] 7.735462
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora podemos ter uma ideia de que o nosso erro está alto. Se usássemos apenas a
média erraríamos em média 7,7 usando o nosso modelo, ficamos com 6,1.&lt;/p&gt;

&lt;p&gt;Felizmente, podemos melhorar o modelo adicionando mais variáveis. No R basta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ajuste2 &amp;lt;- lm(BODYFAT ~ WEIGHT + HEIGHT + CHEST + ABDOMEN + NECK + KNEE, 
              data = bodyfat)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O erro pode ser novamente calculado repetindo as operações que fizemos anteriormente.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bodyfat$predito_modelo2 &amp;lt;- predict(ajuste2, newdata = bodyfat)
mse &amp;lt;- mean((bodyfat$BODYFAT - bodyfat$predito_modelo2)^2)
sqrt(mse)
## [1] 4.049453
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora reduzimos bastante o erro. É muito importante ressaltar que estamos avaliando
o erro dentro da mesma base de dados que utilizamos para ajustar o modelo. Isso é
considerado uma má prática, pois podemos facilmente esbarrar em uma situação de
&lt;em&gt;superajuste&lt;/em&gt; ou &lt;em&gt;overfitting&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;recapitulando&#34;&gt;Recapitulando&lt;/h3&gt;

&lt;p&gt;Ajustar um modelo de regressão linear no R é muito simples.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Usamos a função &lt;code&gt;lm&lt;/code&gt; que recebe uma fórmula de especificação do modelo e um data.frame.&lt;/li&gt;
&lt;li&gt;A função &lt;code&gt;lm&lt;/code&gt; retorna um obejto do tipo &lt;code&gt;lm&lt;/code&gt;, que é uma &lt;code&gt;list&lt;/code&gt; que armazena diversas informações sobre o ajuste.&lt;/li&gt;
&lt;li&gt;A função &lt;code&gt;summary&lt;/code&gt; e a função &lt;code&gt;str&lt;/code&gt; ajudam a identificar o conteúdo do objeto do modelo.&lt;/li&gt;
&lt;li&gt;A função &lt;code&gt;predict&lt;/code&gt; é usada para aplicar o modelo em um novo banco de dados.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Essas funções são bem parecidas para qualquer modelo que você ajustar no R futuramente.&lt;/p&gt;

&lt;h2 id=&#34;árvore-de-decisão&#34;&gt;Árvore  de Decisão&lt;/h2&gt;

&lt;p&gt;Os modelos de árvore de decisão como vamos utilizar são implementados de acordo
com o livro &lt;em&gt;Classification and Regression Trees&lt;/em&gt; de Breiman, Friedman, Olshen e Stone.&lt;/p&gt;

&lt;p&gt;De certa forma, a árvore de decisão é o modelo mais intuitivo que existe, principalmente
quando o objetivo é classificar uma observação em uma de duas classes. Considere
que o seu objetivo é separar as observações azuis das observações laranjas no
gráfico abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-20-1.png&#34; title=&#34;plot of chunk unnamed-chunk-20&#34; alt=&#34;plot of chunk unnamed-chunk-20&#34; width=&#34;50%&#34; height=&#34;50%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pelo gráfico acima, podemos ver que a variável $x$ fornece informação que ajuda
a discriminar se a observação será azul ou laranja. Basta ver que as observações
de cor laranja estão mais concentradas do lado direito e as azuis, mais para o
lado esquerdo. O objetivo da árvore de decisão é encontrar o valor de $x$ que
melhor separa as informações azuis e laranja.&lt;/p&gt;

&lt;p&gt;Para detalhar um pouco mais, imagine que você tem um nó com $N$ observações e que
$n$ possuem $Resposta = 1$ (Exemplo Cor = &amp;lsquo;Azul&amp;rsquo;) e $N - n$ possuem $Resposta = 0$,
ou seja, temos um problema de classificação binária. Então neste caso $p = \frac{n}{N}$
é a proporção de resposta neste nó.&lt;/p&gt;

&lt;p&gt;O objetivo da árvore de decisão dividir este &lt;em&gt;nó&lt;/em&gt; (grupo de observações) em 2 de
forma que a diferença entre a proporção de classes entre os dois nós resultantes
seja a maior possível. Claro que cada um dos nós precisa ter uma quantidade
significativa de observações de forma que $p$ seja estimado corretamente.&lt;/p&gt;

&lt;p&gt;No R, o pacote que usamos para fazer este tipo de análise é o &lt;a href=&#34;https://CRAN.R-project.org/package=rpart&#34;&gt;&lt;code&gt;rpart&lt;/code&gt;&lt;/a&gt;. Uma introdução
mais formal a esses métodos pode ser encontrada na vignette do pacote &lt;code&gt;rpart&lt;/code&gt;.
Digite &lt;code&gt;vignette(&#39;longintro&#39;, package = &#39;rpart&#39;)&lt;/code&gt; no console para encontrá-la.&lt;/p&gt;

&lt;p&gt;Existem ainda outras alternativas de pacotes como o &lt;a href=&#34;https://CRAN.R-project.org/package=tree&#34;&gt;&lt;code&gt;tree&lt;/code&gt;&lt;/a&gt;,
e &lt;a href=&#34;https://CRAN.R-project.org/package=party&#34;&gt;&lt;code&gt;party&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;exemplo-1&#34;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Para esse exemplo vamos usar o banco de dados do Titanic. Um banco de dados que
ficou famoso por causa de uma competição no Kaggle. Esse banco de dados contém
diversas informações sobre os passageiros do Titanic bem como uma variável que
indica se o passageiro sobreviveu (1) e se não sobreviveu (0).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(readr)
titanic &amp;lt;- read_csv(&#39;data/titanic-train.csv&#39;)
## Parsed with column specification:
## cols(
##   PassengerId = col_integer(),
##   Survived = col_integer(),
##   Pclass = col_integer(),
##   Name = col_character(),
##   Sex = col_character(),
##   Age = col_double(),
##   SibSp = col_integer(),
##   Parch = col_integer(),
##   Ticket = col_character(),
##   Fare = col_double(),
##   Cabin = col_character(),
##   Embarked = col_character()
## )
titanic$Survived &amp;lt;- as.factor(titanic$Survived)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usaremos o pacote &lt;code&gt;rpart&lt;/code&gt; que por sua vez possui uma função chamada &lt;code&gt;rpart&lt;/code&gt;.
A função &lt;code&gt;rpart&lt;/code&gt; recebe uma fórmula indicando a variável resposta e as
variáveis que serão utilizadas no modelo, além de receber um argumento
&lt;code&gt;data&lt;/code&gt; que indica o banco de dados utilizado.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(rpart)
arvore &amp;lt;- rpart(Survived ~ Sex + Age + Pclass, data = titanic)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assim como na regressão linear, podemos ver informações sobre o ajuste
usando a função &lt;code&gt;summary&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;summary(arvore)
## Call:
## rpart(formula = Survived ~ Sex + Age + Pclass, data = titanic)
##   n= 891 
## 
##           CP nsplit rel error    xerror       xstd
## 1 0.44444444      0 1.0000000 1.0000000 0.04244576
## 2 0.02339181      1 0.5555556 0.5555556 0.03574957
## 3 0.01461988      2 0.5321637 0.5614035 0.03588593
## 4 0.01169591      4 0.5029240 0.5643275 0.03595352
## 5 0.01000000      6 0.4795322 0.5438596 0.03547203
## 
## Variable importance
##    Sex Pclass    Age 
##     70     18     12 
## 
## Node number 1: 891 observations,    complexity param=0.4444444
##   predicted class=0  expected loss=0.3838384  P(node) =1
##     class counts:   549   342
##    probabilities: 0.616 0.384 
##   left son=2 (577 obs) right son=3 (314 obs)
##   Primary splits:
##       Sex    splits as  RL,       improve=124.426300, (0 missing)
##       Pclass &amp;lt; 2.5  to the right, improve= 43.781830, (0 missing)
##       Age    &amp;lt; 6.5  to the right, improve=  8.814172, (177 missing)
## 
## Node number 2: 577 observations,    complexity param=0.02339181
##   predicted class=0  expected loss=0.1889081  P(node) =0.647587
##     class counts:   468   109
##    probabilities: 0.811 0.189 
##   left son=4 (553 obs) right son=5 (24 obs)
##   Primary splits:
##       Age    &amp;lt; 6.5  to the right, improve=10.78893, (124 missing)
##       Pclass &amp;lt; 1.5  to the right, improve=10.01914, (0 missing)
## 
## Node number 3: 314 observations,    complexity param=0.01461988
##   predicted class=1  expected loss=0.2579618  P(node) =0.352413
##     class counts:    81   233
##    probabilities: 0.258 0.742 
##   left son=6 (144 obs) right son=7 (170 obs)
##   Primary splits:
##       Pclass &amp;lt; 2.5  to the right, improve=31.163130, (0 missing)
##       Age    &amp;lt; 12   to the left,  improve= 1.891684, (53 missing)
##   Surrogate splits:
##       Age &amp;lt; 18.5 to the left,  agree=0.564, adj=0.049, (0 split)
## 
## Node number 4: 553 observations
##   predicted class=0  expected loss=0.1681736  P(node) =0.620651
##     class counts:   460    93
##    probabilities: 0.832 0.168 
## 
## Node number 5: 24 observations
##   predicted class=1  expected loss=0.3333333  P(node) =0.02693603
##     class counts:     8    16
##    probabilities: 0.333 0.667 
## 
## Node number 6: 144 observations,    complexity param=0.01461988
##   predicted class=0  expected loss=0.5  P(node) =0.1616162
##     class counts:    72    72
##    probabilities: 0.500 0.500 
##   left son=12 (12 obs) right son=13 (132 obs)
##   Primary splits:
##       Age &amp;lt; 38.5 to the right, improve=3.875163, (42 missing)
## 
## Node number 7: 170 observations
##   predicted class=1  expected loss=0.05294118  P(node) =0.1907969
##     class counts:     9   161
##    probabilities: 0.053 0.947 
## 
## Node number 12: 12 observations
##   predicted class=0  expected loss=0.08333333  P(node) =0.01346801
##     class counts:    11     1
##    probabilities: 0.917 0.083 
## 
## Node number 13: 132 observations,    complexity param=0.01169591
##   predicted class=1  expected loss=0.4621212  P(node) =0.1481481
##     class counts:    61    71
##    probabilities: 0.462 0.538 
##   left son=26 (117 obs) right son=27 (15 obs)
##   Primary splits:
##       Age &amp;lt; 5.5  to the right, improve=1.777778, (42 missing)
## 
## Node number 26: 117 observations,    complexity param=0.01169591
##   predicted class=1  expected loss=0.4871795  P(node) =0.1313131
##     class counts:    57    60
##    probabilities: 0.487 0.513 
##   left son=52 (8 obs) right son=53 (109 obs)
##   Primary splits:
##       Age &amp;lt; 12   to the left,  improve=3.900498, (42 missing)
## 
## Node number 27: 15 observations
##   predicted class=1  expected loss=0.2666667  P(node) =0.01683502
##     class counts:     4    11
##    probabilities: 0.267 0.733 
## 
## Node number 52: 8 observations
##   predicted class=0  expected loss=0  P(node) =0.008978676
##     class counts:     8     0
##    probabilities: 1.000 0.000 
## 
## Node number 53: 109 observations
##   predicted class=1  expected loss=0.4495413  P(node) =0.1223345
##     class counts:    49    60
##    probabilities: 0.450 0.550
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Visualizar a árvore de decisão sempre dá bons &lt;em&gt;insights&lt;/em&gt;. Um pacote que é interessante
para visualizar a árvore de decisão construída com o &lt;code&gt;rpart&lt;/code&gt; é o &lt;a href=&#34;https://CRAN.R-project.org/package=rpart.plot&#34;&gt;&lt;code&gt;rpart.plot&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(rpart.plot)
rpart.plot(arvore)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-24-1.png&#34; title=&#34;plot of chunk unnamed-chunk-24&#34; alt=&#34;plot of chunk unnamed-chunk-24&#34; width=&#34;70%&#34; height=&#34;70%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A visualização é bem intuitiva. No topo, vemos o primeiro nó em que 38% dos indivíduos
sobreviveram e que representa o total da base (100%). Em seguida, vemos que a primeira
variável que discrimina quem sobreviveu ou não é a variável Sexo: Dos homens, que eram 65%
dos passageiros, apenas 19% sobreviveu enquanto das mulheres, que eram 35%, 74% sobreviveu.
Dos homens, aqueles que eram menores de 6 anos e meio, sobreviveram em maior proporção
também. A interpretação pode continuar dessa forma recursivamente.&lt;/p&gt;

&lt;p&gt;Mais uma vez, assim como na regressão linear, podemos utilizar a função &lt;code&gt;predict&lt;/code&gt; para
obter a probabilidade predita de sobrevivência e a classificação predita para cada
observação. A diferença é que agora temos o parâmetros &lt;code&gt;type&lt;/code&gt;, que vai indicar se queremos
a probabilidade ou a classe predita.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;probabilidades &amp;lt;- predict(arvore, newdata = titanic, type = &#39;prob&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Com &lt;code&gt;type = &#39;prob&#39;&lt;/code&gt; obtemos uma &lt;code&gt;matrix&lt;/code&gt; em que cada coluna representa a probabilidade
predita para cada classe. Quando temos apenas um classe isso pode parecer desnecessário
já que o valor de uma coluna é a diferença de 1 pelo valor da outra, mas árvores podem
ser utilizadas em modelos com mais de classificação para mais de duas categorias.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;classes &amp;lt;- predict(arvore, newdata = titanic, type = &#39;class&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quando você prevê a classe diretamente, o &lt;code&gt;rpart&lt;/code&gt; indica como predito quando a
probabilidade de sobrevivência é maior do que 50%. Isso nem sempre é o que garante
o maior ganho com o modelo. Principalmente em problemas em que as classes são muito
desbalanceadas. Além disso, em outros problemas, os custos de classificar uma observação
como positiva quando ela é negativa, podem ser diferentes de classificá-la como negativa
quando ela é positiva.&lt;/p&gt;

&lt;p&gt;Para escolher o melhor ponto de corte da probabilidade, podemos usar a curva ROC, e
uma função de custo. Existem diversos pacotes que ajudam a calcular essas medidas. Vamos fazer aqui sem usá-los para praticar.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(tidyverse)
## Loading tidyverse: tibble
## Loading tidyverse: tidyr
## Loading tidyverse: purrr
## Conflicts with tidy packages ----------------------------------------------
## filter(): dplyr, stats
## lag():    dplyr, stats
cortes &amp;lt;- seq(0,1,by = 0.01)
valores &amp;lt;- map_df(cortes, function(x){
  tabela &amp;lt;- table(
    titanic$Survived, 
    factor(probabilidades[,2] &amp;gt; x, levels = c(&amp;quot;FALSE&amp;quot;, &amp;quot;TRUE&amp;quot;))
    )
  data_frame(
    corte = x,
    FPR = tabela[1,2]/sum(tabela[1,]),
    TPR = tabela[2,2]/sum(tabela[2,]),
    TNR = tabela[1,1]/sum(tabela[1,]),
    FNR = tabela[2,1]/sum(tabela[2,])
  )
})


ggplot(valores, aes(x = FPR, y = TPR)) + 
  geom_step() + 
  geom_abline(color = &#39;blue&#39;, linetype = &#39;dashed&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-27-1.png&#34; title=&#34;plot of chunk unnamed-chunk-27&#34; alt=&#34;plot of chunk unnamed-chunk-27&#34; width=&#34;50%&#34; height=&#34;50%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A função de custo pode ser calculada da seguinte forma. Veja que estamos considerando
pesos iguais para ambos os erros.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;valores %&amp;gt;%
  mutate(custo = FPR + FNR) %&amp;gt;%
  ggplot(aes(x = corte, y = custo)) +
  geom_line()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-28-1.png&#34; title=&#34;plot of chunk unnamed-chunk-28&#34; alt=&#34;plot of chunk unnamed-chunk-28&#34; width=&#34;50%&#34; height=&#34;50%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Neste caso, o ponto mínimo da função é obtido com qualquer corte entre um pouco menos de 25%
até um pouco mais de 50%. Isso nem sempre é verdade e deve ser avaliado em cada modelo.&lt;/p&gt;

&lt;h2 id=&#34;overfitting&#34;&gt;Overfitting&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Overfitting&lt;/em&gt; ou &lt;em&gt;superajuste&lt;/em&gt; acontece quando a função $f$ estimada por algum
modelo da forma $y = f(x) + \epsilon$ é muito específica sendo assim, quando avaliamos
o modelo em um outro conjunto de observações percebemos que o erro aumenta muito.&lt;/p&gt;

&lt;p&gt;Isso acontece quando o modelo aprende muitos detalhes e ruidos da base de treino e
ao aplicar o modelo em novos dados, como esses detalhes/ruídos não se repetem, a
performance do modelo é impactada de forma negativa.&lt;/p&gt;

&lt;p&gt;Para visualizar o que é overfitting, considere o seguinte banco de dados.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
library(dplyr)
set.seed(7)
dados &amp;lt;- data_frame(
  x = runif(10),
  y = 2*x + rnorm(10, 0, 0.1)
)
ggplot(dados, aes(x = x, y = y)) + geom_point()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-29-1.png&#34; title=&#34;plot of chunk unnamed-chunk-29&#34; alt=&#34;plot of chunk unnamed-chunk-29&#34; width=&#34;50%&#34; height=&#34;50%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Esse banco de dados foi gerado usando exatamente as suposições de um modelo de regressão.
Temos uma variável $x$ e uma variável $y$ que é calculada com $2*x + \epsilon$ em que
$\epsilon$ é uma variável aleatória com distribuição Normal de média zero e desvio padrão $0.1$.&lt;/p&gt;

&lt;p&gt;Portanto, o melhor modelo para explicar esses dados, seria um modelo linear bem simples,
que poderia ser ajsutado no R usando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;modelo &amp;lt;- lm(y ~ x, data = dados)
summary(modelo)
## 
## Call:
## lm(formula = y ~ x, data = dados)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.18459 -0.08062 -0.03914  0.11382  0.17434 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  0.10125    0.07015   1.443    0.187    
## x            1.98848    0.12519  15.884 2.47e-07 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.1298 on 8 degrees of freedom
## Multiple R-squared:  0.9693,	Adjusted R-squared:  0.9654 
## F-statistic: 252.3 on 1 and 8 DF,  p-value: 2.471e-07
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note que mesmo com 10 observações o modelo acertou precisamente os parâmetros que
utilizamos para simular os dados. Mas existe uma aleatoriedade inerente ao método
que utilizamos para construir o banco de dados.&lt;/p&gt;

&lt;p&gt;Imagine se, ao invés de ajustar esse modelo, tivessemos ajustado o modelo:&lt;/p&gt;

&lt;p&gt;$$y = \alpha + \beta_1x + \beta_2x^2 + &amp;hellip; + \beta_9x^9 + \epsilon$$
No R:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;modelo2 &amp;lt;- lm(y ~ poly(x, 9), data = dados)
summary(modelo2)
## 
## Call:
## lm(formula = y ~ poly(x, 9), data = dados)
## 
## Residuals:
## ALL 10 residuals are 0: no residual degrees of freedom!
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)
## (Intercept)  1.00501         NA      NA       NA
## poly(x, 9)1  2.06100         NA      NA       NA
## poly(x, 9)2 -0.18881         NA      NA       NA
## poly(x, 9)3  0.10846         NA      NA       NA
## poly(x, 9)4 -0.02527         NA      NA       NA
## poly(x, 9)5 -0.20073         NA      NA       NA
## poly(x, 9)6 -0.11473         NA      NA       NA
## poly(x, 9)7 -0.12387         NA      NA       NA
## poly(x, 9)8 -0.11701         NA      NA       NA
## poly(x, 9)9 -0.06445         NA      NA       NA
## 
## Residual standard error: NaN on 0 degrees of freedom
## Multiple R-squared:      1,	Adjusted R-squared:    NaN 
## F-statistic:   NaN on 9 and 0 DF,  p-value: NA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja agora o gráfico dos modelos ajsutados:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(dados, aes(x = x, y = y)) + geom_point() + 
  geom_smooth(formula = y ~ x, colour = &amp;quot;red&amp;quot;, se = FALSE, method = &#39;lm&#39;) +
  geom_smooth(formula = y ~ poly(x, 9), se = FALSE, method = &#39;lm&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-32-1.png&#34; title=&#34;plot of chunk unnamed-chunk-32&#34; alt=&#34;plot of chunk unnamed-chunk-32&#34; width=&#34;50%&#34; height=&#34;50%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O linha em vermelho, é a reta ajustada pelo primeiro modelo, ou seja, o modelo que
utilizamos para gerar os dados. A linha azul, é a curva ajustada pelo polinômio do
nono grau. O modelo azul acerta todos os pontos enquanto o vermelho (que é o modelo
correto não). Se calcularmos o erro médio quadrático de cada um dos modelos, chegaríamos
a conclusão de que o modelo azul é melhor.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;erro_modelo1 &amp;lt;- mean((dados$y - predict(modelo, newdata = dados))^2)
erro_modelo2 &amp;lt;- mean((dados$y - predict(modelo2, newdata = dados))^2)
erro_modelo1 %&amp;gt;% round(3)
## [1] 0.013
erro_modelo2 %&amp;gt;% round(3)
## [1] 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mas e gerarmos mais dados de acordo com o nosso modelo inicial? Qual modelo terá melhor
performance?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados2 &amp;lt;- data_frame(
  x = runif(100),
  y = 2*x + rnorm(100, 0, 0.1)
)
ggplot(dados2, aes(x = x, y = y)) + geom_point() +
  geom_smooth(data = dados, formula = y ~ x, colour = &amp;quot;red&amp;quot;, se = FALSE, method = &#39;lm&#39;) +
  geom_smooth(data = dados, formula = y ~ poly(x, 9), se = FALSE, method = &#39;lm&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-34-1.png&#34; title=&#34;plot of chunk unnamed-chunk-34&#34; alt=&#34;plot of chunk unnamed-chunk-34&#34; width=&#34;50%&#34; height=&#34;50%&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;erro_modelo1 &amp;lt;- mean((dados2$y - predict(modelo, newdata = dados2))^2)
erro_modelo2 &amp;lt;- mean((dados2$y - predict(modelo2, newdata = dados2))^2)
erro_modelo1 %&amp;gt;% round(3)
## [1] 0.015
erro_modelo2 %&amp;gt;% round(3)
## [1] 6.772
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O modelo que acertava todas as observações na base que usamos para treinar, passou
a errar mais quando testado em novos dados.&lt;/p&gt;

&lt;p&gt;Isso é o que chamamos de &lt;em&gt;overfitting&lt;/em&gt;. O modelo azul ajustou ruidos aleatórios que
eram inerentes à forma com que os dados foram gerados e dessa forma, não foi capaz
de prever bem em dados que tinham ruidos aleatorios diferentes.&lt;/p&gt;

&lt;p&gt;Claro, esse exemplo é ilustrativo. Desde o começo sabíamos a forma com que os dados
eram gerados. Isso raramente acontece. Na prática, estamos tentando criar um modelo
para explicar como os dados são gerados, por isso temos que tomar bastante cuidado
para não assumir relações desta forma e criar modelos que explicam apenas aquela amostra.&lt;/p&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;ol&gt;
&lt;li&gt;Calcule o número de ouro no R.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$$
\frac{1 + \sqrt{5}}{2}
$$&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIERpZ2l0ZSBhIGV4cHJlc3NcdTAwZTNvIHF1ZSBjYWxjdWxhIG8gblx1MDBmYW1lcm8gZGUgb3Vyby4iLCJzb2x1dGlvbiI6IigxICsgc3FydCg1KSkvMiIsInNjdCI6InRlc3Rfb3V0cHV0X2NvbnRhaW5zKFwiMS42MTgwMzRcIiwgaW5jb3JyZWN0X21zZyA9IFwiVGVtIGNlcnRlemEgZGUgcXVlIGluZGljb3UgYSBleHByZXNzXHUwMGUzbyBjb3JyZXRhbWVudGU/XCIpXG5zdWNjZXNzX21zZyhcIkNvcnJldG8hXCIpIn0=&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>ggplot</title>
      <link>/ggplot/</link>
      <pubDate>Sun, 05 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/ggplot/</guid>
      <description>

&lt;p&gt;Para este tópico vamos utilizar o &lt;code&gt;ggplot2&lt;/code&gt;. O &lt;code&gt;ggplot2&lt;/code&gt; é um pacote do R voltado
para a criação de gráficos estatísticos. Ele é baseado na Gramática dos Gráficos
(&lt;em&gt;grammar of graphics&lt;/em&gt;, em inglês), criado por Leland Wilkinson, que é uma
resposta para a pergunta: o que é um gráfico estatístico? Resumidamente, a gramática
diz que um gráfico estatístico é um mapeamento dos dados a partir de atributos
estéticos (cores, formas, tamanho) em formas geométricas (pontos, linhas, barras).&lt;/p&gt;

&lt;p&gt;Para mais informações sobre a Gramática dos Gráficos, você pode consultar o livro
&lt;a href=&#34;http://www.springer.com/statistics/computational+statistics/book/978-0-387-24544-7&#34;&gt;&lt;em&gt;The Grammar of graphics&lt;/em&gt;&lt;/a&gt;,
escrito pelo Leland Wilkinson e o livro &lt;a href=&#34;http://ggplot2.org/book/&#34;&gt;ggplot2: elegant graphics for data analysis&lt;/a&gt;, do Hadley Wickham.
Um &lt;a href=&#34;http://moderngraphics11.pbworks.com/f/ggplot2-Book09hWickham.pdf&#34;&gt;pdf do livro&lt;/a&gt; também está disponível.&lt;/p&gt;

&lt;p&gt;Para quem quiser se aprofundar mais com o &lt;code&gt;ggplot2&lt;/code&gt;, o &lt;a href=&#34;https://www.datacamp.com/&#34;&gt;DataCamp&lt;/a&gt; possui dois cursos
focados em visualização. É possível começar o curso gratuitamente, mas para terminar,
tem que pagar.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.datacamp.com/courses/data-visualization-with-ggplot2-1&#34;&gt;Data Visualization with ggplot2 (Part 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.datacamp.com/courses/data-visualization-with-ggplot2-2&#34;&gt;Data Visualization with ggplot2 (Part 2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Antes de começar, instale o pacote digitando &lt;code&gt;install.packages(&amp;quot;ggplot2&amp;quot;)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;banco-de-dados&#34;&gt;Banco de dados&lt;/h2&gt;

&lt;p&gt;A seguir, vamos discutir os aspectos básicos para a construção de gráficos com o
pacote &lt;code&gt;ggplot2&lt;/code&gt;. Para isso, utilizaremos o banco de dados contido no objeto &lt;code&gt;mtcars&lt;/code&gt;.
Para visualizar as primeiras linhas deste banco, utilize o comando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;head(mtcars)
##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O &lt;code&gt;mtcars&lt;/code&gt; é um banco de dados de 1974 extraído da revista &lt;em&gt;Motor Trend US&lt;/em&gt; que
compreende consumo de combustível e outros 10 aspectos de performance e engenharia
de 32 automóveis.&lt;/p&gt;

&lt;p&gt;Entre as variáveis deste banco de dados estão:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mpg&lt;/code&gt;: consumo de combustível (milhas por galão)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;disp&lt;/code&gt;: cilindrada, que é o &lt;a href=&#34;https://pt.wikipedia.org/wiki/Cilindrada&#34;&gt;volume de deslocamento do motor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para saber mais sobre o &lt;code&gt;mtcarts&lt;/code&gt;, digite &lt;code&gt;help(mtcars)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;as-camadas-de-um-gráfico&#34;&gt;As camadas de um gráfico&lt;/h2&gt;

&lt;p&gt;Antes de mais nada, vamos carregar o &lt;code&gt;ggplot2&lt;/code&gt; usando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No &lt;code&gt;ggplot2&lt;/code&gt;, os gráficos são construídos camada por camada (ou, &lt;em&gt;layers&lt;/em&gt;, em inglês),
sendo que a primeira delas é dada pela função &lt;code&gt;ggplot()&lt;/code&gt; (não tem o &amp;ldquo;2&amp;rdquo;). Cada camada
representa um tipo de mapeamento ou personalização do gráfico. O código abaixo é um
exemplo de um gráfico bem simples, construído a partir das duas principais camadas.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data = mtcars) + 
  geom_point(mapping = aes(x = disp, y = mpg))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//grafico1-1.png&#34; title=&#34;plot of chunk grafico1&#34; alt=&#34;plot of chunk grafico1&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Observe que o primeiro argumento da função &lt;code&gt;ggplot&lt;/code&gt; é um data frame. A função &lt;code&gt;aes()&lt;/code&gt;
descreve como as variáveis são mapeadas em aspectos visuais de formas geométricas
definidas pelos &lt;em&gt;geoms&lt;/em&gt;. Aqui, essas formas geométricas são pontos, selecionados pela
função &lt;code&gt;geom_point()&lt;/code&gt;, gerando, assim, um gráfico de dispersão. A combinação dessas
duas camadas define o tipo de gráfico que você deseja construir.&lt;/p&gt;

&lt;h2 id=&#34;aesthetics&#34;&gt;Aesthetics&lt;/h2&gt;

&lt;p&gt;A primeira camada de um gráfico deve indicar a relação entre os dados e cada aspecto
visual do gráfico, como qual variável será representada no eixo x, qual será
representada no eixo y, a cor e o tamanho dos componentes geométricos etc. Os aspectos
que podem ou devem ser mapeados depende do tipo de gráfico que você deseja fazer.&lt;/p&gt;

&lt;p&gt;No exemplo acima, atribuímos aspectos de posição: ao eixo y mapeamos a variável &lt;code&gt;mpg&lt;/code&gt;
(milhas por galão) e ao eixo x a variável &lt;code&gt;disp&lt;/code&gt; (cilindradas). Outro aspecto que pode
ser mapeado nesse gráfico é a cor dos pontos&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data = mtcars) + 
  geom_point(mapping = aes(x = disp, y = mpg, colour = as.factor(am)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//mapear_am-1.png&#34; title=&#34;plot of chunk mapear_am&#34; alt=&#34;plot of chunk mapear_am&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora, a variável &lt;code&gt;am&lt;/code&gt; (tipo de transmissão) foi mapeada à cor dos pontos, sendo que pontos vermelhos correspondem à transmissão automática (valor 0) e pontos azuis à transmissão manual (valor 1). Observe que inserimos a variável &lt;code&gt;am&lt;/code&gt; como um fator, pois temos interesse apenas nos valores &amp;ldquo;0&amp;rdquo; e &amp;ldquo;1&amp;rdquo;. No entanto, também podemos mapear uma variável contínua à cor dos pontos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) + 
  geom_point(mapping = aes(x = disp, y = mpg, colour = cyl))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//mapear_cor-1.png&#34; title=&#34;plot of chunk mapear_cor&#34; alt=&#34;plot of chunk mapear_cor&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Aqui, o número de cilindros, &lt;code&gt;cyl&lt;/code&gt;, é representado pela tonalidade da cor azul.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nota&lt;/strong&gt;: por &lt;em&gt;default&lt;/em&gt;, a legenda é insirida no gráfico automaticamente.&lt;/p&gt;

&lt;p&gt;Também podemos mapear o tamanho dos pontos a uma variável de interesse:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) +
  geom_point(mapping = aes(x = disp, y = mpg, colour = cyl, size = wt))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//mapear_tamanaho-1.png&#34; title=&#34;plot of chunk mapear_tamanaho&#34; alt=&#34;plot of chunk mapear_tamanaho&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exercício&lt;/strong&gt;: pesquisar mais aspectos que podem ser alterados no gráfico de dispersão. &lt;a href=&#34;http://ggplot2.tidyverse.org/articles/ggplot2-specs.html&#34;&gt;Essa&lt;/a&gt; é uma
boa referência.&lt;/p&gt;

&lt;h2 id=&#34;geoms&#34;&gt;Geoms&lt;/h2&gt;

&lt;p&gt;Os &lt;em&gt;geoms&lt;/em&gt; definem qual forma geométrica será utilizada para a visualização dos
dados no gráfico. Como já vimos, a função &lt;code&gt;geom_point()&lt;/code&gt; gera gráficos de dispersão
transformando pares (x,y) em pontos. Veja a seguir outros &lt;em&gt;geoms&lt;/em&gt; bastante utilizados:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;geom_line&lt;/code&gt; - para linhas definidas por pares (x,y)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_abline&lt;/code&gt; - para retas definidas por um intercepto e uma inclinação&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_hline&lt;/code&gt; - para retas horizontais&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_boxplot&lt;/code&gt; - para boxplots&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_histogram&lt;/code&gt; - para histogramas&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_density&lt;/code&gt; - para densidades&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_area&lt;/code&gt; - para áreas&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_bar&lt;/code&gt; - para barras&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Veja a seguir como é fácil gerar diversos gráficos diferentes utilizando a mesma estrutura do gráfico de dispersão acima:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) + 
  geom_boxplot(aes(x = as.factor(cyl), y = mpg))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-7-1.png&#34; title=&#34;plot of chunk unnamed-chunk-7&#34; alt=&#34;plot of chunk unnamed-chunk-7&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; que para fazer um boxplot para cada grupo, precisamos passar para o aspecto
x do gráfico uma variável do tipo &lt;code&gt;factor&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) + 
  geom_histogram(aes(x = mpg))
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-8-1.png&#34; title=&#34;plot of chunk unnamed-chunk-8&#34; alt=&#34;plot of chunk unnamed-chunk-8&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) + 
  geom_bar(aes(x = as.factor(cyl)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-9-1.png&#34; title=&#34;plot of chunk unnamed-chunk-9&#34; alt=&#34;plot of chunk unnamed-chunk-9&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Um padrão para os gráficos
&lt;/p&gt;
&lt;p&gt;
Você deve ter percebido que, para fazer um gráfico usando `ggplot2` e a gramática
dos gráficos, existe um padrão:
&lt;br&gt; 
&lt;br&gt;
ggplot(data = DATA) + GEOM_FUNCTION(mapping = aes(MAPPINGS))
&lt;br&gt;
&lt;br&gt;
Para fazer um gráfico, basta substituir DATA por um banco de dados, GEOM_FUNCTION por
uma função geométrica e MAPPINGS por uma coleção de &lt;b&gt;mapas estéticos&lt;/b&gt;. Isso será muito útil quando você for fazer o seu próprio gráfico.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;exercícios&#34;&gt;Exercícios&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Rode &lt;code&gt;ggplot(data = mtcars)&lt;/code&gt;. O que você vê?&lt;/li&gt;
&lt;li&gt;Quantas linhas existem no &lt;code&gt;mtcars&lt;/code&gt;. Quantas colunas? &lt;strong&gt;Dica&lt;/strong&gt;: use a função &lt;code&gt;nrows&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;O que a variável &lt;code&gt;qsec&lt;/code&gt; descreve. Leia o help do &lt;code&gt;mtcars&lt;/code&gt; para encontrar.&lt;/li&gt;
&lt;li&gt;Faça um gráfico de dispersão de &lt;code&gt;mpg&lt;/code&gt; por &lt;code&gt;qsec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;O que acontece se você fizer um gráfico de dispersão de &lt;code&gt;vs&lt;/code&gt; por &lt;code&gt;mpg&lt;/code&gt;? Porque o
gráfico não é útil?&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;combinando-gráficos&#34;&gt;Combinando gráficos&lt;/h2&gt;

&lt;p&gt;Considere os 2 gráficos a seguir.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# esquerda
ggplot(mtcars) + 
  geom_point(aes(y = mpg, x = disp))
# direita
ggplot(mtcars) + 
  geom_smooth(aes(y = mpg, x = disp))
## `geom_smooth()` using method = &#39;loess&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//duplochunk-1.png&#34; title=&#34;plot of chunk duplochunk&#34; alt=&#34;plot of chunk duplochunk&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;img src=&#34;figures//duplochunk-2.png&#34; title=&#34;plot of chunk duplochunk&#34; alt=&#34;plot of chunk duplochunk&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Os gráficos são similares e completaam-se. O da esquerda, mostra como os pontos estão distribuídos. Ele mostra uma tendência de aumento do consumo de combustível de acordo
com as cilindradas. Já o gráfico da direita resume essa relação. Simplificando-a para uma linha de tendência com alguma margem de confiança.&lt;/p&gt;

&lt;p&gt;Esses dois gráficos se completam e ficam bons juntos. Com o &lt;code&gt;ggplot2&lt;/code&gt;, é muito fácil
sobrepor os dois gráficos, pois ele é pensado para que cada gráfico seja feito com
uma combinação de camadas. Veja o código abaixo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) + 
  geom_point(aes(y = mpg, x = disp)) +
  geom_smooth(aes(y = mpg, x = disp))
## `geom_smooth()` using method = &#39;loess&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-10-1.png&#34; title=&#34;plot of chunk unnamed-chunk-10&#34; alt=&#34;plot of chunk unnamed-chunk-10&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Desta forma, sobrepusemos os pontos e a linha de suavização. No entanto, duplicamos alguns trechos no nosso código, o que geralmente não é bom. Imagine se você precisar
mudar a variável do eixo &lt;code&gt;y&lt;/code&gt;, você precisará trocar o nome da variável em mais de um
lugar do código. Para resolver isso, você pode definir o &lt;em&gt;mapping&lt;/em&gt; apenas uma vez
dentro da declaração do gráfico, conforme o código a seguir.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp)) + 
  geom_point() +
  geom_smooth()
## `geom_smooth()` using method = &#39;loess&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-11-1.png&#34; title=&#34;plot of chunk unnamed-chunk-11&#34; alt=&#34;plot of chunk unnamed-chunk-11&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Veja que isso gera o mesmo gráfico!&lt;/p&gt;

&lt;p&gt;Veja que mesmo com dois &lt;code&gt;geom&lt;/code&gt;&amp;rsquo;s, o &lt;code&gt;ggplot&lt;/code&gt; segue a mesma regra para mapear as
variáveis para as &lt;code&gt;aesthetics&lt;/code&gt;. Por exemplo, se você mapear uma variável para
a cor, você obterá o seguinte gráfico.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp, colour = as.factor(cyl))) + 
  geom_point() +
  geom_smooth(method = &amp;quot;lm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-12-1.png&#34; title=&#34;plot of chunk unnamed-chunk-12&#34; alt=&#34;plot of chunk unnamed-chunk-12&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O &lt;code&gt;ggplot2&lt;/code&gt; agora desenhou uma reta para cada um dos grupos de pontos e coloriu
cada grupo de pontos de uma cor diferente. Em alguns casos, você pode querer mapear
a cor em apenas uma das camadas do gráfico. Isso pode ser feito da seguinte forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp)) + 
  geom_point(aes(colour = as.factor(cyl))) +
  geom_smooth(method = &amp;quot;lm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-13-1.png&#34; title=&#34;plot of chunk unnamed-chunk-13&#34; alt=&#34;plot of chunk unnamed-chunk-13&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora, cada grupo de pontos tem uma cor, mas a reta é única para todos os pontos.&lt;/p&gt;

&lt;h2 id=&#34;alterando-os-padrões-do-gráfico&#34;&gt;Alterando os padrões do gráfico&lt;/h2&gt;

&lt;p&gt;Até agora, sempre &lt;em&gt;mapeamos&lt;/em&gt; uma forma estética à uma variável. Muitas vezes
queremos apenas modificar esta forma estética sem mapeá-la a outra variável.
Por exemplo, no gráfico a seguir, modificamos a cor de todos os pontos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp)) + 
  geom_point(colour = &amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-14-1.png&#34; title=&#34;plot of chunk unnamed-chunk-14&#34; alt=&#34;plot of chunk unnamed-chunk-14&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A principal diferença aqui é que especificamos o argumento &lt;code&gt;colour&lt;/code&gt; fora da função
&lt;code&gt;aes&lt;/code&gt;. Dessa forma, podemos controlar todos os parâmetros
de cada forma geométrica.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp)) + 
  geom_point(colour = &amp;quot;red&amp;quot;, size = 2, shape = 3, alpha = 0.5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-15-1.png&#34; title=&#34;plot of chunk unnamed-chunk-15&#34; alt=&#34;plot of chunk unnamed-chunk-15&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;facets&#34;&gt;Facets&lt;/h2&gt;

&lt;p&gt;Uma funcionalidade muito útil do &lt;code&gt;ggplot2&lt;/code&gt; é a possibilidade de usar &lt;code&gt;facets&lt;/code&gt;.
Isso auxilia na visualização de diferentes subconjuntos dos dados em gráficos
separados, permitindo a visualização de comportamentos diferentes dependendo
do grupo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp)) + 
  geom_point() +
  geom_smooth(method = &amp;quot;lm&amp;quot;) + 
  facet_wrap(~am)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-16-1.png&#34; title=&#34;plot of chunk unnamed-chunk-16&#34; alt=&#34;plot of chunk unnamed-chunk-16&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;No gráfico acima, rapidamente conseguimos visualizar que se o carro não é automático o consumo de combustível é muito menor do que quando o carro é automático. Também conseguimos ver que a inclinação das retas é bem diferente dependendo do carro ser
automático/manual.&lt;/p&gt;

&lt;h3 id=&#34;exercício&#34;&gt;&lt;strong&gt;Exercício&lt;/strong&gt;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = &amp;quot;blue&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-19-1.png&#34; title=&#34;plot of chunk unnamed-chunk-19&#34; alt=&#34;plot of chunk unnamed-chunk-19&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mapeie uma variável contínua para uma cor, tamanho e forma. Como essas formas
estéticas se comportam diferente para variáveis categóricas vs. contínuas?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Começando de um simples boxplot feito no &lt;code&gt;ggplot2&lt;/code&gt; vamos fazer diversas alterações nas legendas. O gráfico inicial é construido da seguinte forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
# boxplot simples
bp &amp;lt;- ggplot(data=PlantGrowth, aes(x=group, y=weight, fill=group)) + geom_boxplot()
bp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-21-1.png&#34; title=&#34;plot of chunk unnamed-chunk-21&#34; alt=&#34;plot of chunk unnamed-chunk-21&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;removendo-totalmente-a-legenda&#34;&gt;Removendo totalmente a legenda&lt;/h2&gt;

&lt;p&gt;Existem diversas maneiras para remover a legenda de um gráfico no &lt;code&gt;ggplot2&lt;/code&gt;. A forma mais simples é usar &lt;code&gt;guides(fill = FALSE)&lt;/code&gt; com &lt;code&gt;fill&lt;/code&gt; sendo o atributo gráfico do qual você deseja remover a legenda.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# aqui definimos fill = FALSE, porque é o atributo do gráfico que relacionamos 
# a alguma variável.
bp + guides(fill = FALSE)

# também é possível remover a legenda por meio da escala de cores
# aqui também usamos o scale_fill_discrete, porque associamos fill
# a uma variável anteriormente.
bp + scale_fill_discrete(guide = F)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-22-1.png&#34; title=&#34;plot of chunk unnamed-chunk-22&#34; alt=&#34;plot of chunk unnamed-chunk-22&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;img src=&#34;figures//unnamed-chunk-22-2.png&#34; title=&#34;plot of chunk unnamed-chunk-22&#34; alt=&#34;plot of chunk unnamed-chunk-22&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# o comando a seguir remove todas as legendas, não importa o atributo que ela
# esteja representando.
bp + theme(legend.position=&amp;quot;none&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-23-1.png&#34; title=&#34;plot of chunk unnamed-chunk-23&#34; alt=&#34;plot of chunk unnamed-chunk-23&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;alterando-a-ordem-dos-itens&#34;&gt;Alterando a ordem dos itens&lt;/h2&gt;

&lt;p&gt;Para alterar a ordem dos itens na legenda do gráfico no &lt;code&gt;ggplot2&lt;/code&gt;, usamos o comando da escala de cores.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bp + scale_fill_discrete(breaks=c(&amp;quot;trt1&amp;quot;,&amp;quot;ctrl&amp;quot;,&amp;quot;trt2&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-24-1.png&#34; title=&#34;plot of chunk unnamed-chunk-24&#34; alt=&#34;plot of chunk unnamed-chunk-24&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-24-2.png&#34; title=&#34;plot of chunk unnamed-chunk-24&#34; alt=&#34;plot of chunk unnamed-chunk-24&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Dependendo dos aspectos gráficos (cores, formatos, preenchimentos) especificados, você pode precisar usar alguma das seguintes funções: &lt;code&gt;scale_fill_manual&lt;/code&gt;, &lt;code&gt;scale_colour_hue&lt;/code&gt;, &lt;code&gt;scale_colour_manual&lt;/code&gt;, &lt;code&gt;scale_shape_discrete&lt;/code&gt;, &lt;code&gt;scale_linetype_discrete&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Você pode também querer inverter a ordem dos itens da legenda. Isso pode ser feito de uma das seguintes maneiras.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bp + guides(fill = guide_legend(reverse=TRUE))
bp + scale_fill_discrete(guide = guide_legend(reverse=TRUE))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-25-1.png&#34; title=&#34;plot of chunk unnamed-chunk-25&#34; alt=&#34;plot of chunk unnamed-chunk-25&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;img src=&#34;figures//unnamed-chunk-25-2.png&#34; title=&#34;plot of chunk unnamed-chunk-25&#34; alt=&#34;plot of chunk unnamed-chunk-25&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;removendo-os-títulos-da-legenda&#34;&gt;Removendo os títulos da legenda&lt;/h2&gt;

&lt;p&gt;Algumas vezes é necessário remover o título das legendas do gráfico feito no &lt;code&gt;ggplot2&lt;/code&gt;.
Veja a seguir algumas maneiras:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Remove o título apenas da legenda do preenchimento (fill)
bp + guides(fill=guide_legend(title=NULL))

# Remove o título de todas as legendas
bp + theme(legend.title=element_blank())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-26-1.png&#34; title=&#34;plot of chunk unnamed-chunk-26&#34; alt=&#34;plot of chunk unnamed-chunk-26&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;img src=&#34;figures//unnamed-chunk-26-2.png&#34; title=&#34;plot of chunk unnamed-chunk-26&#34; alt=&#34;plot of chunk unnamed-chunk-26&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;modificando-texto-cores-e-rótulos&#34;&gt;Modificando texto, cores e rótulos&lt;/h2&gt;

&lt;p&gt;Existem duas formas para modificar os textos e rótulos das legendas. Uma delas é modificar o &lt;code&gt;data.frame&lt;/code&gt; de forma com que os fatores tenham o mesmo nome que você deseja na legenda. Outra forma é usando as funções de &lt;code&gt;scale&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Veja algumas modificações que podem ser feitas por meio das funções de &lt;code&gt;scale&lt;/code&gt;. Como a variável &lt;code&gt;group&lt;/code&gt; está associada ao atributo &lt;code&gt;fill&lt;/code&gt;, usamos as funções &lt;code&gt;scale_fill_xxx&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# usamos scale_fill_discrete porque não queremos alterar as cores padrão,
# mas queremos que cada fator esteja associado a uma cor de tom diferente.
# mudamos aqui os rótulos e o título da legenda.
bp + scale_fill_discrete(name=&amp;quot;Experimental\nCondition&amp;quot;,
                         breaks=c(&amp;quot;ctrl&amp;quot;, &amp;quot;trt1&amp;quot;, &amp;quot;trt2&amp;quot;),
                         labels=c(&amp;quot;Control&amp;quot;, &amp;quot;Treatment 1&amp;quot;, &amp;quot;Treatment 2&amp;quot;))


# usamos scale_fill_manual porque queremos alterar as cores padrão.
# aqui escolhemos as cores da escala hexadecimal.
bp + scale_fill_manual(values=c(&amp;quot;#999999&amp;quot;, &amp;quot;#E69F00&amp;quot;, &amp;quot;#56B4E9&amp;quot;), 
                       name=&amp;quot;Experimental\nCondition&amp;quot;,
                       breaks=c(&amp;quot;ctrl&amp;quot;, &amp;quot;trt1&amp;quot;, &amp;quot;trt2&amp;quot;),
                       labels=c(&amp;quot;Control&amp;quot;, &amp;quot;Treatment 1&amp;quot;, &amp;quot;Treatment 2&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-27-1.png&#34; title=&#34;plot of chunk unnamed-chunk-27&#34; alt=&#34;plot of chunk unnamed-chunk-27&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;img src=&#34;figures//unnamed-chunk-27-2.png&#34; title=&#34;plot of chunk unnamed-chunk-27&#34; alt=&#34;plot of chunk unnamed-chunk-27&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Veja que isso não aletrou o eixo X do gráfico.&lt;/p&gt;

&lt;h2 id=&#34;modificando-a-aparência-da-legenda&#34;&gt;Modificando a aparência da legenda&lt;/h2&gt;

&lt;p&gt;Existem inúmeras modificações que podem ser realizadas na aparência da legenda. Todas elas estão relacionadas à modificação do &lt;code&gt;element_text&lt;/code&gt;. Veja neste &lt;a href=&#34;http://docs.ggplot2.org/0.9.2.1/element_text.html&#34;&gt;link&lt;/a&gt; todos os atributos que podem ser modificados.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Mudando a aparência do título
bp + theme(legend.title = element_text(colour=&amp;quot;blue&amp;quot;, size=16, face=&amp;quot;bold&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-28-1.png&#34; title=&#34;plot of chunk unnamed-chunk-28&#34; alt=&#34;plot of chunk unnamed-chunk-28&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Mudando a aparência dos rótulos
bp + theme(legend.text = element_text(colour=&amp;quot;blue&amp;quot;, size = 16, face = &amp;quot;bold&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-29-1.png&#34; title=&#34;plot of chunk unnamed-chunk-29&#34; alt=&#34;plot of chunk unnamed-chunk-29&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;modificando-a-posição-da-legenda&#34;&gt;Modificando a posição da legenda&lt;/h2&gt;

&lt;p&gt;É possível controlar a posição da legenda facilmente escolhendo uma das posições (left/right/top/bottom).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bp + theme(legend.position=&amp;quot;top&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-30-1.png&#34; title=&#34;plot of chunk unnamed-chunk-30&#34; alt=&#34;plot of chunk unnamed-chunk-30&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Também é possível controlar a posição da legenda de forma precisa usando a função &lt;code&gt;theme()&lt;/code&gt;. A legenda será posicionada dentro do gráfico com o ponto central sendo o valor do argumento &lt;code&gt;legend.position&lt;/code&gt;. Esses valores são definidos de forma que o ponto (0,0) seja o canto inferior esquerdo e (1,1) seja o canto superior direito.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bp + theme(legend.position=c(.5, .5))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-31-1.png&#34; title=&#34;plot of chunk unnamed-chunk-31&#34; alt=&#34;plot of chunk unnamed-chunk-31&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introdução</title>
      <link>/forcats/</link>
      <pubDate>Fri, 03 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/forcats/</guid>
      <description>

&lt;h2 id=&#34;introdução&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Se você já utilizou R anteriormente, provavelmente já escreveu a expressão &lt;code&gt;stringsAsFactors = F&lt;/code&gt; quando importava dados usando as funções &lt;code&gt;read.csv&lt;/code&gt; ou &lt;code&gt;read.table&lt;/code&gt;. É muito frustrante quando uma coluna de &lt;code&gt;strings&lt;/code&gt; é lida como um fator, pois fatores não podem ser manipulados do mesmo jeito que manipulamos vetores de &lt;code&gt;strings&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Felizmente, depois de aprender a usar o &lt;code&gt;tidyverse&lt;/code&gt; você não terá mais esse problema, pois o pacote &lt;code&gt;readr&lt;/code&gt; não lê colunas de caracteres como fatores por padrão. Mas isso não significa que fatores são inúteis. Eles representam uma forma muito prática de lidar com variáveis categorizadas, tanto para fins de modelagem quanto para fins de visualização.&lt;/p&gt;

&lt;p&gt;Grande parte da frustração associada ao uso de fatores no R existe por conta da falta de algumas ferramentas úteis no pacote &lt;code&gt;base&lt;/code&gt;. Para resolver esse o problema, Hadley Wickham ajudou a comunidade R (de novo) desenvolvendo o pacote &lt;code&gt;forcats&lt;/code&gt;(&lt;strong&gt;for&lt;/strong&gt; &lt;strong&gt;cat&lt;/strong&gt;egorial variable&lt;strong&gt;s&lt;/strong&gt;), que implementa algumas dessas ferramentas.&lt;/p&gt;

&lt;p&gt;As principais funções do &lt;code&gt;forcats&lt;/code&gt; servem para alterar a &lt;strong&gt;ordem&lt;/strong&gt; e modificar os &lt;strong&gt;níveis&lt;/strong&gt; de um fator. Para exemplificar a utilidade dessas funções, neste Power Up vamos utilizá-las em situações corriqueiras.&lt;/p&gt;

&lt;h1 id=&#34;relembrando-o-que-são-fatores&#34;&gt;Relembrando: o que são fatores?&lt;/h1&gt;

&lt;p&gt;No R, fatores são estruturas de dados utilizadas para ordenar &lt;code&gt;strings&lt;/code&gt;. Formalmente, um fator é definido como um vetor de &lt;code&gt;integers&lt;/code&gt; com dois atributos específicos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;levels&lt;/code&gt;: m vetor de &lt;code&gt;strings&lt;/code&gt; que indica a relação de ordem entre as variáveis.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt;: a &lt;code&gt;string&lt;/code&gt; atômica &lt;code&gt;&amp;quot;factor&amp;quot;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Em modelos estatísticos clássicos, como ANOVA, é útil e adequado interpretar um vetor de textos como um vetor de números inteiros. O nome &amp;ldquo;fator&amp;rdquo;, inclusive, foi definido fazendo alusão à literatura estatística.&lt;/p&gt;

&lt;h1 id=&#34;para-que-fatores-servem&#34;&gt;Para que fatores servem?&lt;/h1&gt;

&lt;p&gt;Fatores são úteis porque facilitam a ordenação de vetores de texto, principalmente quando estamos fazendo gráficos. Nesta seção, vamos exemplificar essa facilidade com um exemplo.&lt;/p&gt;

&lt;p&gt;Considere que temos interesse em construir um gráfico que ilustre a diminuição da pressão sanguinea de um conjunto de indivíduos em função do restaurante em que acabaram de jantar. Para realizar esta tarefa, fomos à praça de alimentação de um shopping e anotamos as pressões arteriais de 10 voluntários conforme eles terminavam suas refeições nos restarantes Max Donalds, Frutaria da vila e Outlet.&lt;/p&gt;

&lt;p&gt;O resultado das nossas medições está descrito na tabela abaixo.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;voluntario&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;restaurante&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;pressao&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Frutaria da vila&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.56&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Max Donalds&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.71&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Outlet&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.44&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Outlet&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.62&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Max Donalds&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.00&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Outlet&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.62&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Frutaria da vila&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Max Donalds&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.88&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Outlet&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.62&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Frutaria da vila&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.50&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Utilizando esses dados, o gráfico desejado fica:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
d %&amp;gt;% 
ggplot(aes(x = restaurante, y = pressao)) +
  geom_point() + 
  theme_bw(15)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-7-1.png&#34; title=&#34;plot of chunk unnamed-chunk-7&#34; alt=&#34;plot of chunk unnamed-chunk-7&#34; width=&#34;60%&#34; height=&#34;60%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O gráfico mostra o que desejávamos, mas podemos incluir outras informações no gráfico. Se soubéssemos a priori que o Max Donalds oferece uma refeição muito mais calórica do que o Outlet, gostaríamos de atribuir essa ordem ao nosso eixo x. Como poderíamos fazer isso? Usando fatores!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
d %&amp;gt;% 
mutate(restaurante = factor(restaurante, levels = c(&amp;quot;Frutaria da vila&amp;quot;, &amp;quot;Outlet&amp;quot;, &amp;quot;Max Donalds&amp;quot;))) %&amp;gt;% 
ggplot(aes(x = restaurante, y = pressao)) +
  geom_point() + 
  theme_bw(15)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-8-1.png&#34; title=&#34;plot of chunk unnamed-chunk-8&#34; alt=&#34;plot of chunk unnamed-chunk-8&#34; width=&#34;60%&#34; height=&#34;60%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;estrutura-básica&#34;&gt;Estrutura básica&lt;/h2&gt;

&lt;p&gt;O &lt;code&gt;forcats&lt;/code&gt; é um pacote bastante simples. Ele é composto por funções de apenas dois tipos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Funções que começam com &lt;code&gt;fct_&lt;/code&gt;, que recebem uma lista de fatores e devolvem um fator.

&lt;ul&gt;
&lt;li&gt;Exemplo: &lt;code&gt;fct_c&lt;/code&gt; recebe uma lista de fatores e devolve um fator que é a união dos anteriores.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
fator_1 &amp;lt;- factor(c(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;))
fator_2 &amp;lt;- factor(c(&amp;quot;d&amp;quot;,&amp;quot;e&amp;quot;))

fator_3_sem_sentido &amp;lt;- c(fator_1, fator_2)

fator_3_sem_sentido
## [1] 1 2 3 1 2

fator_3_com_sentido &amp;lt;- forcats::fct_c(list(fator_1, fator_2))

fator_3_com_sentido
## [1] a b c d e
## Levels: a b c d e
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Funções que começam com &lt;code&gt;lvl_&lt;/code&gt;, que modificam os níveis de um fator.

&lt;ul&gt;
&lt;li&gt;Exemplo: &lt;code&gt;lvl_revalue&lt;/code&gt; recebe um fator e um vetor de &lt;code&gt;strings&lt;/code&gt; com dimensão igual ao número de níveis do fator. Retorna o fator fornecido com o atributo &lt;code&gt;levels&lt;/code&gt; igual ao vetor de &lt;code&gt;strings&lt;/code&gt; fornecido.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
fator &amp;lt;- factor(c(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;))

novos_niveis &amp;lt;- c(&amp;quot;c&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;)
  
fator &amp;lt;- forcats::lvls_revalue(fator, novos_niveis)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;principais-funções&#34;&gt;Principais funções&lt;/h2&gt;

&lt;p&gt;Nesta seção, vamos estudar o funcionamento das principais funções do &lt;code&gt;forcats&lt;/code&gt; utilizando como motivação a visualização dos dados de uma base analisada pela Associação Brasileira de Jurimetria. A base foi simplificada para otimizar seu uso neste curso. Além disso, os dados passaram por um processo de anonimização, pois os resultados ainda não foram divulgados.&lt;/p&gt;

&lt;p&gt;A base contém informações sobre uma amostra de vítimas de homicídios no município de São Paulo e é composta pelas seguintes variáveis:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;instrumento.usado&lt;/code&gt;: instrumento usado pelo crime.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sexo.vítima&lt;/code&gt;: sexo da vítima.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idade.vítima&lt;/code&gt;: idade da vítima.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;modificar-níveis-de-fatores&#34;&gt;Modificar níveis de fatores&lt;/h1&gt;

&lt;p&gt;A tabela abaixo ilustra a distribuição dos valores da variável &lt;code&gt;instrumento.usado&lt;/code&gt;.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;instrumento.usado&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Frequência&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Arma de fogo&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;30&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Faca&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;17&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Fio elétrico (vítima foi estrangulada)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Fogo&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Nenhum&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Revólver&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Veículo&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;38&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Fio elétrico&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Pistola&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Como existe uma grande variabilidade de instrumentos, vamos reclassificar a variável &lt;code&gt;instrumento.usado&lt;/code&gt; em um fator com níveis menos gerais.&lt;/p&gt;

&lt;p&gt;Para realizar essa tarefa, vamos utilizar a função &lt;code&gt;fct_collapse&lt;/code&gt; e a função &lt;code&gt;fct_lump&lt;/code&gt;. A função &lt;code&gt;fct_collapse&lt;/code&gt; é uma generalização de uma outra função chamada &lt;code&gt;fct_recode&lt;/code&gt;. A função &lt;code&gt;fct_collapse&lt;/code&gt; recebe um fator e uma série nomeada de vetores de &lt;code&gt;strings&lt;/code&gt;,  enquanto a função &lt;code&gt;fct_recode&lt;/code&gt; recebe um fator e uma série de &lt;code&gt;strings&lt;/code&gt; nomeadas. Já a função &lt;code&gt;fct_lump&lt;/code&gt; transforma os níveis menos frequentes de um fator em um nível &amp;ldquo;Outros&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Abaixo exemplificamos a utilização das três funções mencionadas no parágrafo anterior:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
fator &amp;lt;- factor(c(&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;))

fct_collapse(fator, b2 = c(&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;), a2 = c(&amp;quot;a&amp;quot;, &amp;quot;d&amp;quot;))
## [1] a2 a2 a2 b2 b2 b2 a2 e 
## Levels: a2 b2 e
fct_recode(fator, b2 = &amp;quot;b&amp;quot;, b2 = &amp;quot;c&amp;quot;, a2 = &amp;quot;a&amp;quot;, a2 = &amp;quot;d&amp;quot;)
## [1] a2 a2 a2 b2 b2 b2 a2 e 
## Levels: a2 b2 e

fct_lump(fator, 2, other_level = &amp;quot;Outros&amp;quot;)
## [1] a      a      a      b      b      Outros Outros Outros
## Levels: a b Outros
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voltando à nossa aplicação, vamos utilizar a função &lt;code&gt;fct_collapse&lt;/code&gt; para recodificar a variável &lt;code&gt;instrumento.usado&lt;/code&gt;. Após essa reclassificação, os níveis com poucas contagens serão convertidos em &amp;ldquo;Outros&amp;rdquo; por meio da função &lt;code&gt;fct_lump&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
bd_enasp_abj &amp;lt;- bd_enasp_abj %&amp;gt;% 
  mutate(instrumento.usado = fct_collapse(instrumento.usado,
    `Arma branca` = c(&amp;quot;Faca&amp;quot;, &amp;quot;Fio elétrico&amp;quot;, &amp;quot;Fio elétrico (vítima foi estrangulada)&amp;quot;, &amp;quot;Fogo&amp;quot;),
    `Arma de Fogo` = c(&amp;quot;Pistola&amp;quot;, &amp;quot;Revólver&amp;quot;, &amp;quot;Arma de fogo&amp;quot;,&amp;quot;38&amp;quot;)),
    instrumento.usado = fct_lump(instrumento.usado, 2, other_level = &amp;quot;Outros&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Após a reclassificação a distribuição fica:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
bd_enasp_abj %&amp;gt;% 
  count(instrumento.usado) %&amp;gt;% 
  knitr::kable()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;instrumento.usado&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;n&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Arma de Fogo&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;34&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Arma branca&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;22&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Outros&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;reordenar-níveis-de-fatores&#34;&gt;Reordenar níveis de fatores&lt;/h1&gt;

&lt;p&gt;Vamos visualizar a tabela anterior como um gráfico.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-15-1.png&#34; title=&#34;plot of chunk unnamed-chunk-15&#34; alt=&#34;plot of chunk unnamed-chunk-15&#34; width=&#34;60%&#34; height=&#34;60%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A ordem das barras nesse gráfico não está muito intuitiva, pois uma arma de fogo é um instrumento de crime mais perigoso do que uma arma branca, mas o eixo das abscissas não transmite essa informação.&lt;/p&gt;

&lt;p&gt;Alterar a relação de ordem entre os níveis de um fator pode ser feito de duas maneiras:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Alterando diretamente o atributo &lt;code&gt;levels&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Criando o fator novamente.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
bd_teste &amp;lt;- bd_enasp_abj

levels(bd_teste$instrumento.usado) &amp;lt;- c(&amp;quot;Outros&amp;quot;, &amp;quot;Arma branca&amp;quot;, &amp;quot;Arma de Fogo&amp;quot;)

bd_teste %&amp;gt;% 
  ggplot(aes(x = instrumento.usado, fill = instrumento.usado)) + 
  geom_bar() +
  theme_bw(15) +
  xlab(&amp;quot;Intrumento usado&amp;quot;) + 
  ylab(&amp;quot;Frequência&amp;quot;) + 
  theme(legend.position = &#39;none&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-16-1.png&#34; title=&#34;plot of chunk unnamed-chunk-16&#34; alt=&#34;plot of chunk unnamed-chunk-16&#34; width=&#34;60%&#34; height=&#34;60%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Mudar diretamente os níveis também mudou as labels impressas! Mesmo que os níveis do novo fator &lt;code&gt;bd_teste$instrumento.usado&lt;/code&gt; estejam na ordem correta, os rótulos também foram alterados.&lt;/p&gt;

&lt;p&gt;O problema da reordenação pode ser resolvido conforme ilustrado no código abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
bd_teste &amp;lt;- bd_enasp_abj

novos_niveis &amp;lt;- c(&amp;quot;Outros&amp;quot;, &amp;quot;Arma branca&amp;quot;, &amp;quot;Arma de Fogo&amp;quot;)

bd_teste$instrumento.usado &amp;lt;- factor(bd_teste$instrumento.usado, novos_niveis)

bd_teste %&amp;gt;% 
  ggplot(aes(x = instrumento.usado, fill = instrumento.usado)) + 
  geom_bar() +
  theme_bw(15) +
  xlab(&amp;quot;Intrumento usado&amp;quot;) + 
  ylab(&amp;quot;Frequência&amp;quot;) + 
  theme(legend.position = &#39;none&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-17-1.png&#34; title=&#34;plot of chunk unnamed-chunk-17&#34; alt=&#34;plot of chunk unnamed-chunk-17&#34; width=&#34;60%&#34; height=&#34;60%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;No &lt;code&gt;forcats&lt;/code&gt;, a reordenação equivalente a criar o fator novamente pode ser feita de três maneiras:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lvl_reorder&lt;/code&gt;, que reordena os níveis de um fator de acordo com um conjunto de índices. Recomenda-se o uso dessa função quando se quer reordenar os níveis de uma maneira facilmente parametrizável, como uma permutação dos índices dos níveis. Um exemplo comum é trocar a ordem dos níveis de crescente para decrescente.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
fator &amp;lt;- factor(letters)

#altera a ordem dos fatores de crescente para decrescente
lvls_reorder(fator, length(letters):1)
##  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z
## Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fct_reorder&lt;/code&gt; e &lt;code&gt;fct_reorder2&lt;/code&gt;, que reordenam os níveis de um fator &lt;code&gt;f&lt;/code&gt; de acordo com a aplicação de uma função em um vetor (ou dois no caso de &lt;code&gt;fct_reorder2&lt;/code&gt;) agrupado por &lt;code&gt;f&lt;/code&gt;. Recomenda-se o uso dessa função quando se quer reordenar os níveis considerando os valores de uma outra variável ou resultado de um cálculo.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
fator &amp;lt;- factor(c(&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;))
vetor &amp;lt;- c(1,2,3,1,1,1.2)

#ordena os níveis de acordo com a média da variável vetor em cada nível
fct_reorder(fator, vetor, fun = mean)
## [1] a a a b b c
## Levels: b c a
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fct_relevel&lt;/code&gt;, que &amp;ldquo;puxa&amp;rdquo; os níveis de um fator para o começo do vetor de níveis.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
fator &amp;lt;- factor(c(&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;))

#&amp;quot;puxa&amp;quot; os níveis &amp;quot;b&amp;quot; e &amp;quot;c&amp;quot; para o começo
fct_relevel(fator, &amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;)
## [1] a a a b b c
## Levels: b c a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Na nossa aplicação, podemos utilizar tanto a função &lt;code&gt;lvls_reorder&lt;/code&gt; quanto a função &lt;code&gt;fct_relevel&lt;/code&gt;. O gráfico resultante ordena os níveis de instrumento.usado como queríamos.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-21-1.png&#34; title=&#34;plot of chunk unnamed-chunk-21&#34; alt=&#34;plot of chunk unnamed-chunk-21&#34; width=&#34;60%&#34; height=&#34;60%&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;fazendo-tudo-de-uma-vez&#34;&gt;Fazendo tudo de uma vez&lt;/h1&gt;

&lt;p&gt;Nesta sessão, vamos utilizar as funções para exemplificar utilizações do pacote &lt;code&gt;forcats&lt;/code&gt; para visualizações.&lt;/p&gt;

&lt;p&gt;A visualização abaixo ordena os níveis de &amp;ldquo;instrumento.usado&amp;rdquo; de acordo com a mediana da idade das vítimas de homicídio.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bd_enasp_abj %&amp;gt;%
  mutate(instrumento.usado = fct_reorder(instrumento.usado, `idade.vítima`, fun = median)) %&amp;gt;% 
  ggplot(aes(x = instrumento.usado, y = `idade.vítima`, fill = instrumento.usado)) + 
  geom_boxplot() +
  theme_bw(15) +
  xlab(&amp;quot;Intrumento usado&amp;quot;) + 
  ylab(&amp;quot;Idade&amp;quot;) + 
  theme(legend.position = &#39;none&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-22-1.png&#34; title=&#34;plot of chunk unnamed-chunk-22&#34; alt=&#34;plot of chunk unnamed-chunk-22&#34; width=&#34;60%&#34; height=&#34;60%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A visualização abaixo exemplifica um caso em que a ordem dos facets foi invertida reordenando o fator &lt;code&gt;sexo.vítima&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bd_enasp_abj %&amp;gt;%
  mutate(instrumento.usado = fct_reorder(instrumento.usado, `idade.vítima`, fun = median),
         `sexo.vítima` = fct_recode(`sexo.vítima`, Homem = &amp;quot;M&amp;quot;, Mulher = &amp;quot;F&amp;quot;)) %&amp;gt;% 
  ggplot(aes(x = instrumento.usado, y = `idade.vítima`, fill = instrumento.usado)) + 
  geom_boxplot() +
  theme_bw(15) +
  xlab(&amp;quot;Intrumento usado&amp;quot;) + 
  ylab(&amp;quot;Idade&amp;quot;) + 
  facet_wrap(~`sexo.vítima`) +
  theme(legend.position = &#39;none&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-23-1.png&#34; title=&#34;plot of chunk unnamed-chunk-23&#34; alt=&#34;plot of chunk unnamed-chunk-23&#34; width=&#34;60%&#34; height=&#34;60%&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bd_enasp_abj %&amp;gt;%
  mutate(instrumento.usado = fct_reorder(instrumento.usado, `idade.vítima`, fun = median),
         `sexo.vítima` = fct_recode(`sexo.vítima`, Homem = &amp;quot;M&amp;quot;, Mulher = &amp;quot;F&amp;quot;),
         `sexo.vítima` = fct_relevel(`sexo.vítima`, &amp;quot;Homem&amp;quot;, &amp;quot;Mulher&amp;quot;)) %&amp;gt;% 
  ggplot(aes(x = instrumento.usado, y = `idade.vítima`, fill = instrumento.usado)) + 
  geom_boxplot() +
  theme_bw(15) +
  xlab(&amp;quot;Intrumento usado&amp;quot;) + 
  ylab(&amp;quot;Idade&amp;quot;) + 
  facet_wrap(~`sexo.vítima`) +
  theme(legend.position = &#39;none&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-24-1.png&#34; title=&#34;plot of chunk unnamed-chunk-24&#34; alt=&#34;plot of chunk unnamed-chunk-24&#34; width=&#34;60%&#34; height=&#34;60%&#34; /&gt;&lt;/p&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;ol&gt;
&lt;li&gt;Transforme o fator &lt;code&gt;f1&lt;/code&gt; no fator &lt;code&gt;f2&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIERpZ2l0ZSBvIGNcdTAwZjNkaWdvIGFxdWkiLCJzb2x1dGlvbiI6ImZjdF9yZWxldmVsKGYxLCByZXYobGV0dGVycykpIiwic2N0IjoidGVzdF9vdXRwdXRfY29udGFpbnMoXCJmMlwiLCBpbmNvcnJlY3RfbXNnID0gXCJUZW0gY2VydGV6YSBkZSBxdWUgaW5kaWNvdSBhIGV4cHJlc3NcdTAwZTNvIGNvcnJldGFtZW50ZT9cIilcbnN1Y2Nlc3NfbXNnKFwiQ29ycmV0byFcIikifQ==&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;Transforme o fator &lt;code&gt;f1&lt;/code&gt; no fator &lt;code&gt;f3&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsdmxzXy4uLiIsInNvbHV0aW9uIjoibHZsc19yZXZhbHVlKGYxLCByZXYobGV0dGVycykpIiwic2N0IjoidGVzdF9vdXRwdXRfY29udGFpbnMoXCJmM1wiLCBpbmNvcnJlY3RfbXNnID0gXCJUZW0gY2VydGV6YSBkZSBxdWUgaW5kaWNvdSBhIGV4cHJlc3NcdTAwZTNvIGNvcnJldGFtZW50ZT9cIilcbnN1Y2Nlc3NfbXNnKFwiQ29ycmV0byFcIikifQ==&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Introdução</title>
      <link>/pipe/</link>
      <pubDate>Fri, 03 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/pipe/</guid>
      <description>

&lt;h2 id=&#34;pipe&#34;&gt;Pipe &lt;code&gt;%&amp;gt;%&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;As duas linhas abaixo são equivalentes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;f(x, y)
x %&amp;gt;% f(y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O operador &lt;code&gt;%&amp;gt;%&lt;/code&gt; (&lt;em&gt;pipe&lt;/em&gt; ) usa o resultado do seu lado esquerdo como primeiro argumento da funçăo do lado direito. Ele foi uma das grandes revoluções recentes do R, tornando a leitura de códigos mais lógica, fácil e compreensível. Este operador foi introduzido por Stefan Milton Bache no pacote &lt;code&gt;magrittr&lt;/code&gt;, e já existem diversos pacotes construidos para facilitar a sua utilizaçăo.&lt;/p&gt;

&lt;p&gt;O operador &lt;code&gt;%&amp;gt;%&lt;/code&gt; pertence ao pacote &lt;code&gt;magrittr&lt;/code&gt;. Instale este pacote para utilizá-lo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&amp;quot;magrittr&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo a seguir, o operador calcula a raiz quadrada da soma dos valores de 1 a 4.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(magrittr)

x &amp;lt;- c(1, 2, 3, 4)
x %&amp;gt;% sum %&amp;gt;% sqrt
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 3.162278
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Escrever esse cálculo na forma usual ficaria da seguinte forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sqrt(sum(x))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 3.162278
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O caminho que o código &lt;code&gt;x %&amp;gt;% sum %&amp;gt;% sqrt&lt;/code&gt; seguiu foi enviar o objeto &lt;code&gt;x&lt;/code&gt; como argumento da função &lt;code&gt;sum()&lt;/code&gt; e, em seguida, enviar a saida da expressão &lt;code&gt;sum(x)&lt;/code&gt; como argumento da função &lt;code&gt;sqrt()&lt;/code&gt;. Observe que não é necessário colocar os parênteses após o nome das funções.&lt;/p&gt;

&lt;p&gt;Pela simplicidade do exemplo, a utilização do &lt;code&gt;%&amp;gt;%&lt;/code&gt; não parece trazer grandes vantagens, pois a expressão &lt;code&gt;sqrt(sum(x))&lt;/code&gt; é facilmente compreendida. No entanto, se tivermos um grande número de funções aninhadas, a utilizaçăo do &lt;code&gt;pipe&lt;/code&gt; transforma um código confuso e difícil de ser lido em algo simples e intuitivo. Como exemplo, imagine escrever uma receita de um bolo usando o R, e cada passo da receita é uma função:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;esfrie(asse(coloque(bata(acrescente(recipiente(rep(&amp;quot;farinha&amp;quot;, 2), &amp;quot;água&amp;quot;, &amp;quot;fermento&amp;quot;, &amp;quot;leite&amp;quot;, &amp;quot;óleo&amp;quot;), &amp;quot;farinha&amp;quot;, até = &amp;quot;macio&amp;quot;), duração = &amp;quot;3min&amp;quot;), lugar = &amp;quot;forma&amp;quot;, tipo = &amp;quot;grande&amp;quot;, untada = TRUE), duração = &amp;quot;50min&amp;quot;), &amp;quot;geladeira&amp;quot;, &amp;quot;20min&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tente entender o que é preciso fazer. Depois de desistir, veja como fica escrevendo com o operador &lt;code&gt;%&amp;gt;%&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;recipiente(rep(&amp;quot;farinha&amp;quot;, 2), &amp;quot;água&amp;quot;, &amp;quot;fermento&amp;quot;, &amp;quot;leite&amp;quot;, &amp;quot;óleo&amp;quot;) %&amp;gt;%
  acrescente(&amp;quot;farinha&amp;quot;, até = &amp;quot;macio&amp;quot;) %&amp;gt;%
  bata(duraço = &amp;quot;3min&amp;quot;) %&amp;gt;%
  coloque(lugar = &amp;quot;forma&amp;quot;, tipo = &amp;quot;grande&amp;quot;, untada = TRUE) %&amp;gt;%
  asse(duração = &amp;quot;50min&amp;quot;) %&amp;gt;%
  esfrie(&amp;quot;geladeira&amp;quot;, &amp;quot;20min&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora, o código realmente parece uma receita de bolo.&lt;/p&gt;

&lt;p&gt;Para mais informações sobre o &lt;code&gt;pipe&lt;/code&gt; e exemplos de utilização, visite a página &lt;a href=&#34;http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html&#34;&gt;Ceci n&amp;rsquo;est pas un pipe&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introdução</title>
      <link>/rbase/</link>
      <pubDate>Fri, 03 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/rbase/</guid>
      <description>

&lt;h2 id=&#34;introdução&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A linguagem &lt;code&gt;R&lt;/code&gt; é intuitiva. Muita coisa sai do jeito certo no chute! Para ver um exemplo disso, é interessante começar fazendo do R uma grande calculadora.&lt;/p&gt;

&lt;p&gt;Mas antes disso, vamos aprender a mexer no RStudio!&lt;/p&gt;

&lt;hr /&gt;

&lt;!-- ## Exercícios --&gt;

&lt;!-- Pratique! Será que você consegue resolver os exercícios abaixo? --&gt;

&lt;!-- 1. Calcule o número de ouro no R. --&gt;

&lt;!-- $$ \frac{1 + \sqrt{5}}{2} $$ --&gt;

&lt;!-- 2. O que dá divisão de 1 por 0 no R? E -1 por 0?  --&gt;

&lt;!-- 3. Quais as diferenças entre `NaN`, `NULL`, `NA` e `Inf`? --&gt;

&lt;!-- 4. Tente mentalmente calcular o que dá a conta `5 + 3 * 10 %/% 3 == 15` no R, sem rodar. --&gt;

&lt;!-- 5. Adicionando apenas parênteses, faça a expressão acima retornar o resultado contrário. --&gt;

&lt;!-- 6. O que acontece se você rodar: --&gt;

&lt;!-- ```{r, eval = F} --&gt;

&lt;!-- x &lt;- 4 --&gt;

&lt;!-- if(x = 4) { --&gt;

&lt;!--   &#39;isso aqui apareceu&#39; --&gt;

&lt;!-- } --&gt;

&lt;!-- x --&gt;

&lt;!-- ``` --&gt;

&lt;!-- 7. Como você faria para que o código da pergunta anterior fizesse com que `&#39;isso aqui apareceu&#39;` fosse impresso no console mas nenhum erro aparecesse? --&gt;

&lt;!-- 8.  **Difícil**: Usando `for`, `if` e `else` escreva as seguintes frases no console: --&gt;

&lt;!-- ```{r, eval=FALSE} --&gt;

&lt;!-- &gt; 1 elefante(s) incomoda(m) muita gente --&gt;

&lt;!-- &gt; 2 elefante(s) incomoda(m) incomoda(m) muito mais --&gt;

&lt;!-- &gt; 3 elefante(s) incomoda(m) muita gente --&gt;

&lt;!-- &gt; 4 elefante(s) incomoda(m) incomoda(m) incomoda(m) incomoda(m) muito mais --&gt;

&lt;!-- ``` --&gt;

&lt;!-- *Dica*: Leia o help da função `paste` e preste atenção no argumento `collapse`. --&gt;

&lt;!-- 9. Crie um vetor com o nome `x` que contenha os números `1, 20, 40, 50, 60` no R. --&gt;

&lt;!-- 10. Crie um vetor com o nome `x` de 100 números aleatórios entre 0 e 1. --&gt;

&lt;!-- 11. Calcule a média do vetor criado na questão anterior. --&gt;

&lt;!-- 12. Crie um vetor com 100 elementos. 99 deles são números aleatórios entre 0 e 1 e o último elemento tem o valor `NA`. Calcule também a média deste vetor. --&gt;

&lt;!-- *Dica*: Olhe atentamente os argumentos da função `mean`. --&gt;

&lt;!-- 13. Crie uma função que calcula a média de um vetor. Use `for` ou `while` nesta função. --&gt;

&lt;!-- 14. Crie uma função que simule um dado, ou seja, gera aleatóriamente um número inteiro entre 1 e 6. --&gt;

&lt;!-- 15. Crie uma função que simula o lançamento de `n` dados, e devolve a soma de seus resultados. --&gt;

&lt;!-- 16. **Difícil** Faça um histograma dos resultados da soma de 3 dados. Isto é, crie um vetor com 1000 resultados que aconteceram após somar 3 dados. Em seguida faça o histograma. --&gt;

&lt;!-- **Esses exercícios possuem resposta [aqui](https://curso-r.github.io/verao2017/r-como-calculadora/respostas)** --&gt;

&lt;h2 id=&#34;rstudio&#34;&gt;RStudio&lt;/h2&gt;

&lt;p&gt;O RStudio é o melhor ambiente de desenvolvimento de R disponível. Você pode &lt;a href=&#34;https://www.rstudio.com/products/rstudio/download/preview/&#34;&gt;baixá-lo aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Muitas das ferramentas são aprendidas conforme o uso, e há bons materiais sobre o Rstudio na internet (por exemplo, &lt;a href=&#34;https://csgillespie.github.io/efficientR/set-up.html#rstudio&#34;&gt;esta página&lt;/a&gt;). Uma funcionalidade importante é a criação de projetos. Uma estrutura sugerida para a organização de um projeto é:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Estrutura 1&lt;/strong&gt;. Por extensão de arquivo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nome_do_projeto/
  - .Rprofile   # códigos para rodar assim que abrir o projeto
  - R/          # Código R, organizado com a-carrega.R, b-prepara bd.R, c-vis.R, d-modela, ...
  - RData/      # Dados em formato .RData
  - csv/        # Dados em .csv
  - png/        # gráficos em PNG
  - nome_do_projeto.Rproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Estrutura 2&lt;/strong&gt;. Típico projeto de análise estatística.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;project/
  - README.Rmd   # Descrição do pacote
  - set-up.R     # Pacotes etc
  - R/           # Código R, organizado com 0-load.R, 1-tidy.R, 2-vis.R, ...
  - data/        # Dados (estruturados ou não)
  - figures/     # gráficos (pode ficar dentro de output/)
  - output/      # Relatórios em .Rmd, .tex etc
  - project.Rproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Estrutura 3&lt;/strong&gt;. Pacote do R (avançado).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;project/
  - README.md    # Descrição do pacote
  - DESCRIPTION  # Metadados estruturados do pacote e dependências
  - NAMESPACE    # importações e exportações do pacote
  - vignettes/   # Relatórios em .Rmd
  - R/           # Funções do R
  - data/        # Dados estruturados (tidy data)
  - data-raw/    # Dados não estruturados e arqs 0-load.R, 1-tidy.R, 2-vis.R, ...
  - project.Rproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ao abrir o RStudio, você verá 4 quadrantes. Observe a figura abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;figures/rstudio-editor.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Esses quadrantes representam o &lt;strong&gt;editor&lt;/strong&gt;, o &lt;strong&gt;console&lt;/strong&gt;, o &lt;strong&gt;environment&lt;/strong&gt; e o &lt;strong&gt;output&lt;/strong&gt;.  Eles vêm nesta ordem, e depois você pode organizá-los da forma que preferir. O R vive no quadrante &lt;strong&gt;console&lt;/strong&gt;!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;rmarkdown&#34;&gt;RMarkdown&lt;/h2&gt;

&lt;p&gt;O RMarkdown é um tipo de documento especial que contém tanto textos quanto códigos de R, tudo escrito em um mesmo lugar.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;markdown&lt;/em&gt; nada mais é do que um documento de texto com alguns padrões básicos de formatação, como negrito, itálico, títulos, subtítulos, itens e referências cruzadas. Já os &lt;em&gt;chunks&lt;/em&gt; são pedaços de códigos em R encapsulados por três crases (```). Os códigos são executados sempre que o documento é processado.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## ```{r}
## 
## isto é um chunk. 
## ```
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Nota
&lt;/p&gt;
&lt;p&gt;
Este site foi escrito em RMarkdown. Toda vez que aparecer exemplos de código de R é porque havia um chunk no .Rmd original.
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Para produção de relatórios, o RMarkdown possui algumas vantagens, como:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Simplicidade e foco&lt;/strong&gt;. Permite ao usuário o foco na análise e não na formatação do documento.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Versátil&lt;/strong&gt;. Pode ser utilizado para gerar documentos em $\LaTeX$, &lt;code&gt;Word&lt;/code&gt;, &lt;code&gt;HTML&lt;/code&gt; e apresentações em &lt;code&gt;beamer&lt;/code&gt;, &lt;code&gt;pptx&lt;/code&gt; e &lt;code&gt;HTML&lt;/code&gt; (de vários tipos). Pode ainda gerar sites, livros, dissertações de mestrado e até mesmo dashboards interativos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reprodutível&lt;/strong&gt;. O RMarkdown nada mais é que um arquivo de texto. Além disso, ele tenta te obrigar a fazer o documento mais autocontido possível. Assim, um documento &lt;code&gt;.Rmd&lt;/code&gt; é fácil de compartilhar e de ser utilizado pelo receptor. Lembre-se, o receptor pode ser o futuro você! Vale enfatizar que a reprodutibilidade é considerada como um dos princípios fundamentais da ciência. Então, só de usar RMarkdown, você já está colaborando com a ciência. :)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flexível&lt;/strong&gt;. É possível configurar e criar templates de análises para quaisquer tipos de aplicações e clientes. Os textos podem ser parametrizados por números que variam de versão para versão, mensalmente, por exemplo, tudo escrito somente em R.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Criar um RMarkdown novo no RStudio é fácil. Clique no botão de criar arquivo e selecione RMarkdown.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;knitr::include_graphics(&amp;quot;figures/criar_rmarkdown.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures/criar_rmarkdown.png&#34; alt=&#34;plot of chunk unnamed-chunk-20&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para detalhes sobre como utilizar o RMarkdown, leia  &lt;a href=&#34;http://r4ds.had.co.nz/r-markdown.html&#34;&gt;aqui&lt;/a&gt; e &lt;a href=&#34;http://rmarkdown.rstudio.com/lesson-1.html&#34;&gt; aqui&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;r-como-calculadora&#34;&gt;R como calculadora&lt;/h2&gt;

&lt;p&gt;Pelo console, é possível executar qualquer comando do R.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;1:30
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
## [24] 24 25 26 27 28 29 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse comando é uma forma simplificada de criar um vetor de inteiros de 1 a 30.
Os números que aparecem entre colchetes ([1] e [24]) indicam o índice do primeiro elemento impresso nessa linha.&lt;/p&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Quando compilamos?
&lt;/p&gt;
&lt;p&gt;
Quem vem de linguagens como o C ou Java espera que seja necessário compilar o código em texto para o código de máquinas (geralmente um código binário). No R, isso não é necessário. O R é uma linguagem de programação dinâmica que interpreta o seu código enquanto você o executa.
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Tente jogar no console &lt;code&gt;2 * 2 - (4 + 4) / 2&lt;/code&gt;. Pronto! Com essa simples expressão você já é capaz de imaginar (certeiramente) como pedir ao R para fazer qualquer tipo de operação aritmética. Lição aprendida!&lt;/p&gt;

&lt;p&gt;Além do mais, as operações e suas precedências são mantidas como na matemática, ou seja, divisão e multiplicação são calculadas antes da adição e subtração. E os parênteses nunca são demais!&lt;/p&gt;

&lt;p&gt;Agora que você já conhece o RStudio, digite a expressão &lt;code&gt;2 * 2 - (4 + 4) / 2&lt;/code&gt; no
&lt;strong&gt;console&lt;/strong&gt; e tecle &lt;code&gt;Enter&lt;/code&gt;. Uma outra forma de chamar uma expressão é escrever
o código no &lt;strong&gt;editor&lt;/strong&gt; e teclar &lt;code&gt;Ctrl + Enter&lt;/code&gt; ou &lt;code&gt;Ctrl + R&lt;/code&gt;. Assim, o comando é enviado para o &lt;strong&gt;console&lt;/strong&gt;, onde é diretamente executado.&lt;/p&gt;

&lt;p&gt;Se você digitar um comando incompleto, como &lt;code&gt;5 +&lt;/code&gt;, e apertar &lt;code&gt;Enter&lt;/code&gt;, o R mostrará um &lt;code&gt;+&lt;/code&gt;, o que não tem nada a ver com somar alguma coisa. Isso significa que o R está esperando que você complete o seu comando. Termine o seu comando ou aperte &lt;code&gt;Esc&lt;/code&gt; para recomeçar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 5 -
+ 
+ 5
[1] 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se você digitar um comando que o R não reconhece, ele retornará uma mensagem de erro. NÃO ENTRE EM PÂNICO! Ele só está avisando que não conseguiu interpretar o comando. Você pode digitar outro comando normalmente em seguida.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 5 % 5
Error: unexpected input in &amp;quot;5 % 5&amp;quot;
&amp;gt; 5 - 5
[1] 0
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;pedindo-ajuda&#34;&gt;Pedindo Ajuda&lt;/h2&gt;

&lt;p&gt;No R, há quatro principais entidades para se pedir ajuda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Help/documentação do R (comandos &lt;code&gt;help(nome_da_funcao)&lt;/code&gt; ou &lt;code&gt;?nome_da_funcao&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Google&lt;/li&gt;
&lt;li&gt;Stack Overflow&lt;/li&gt;
&lt;li&gt;Coleguinha&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A busca por ajuda é feita preferencialmente, mas não necessariamente, na ordem acima.&lt;/p&gt;

&lt;h3 id=&#34;documentação-do-r&#34;&gt;Documentação do R&lt;/h3&gt;

&lt;p&gt;A documentação do R serve para você aprender a usar uma determinada função.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;?mean
help(mean)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cinco dicas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Os exemplos no final são particularmente úteis.&lt;/li&gt;
&lt;li&gt;Atente-se na seção &lt;strong&gt;Usage&lt;/strong&gt; para ter noção de como usar.&lt;/li&gt;
&lt;li&gt;Os parâmetros estão descritos em &lt;strong&gt;Arguments&lt;/strong&gt;. Identifique quais tipos de objetos eles recebem.&lt;/li&gt;
&lt;li&gt;Caso essa função não atenda às suas necessidades, a seção &lt;strong&gt;See Also&lt;/strong&gt; sugere funções relacionadas.&lt;/li&gt;
&lt;li&gt;Alguns pacotes possuem tutorias de uso mais completos. Esses textos são chamados de &lt;code&gt;vignettes&lt;/code&gt; e podem ser acessados com a função &lt;code&gt;vignette(package = &#39;nomeDoPacote&#39;)&lt;/code&gt;. Por exemplo, &lt;code&gt;vignette(package = &#39;dplyr&#39;)&lt;/code&gt;. Depois de ver a lista de artigos, escolha um nome e rode &lt;code&gt;vignette(topic = &#39;nome&#39;, package = &#39;nomeDoPacote&#39;)&lt;/code&gt;. Por exemplo, &lt;code&gt;vignette(topic = &#39;introduction&#39;, package = &#39;dplyr&#39;)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;google&#34;&gt;Google&lt;/h3&gt;

&lt;p&gt;Há uma comunidade gigantesca de usuários de R gerando diariamente uma infinidade de conteúdos e discussões. Não raramente, você irá encontrar discussões sobre o seu problema simplesmente jogando o copiar/colar do seu erro no Google. Essa deve ser sua primeira tentativa!&lt;/p&gt;

&lt;p&gt;Exemplo (repare no &amp;lsquo;r&amp;rsquo; adicionado na busca, também ajuda):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;log(&amp;quot;5&amp;quot;)
## Error in log(&amp;quot;5&amp;quot;): non-numeric argument to mathematical function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures/ajuda_google.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;stack-overflow&#34;&gt;Stack Overflow&lt;/h3&gt;

&lt;p&gt;O &lt;a href=&#34;http://stackoverflow.com/&#34;&gt;Stack Overflow&lt;/a&gt; e o &lt;a href=&#34;http://pt.stackoverflow.com/&#34;&gt;Stack Overflow em Português&lt;/a&gt; são sites de Pergunta e Resposta amplamente utilizados por todas as linguagens de programação, e R é uma delas. Nos EUA, chegam até a usar a reputação dos usuários como diferencial no currículo!&lt;/p&gt;

&lt;p&gt;Provavelmente, o Google lhe indicará uma página deles quando você estiver procurando ajuda. E quando todas as fontes possíveis de ajuda falharem, o Stack Overflow lhe dará o espaço para &lt;strong&gt;criar sua própria pergunta&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Um ponto importante:&lt;/strong&gt; como fazer uma &lt;strong&gt;boa&lt;/strong&gt; pergunta no Stack Overflow?&lt;/p&gt;

&lt;p&gt;No site, tem um tutorial com uma lista de boas práticas, &lt;a href=&#34;http://pt.stackoverflow.com/help/how-to-ask&#34;&gt;que se encontra aqui&lt;/a&gt;. Algumas dicas são&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ser conciso;&lt;/li&gt;
&lt;li&gt;ser específico;&lt;/li&gt;
&lt;li&gt;ter mente aberta; e&lt;/li&gt;
&lt;li&gt;ser gentil.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Porém, no caso do R, há outro requisito que vai aumentar muito sua chance de ter uma boa resposta: &lt;strong&gt;exemplinho minimal e reprodutível&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ser &lt;strong&gt;minimal&lt;/strong&gt;: usar bancos de dados menores e utilizar pedaços de códigos apenas suficientes para gerar o seu problema. Não precisa de banco de dados de um milhão de linhas e nem colocar o seu código inteiro para mostrar seu problema.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ser &lt;strong&gt;reprodutível&lt;/strong&gt;: o seu código deve rodar fora da sua máquina. Se você não fornecer uma versão do seu problema que rode (ou que imite seu erro), as pessoas vão logo desistir de te ajudar. Por isso, nunca coloque bancos de dados que só você tem acesso. Use bancos de dados que já vem no R ou disponibilize um exemplo (possivelmente anonimizado) em &lt;code&gt;.csv&lt;/code&gt; na web para baixar. E se precisar utilizar funções diferentes, coloque as &lt;code&gt;library&lt;/code&gt;&amp;rsquo;s correspondentes.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;instalar-pacotes&#34;&gt;Instalar pacotes&lt;/h2&gt;

&lt;p&gt;O grande trunfo do R são seus pacotes. Assim, fique bastante à vontade para instalar e atualizar muitos e muitos pacotes ao longo da sua experiência com o R.&lt;/p&gt;

&lt;p&gt;Existem três principais maneiras de instalar pacotes. Em ordem de frequência, são:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Via CRAN (Comprehensive R Archive Network): &lt;code&gt;install.packages(&amp;quot;magrittr&amp;quot;)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Via Github: &lt;code&gt;devtools::install_github(&amp;quot;rstudio/shiny&amp;quot;)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Via arquivo .zip/.tar.gz: &lt;code&gt;install.packages(&amp;quot;C:/caminho/pacote.zip&amp;quot;, repos = NULL)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;via-cran&#34;&gt;Via CRAN&lt;/h3&gt;

&lt;p&gt;Instale pacotes que não estão na sua biblioteca usando a função &lt;code&gt;install.packages(&amp;quot;nome_do_pacote&amp;quot;)&lt;/code&gt;. Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&amp;quot;magrittr&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E, de agora em diante, basta carregar o pacote com &lt;code&gt;library(magrittr)&lt;/code&gt;. Não precisa mais instalar.&lt;/p&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Dica!
&lt;/p&gt;
&lt;p&gt;
Escreva `nome_do_pacote::nome_da_funcao()` se quiser usar apenas uma função de um determinado pacote. O operador `::` serve para isso. Essa forma também é útil quando se tem duas funções com o mesmo nome, e precisamos garantir que o código vá usar a função do pacote correto.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;via-github&#34;&gt;Via Github&lt;/h3&gt;

&lt;p&gt;Desenvolvedores costumam disponibilizar a última versão de seus pacotes no Github, e alguns deles sequer estão no CRAN. Mesmo assim ainda é possível utilizá-los instalando diretamente pelo github. O comando é igualmente simples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;devtools::install_github(&amp;quot;rstudio/shiny&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apenas será necessário o username e o nome do repositório. No exemplo, o username foi &amp;ldquo;rstudio&amp;rdquo; e o pacote foi &amp;ldquo;shiny&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Não se preocupe! Os pacotes disponibilizados no github geralmente têm um &lt;code&gt;README&lt;/code&gt; cuja primeira instrução é sobre a instalação. Se não tiver, provavelmente este pacote não te merece! =)&lt;/p&gt;

&lt;h3 id=&#34;via-arquivo-zip-tar-gz&#34;&gt;Via arquivo .zip/.tar.gz&lt;/h3&gt;

&lt;p&gt;Se você precisar instalar um pacote que está zipado no seu computador (ou em algum servidor), utilize o seguinte comando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&amp;quot;C:/caminho/para/o/arquivo/zipapo/pacote.zip&amp;quot;, repos = NULL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É semelhante a instalar pacotes via CRAN, com a diferença que agora o nome do pacote é o caminho inteiro até o arquivo. O parâmetro &lt;code&gt;repos = NULL&lt;/code&gt; informa que estamos instalando a partir da máquina local.&lt;/p&gt;

&lt;p&gt;A aba &lt;strong&gt;&lt;em&gt;Packages&lt;/em&gt;&lt;/strong&gt; do RStudio também ajuda a administrar os seus pacotes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;figures/instalar_pacote_rstudio.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;controles-de-fluxo&#34;&gt;Controles de Fluxo&lt;/h2&gt;

&lt;p&gt;Como toda boa linguagem de programação, o R possui estruturas de &lt;code&gt;if&lt;/code&gt;&amp;rsquo;s, &lt;code&gt;else&lt;/code&gt;&amp;rsquo;s, &lt;code&gt;for&lt;/code&gt;&amp;rsquo;s, &lt;code&gt;while&lt;/code&gt;&amp;rsquo;s etc. Esses &lt;strong&gt;controles de fluxo&lt;/strong&gt; são importantes na hora de programar.&lt;/p&gt;

&lt;h3 id=&#34;if-e-else&#34;&gt;IF e ELSE&lt;/h3&gt;

&lt;p&gt;O seguinte trecho de código só será executado se o objeto &lt;code&gt;x&lt;/code&gt; for igual a 1.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 2
if(x == 1) {
  print(&amp;quot;oi&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 1
if(x == 1) {
  print(&amp;quot;oi&amp;quot;)
}
## [1] &amp;quot;oi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O R só vai executar o que está na expressão dentro das chaves &lt;code&gt;{}&lt;/code&gt; se o que estiver dentro dos parênteses &lt;code&gt;()&lt;/code&gt; retornar &lt;code&gt;TRUE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A sintaxe com o &lt;code&gt;else&lt;/code&gt; e o &lt;code&gt;if else&lt;/code&gt; é&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if(&amp;lt;condição1&amp;gt;) {
  
} else if (&amp;lt;condição2&amp;gt;) {
  
} else if (&amp;lt;condição3&amp;gt;) {
  
} else {
  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Diferença entre SQL e R nas comparações lógicas
&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;Igualdade&lt;/b&gt; no SQL é só um sinal de igual: &lt;2 = 1. No R são dois: 2 == 1.
&lt;br&gt;
&lt;b&gt;Diferença&lt;/b&gt; O teste de diferente no R é != ao invés de de &lt;&gt;.
&lt;br&gt;
&lt;b&gt;Negação&lt;/b&gt; ao invés de usar a palavra &#34;not&#34; igual ao SQL, usamos !. Por exemplo, &#34;entidade_id not in (&#39;100515&#39;)&#34; fica &#34;!entidade_id %in% c(&#39;100515&#39;)&#34;.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;for&#34;&gt;for&lt;/h3&gt;

&lt;p&gt;Sintaxe do &lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;for(contador in 1:5){
  # várias coisas...
  print(contador)
}
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Outro exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor &amp;lt;- 30:35
indices &amp;lt;- seq_along(vetor)
for(i in indices){
  print(vetor[1:i] / 2)
}
## [1] 15
## [1] 15.0 15.5
## [1] 15.0 15.5 16.0
## [1] 15.0 15.5 16.0 16.5
## [1] 15.0 15.5 16.0 16.5 17.0
## [1] 15.0 15.5 16.0 16.5 17.0 17.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No trecho de código acima, preste atenção no resultado individual de cada uma das operações para entender como o R funciona.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;objetos&#34;&gt;Objetos&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- 1
a
## [1] 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O R te permite salvar dados dentro de um objeto.&lt;/p&gt;

&lt;p&gt;No exemplo acima, salvamos o valor &lt;code&gt;1&lt;/code&gt; em &lt;code&gt;a&lt;/code&gt;, e sempre que o R encontrar o nome &lt;code&gt;a&lt;/code&gt; ele vai substituir por &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Atenção!
&lt;/p&gt;
&lt;p&gt;
O R entende letras maiúsculas e minúsculas, isto é &lt;b&gt;a&lt;/b&gt; é considerado um objeto diferente de &lt;b&gt;A&lt;/b&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;objetos-atômicos&#34;&gt;Objetos atômicos&lt;/h3&gt;

&lt;p&gt;Existem cinco classes básicas ou &amp;ldquo;atômicas&amp;rdquo; no R:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;character &lt;code&gt;&amp;quot;UAH!&amp;quot;&lt;/code&gt; (é o varchar do SQL)&lt;/li&gt;
&lt;li&gt;numeric &lt;code&gt;0.95&lt;/code&gt; (números reais)&lt;/li&gt;
&lt;li&gt;integer &lt;code&gt;100515&lt;/code&gt; (inteiros)&lt;/li&gt;
&lt;li&gt;complex &lt;code&gt;2 + 5i&lt;/code&gt; (números complexos, a + bi)&lt;/li&gt;
&lt;li&gt;logical &lt;code&gt;TRUE&lt;/code&gt; (booleanos, TRUE/FALSE)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;vetores&#34;&gt;Vetores&lt;/h3&gt;

&lt;p&gt;Vetores no R são os objetos mais simples que podem guardar objetos atômicos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor &amp;lt;- c(1, 2, 3, 4)
class(vetor)
## [1] &amp;quot;numeric&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De forma bastante intuitiva, você pode fazer operações com vetores.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor - 1
## [1] 0 1 2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quando você faz &lt;code&gt;vetor - 1&lt;/code&gt;, o R subtrai &lt;code&gt;1&lt;/code&gt; de cada um dos elementos do vetor. O mesmo acontece quando você faz qualquer operação aritmética com vetores no R. Tente jogar o código abaixo no console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor / 2
vetor * 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Você também pode fazer operações que envolvem mais de um vetor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor * vetor
## [1]  1  4  9 16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Neste caso, o R irá alinhar os dois vetores e multiplicar elemento por elemento. Isso pode ficar um pouco confuso quando os dois vetores não possuem o mesmo tamanho:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor2 &amp;lt;- 1:3
vetor * vetor2
## Warning in vetor * vetor2: longer object length is not a multiple of
## shorter object length
## [1] 1 4 9 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora o R alinhou os dois vetores. Como eles não possuíam o mesmo tamanho, foi repetindo o vetor menor até completar o vetor maior.&lt;/p&gt;

&lt;p&gt;Esse comportamento é chamado de &lt;strong&gt;reciclagem&lt;/strong&gt; e é útil para fazer operações &lt;em&gt;elemento por elemento&lt;/em&gt; (vetorizadamente), mas às vezes pode ser confuso. Com o tempo, você aprenderá a se aproveitar dele.&lt;/p&gt;

&lt;h3 id=&#34;misturando-objetos&#34;&gt;Misturando objetos&lt;/h3&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Vetores são homogêneos
&lt;/p&gt;
&lt;p&gt;
Os elementos de um vetor são sempre da mesma classe. Ou todos são numéricos, ou são todos character, ou todos são lógicos etc. Não dá para ter um número e um character no mesmo vetor, por exemplo.
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Se colocarmos duas ou mais classes diferentes dentro de um mesmo vetor, o R vai forçar que todos os elementos passem a pertencer à mesma classe. O número &lt;code&gt;1.7&lt;/code&gt; viraria &lt;code&gt;&amp;quot;1.7&amp;quot;&lt;/code&gt; se fosse colocado ao lado de um &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;y &amp;lt;- c(1.7, &amp;quot;a&amp;quot;)  ## character
y &amp;lt;- c(TRUE, 2)   ## numeric
y &amp;lt;- c(TRUE, &amp;quot;a&amp;quot;) ## character
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A ordem de precedência é:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DOMINANTE&lt;/strong&gt; &lt;code&gt;character &amp;gt; complex &amp;gt; numeric &amp;gt; integer &amp;gt; logical&lt;/code&gt; &lt;strong&gt;RECESSIVO&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;forçando-classes-explicitamente&#34;&gt;Forçando classes explicitamente&lt;/h3&gt;

&lt;p&gt;Assim como o &lt;code&gt;convert()&lt;/code&gt; do SQL faz, você pode coagir um objeto a ser de uma classe da sua escolha com as funções &lt;code&gt;as.character()&lt;/code&gt;, &lt;code&gt;as.numeric()&lt;/code&gt;, &lt;code&gt;as.integer()&lt;/code&gt; e &lt;code&gt;as.logical()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 0:4
class(x)
## [1] &amp;quot;integer&amp;quot;
as.numeric(x)
## [1] 0 1 2 3 4
as.logical(x)
## [1] FALSE  TRUE  TRUE  TRUE  TRUE
as.character(x)
## [1] &amp;quot;0&amp;quot; &amp;quot;1&amp;quot; &amp;quot;2&amp;quot; &amp;quot;3&amp;quot; &amp;quot;4&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se o R não entender como coagir uma classe na outra, ele soltará um &lt;code&gt;warning&lt;/code&gt; informado que colocou &lt;code&gt;NA&lt;/code&gt; no lugar.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;)
as.numeric(x)
## Warning: NAs introduced by coercion
## [1] NA NA NA
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Observação
&lt;/p&gt;
&lt;p&gt;
O &lt;b&gt;NA&lt;/b&gt; tem o mesmo papel que o &lt;b&gt;null&lt;/b&gt; do SQL. Porém, há um &lt;b&gt;NULL&lt;/b&gt; no R também, com diferenças sutis que vamos abordar mais adiante. Não confundir!
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;matrizes&#34;&gt;Matrizes&lt;/h3&gt;

&lt;p&gt;Matrizes são vetores com duas dimensões (e por isso só possuem elementos de uma mesma classe).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;m &amp;lt;- matrix(1:6, nrow = 2, ncol = 3)
m
##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6
dim(m) # funçăo dim() retorna a dimensăo do objeto.
## [1] 2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare que os números de 1 a 6 foram dispostos na matriz coluna por coluna (&lt;em&gt;column-wise&lt;/em&gt;), ou seja, preenchendo de cima para baixo e depois da esquerda para a direita.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Utilidades&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;m[3,  ]   # seleciona uma linha
m[ , 2]   # seleciona uma coluna
m[1, 2]   # seleciona um elemento
t(m)      # matriz transposta
m %*% n   # multiplicação matricial
solve(m)  # matriz inversa
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fatores&#34;&gt;Fatores&lt;/h3&gt;

&lt;p&gt;Fatores podem ser vistos como vetores de inteiros que possuem rótulos (labels).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sexo &amp;lt;- c(&amp;quot;M&amp;quot;, &amp;quot;H&amp;quot;, &amp;quot;H&amp;quot;, &amp;quot;H&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;H&amp;quot;)
fator &amp;lt;- as.factor(sexo)
fator
## [1] M H H H M M H
## Levels: H M
as.numeric(fator)
## [1] 2 1 1 1 2 2 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eles são úteis para representar uma variável categórica (nominal e ordinal). Na modelagem, eles serão tratados de maneira especial em funções como &lt;code&gt;lm()&lt;/code&gt; e &lt;code&gt;glm()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A função &lt;code&gt;levels()&lt;/code&gt; retorna os rótulos do fator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;levels(fator)
## [1] &amp;quot;H&amp;quot; &amp;quot;M&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A ordem das categorias de um fator pode importar. Como exemplo, temos as caselas de referência de modelos estatísticos e a ordem das barras de um gráfico. Para ajudar nesta tarefa, consulte o pacote &lt;a href=&#34;https://github.com/tidyverse/forcats&#34;&gt;forcats&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Um erro comum e desastroso
&lt;/p&gt;
&lt;p&gt;
Quando um vetor de números está como &lt;b&gt;factor&lt;/b&gt;, ao tentar transformar o vetor em &lt;b&gt;numeric&lt;/b&gt;, você receberá um vetor de inteiros que não tem nada a ver com os valores originais!
&lt;/p&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;numeros &amp;lt;- factor(c(&amp;quot;10&amp;quot;, &amp;quot;55&amp;quot;, &amp;quot;55&amp;quot;, &amp;quot;12&amp;quot;, &amp;quot;10&amp;quot;, &amp;quot;-5&amp;quot;, &amp;quot;-90&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;as.numeric(numeros)
## [1] 3 5 5 4 3 1 2    # &amp;lt;-- Por essa eu năo esperava!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para evitar isso, use &lt;code&gt;as.character()&lt;/code&gt; antes de transformar para número.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;as.numeric(as.character(numeros))
## [1]  10  55  55  12  10  -5 -90   # &amp;lt;-- Agora está OK
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;valores-especiais&#34;&gt;Valores especiais&lt;/h3&gt;

&lt;p&gt;Existem valores reservados para representar dados faltantes, infinitos, e indefinições matemáticas.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NA&lt;/strong&gt; (Not Available) significa dado faltante/indisponível. É o &lt;code&gt;null&lt;/code&gt; do SQL ou o &lt;code&gt;.&lt;/code&gt; do SAS. O &lt;code&gt;NA&lt;/code&gt; tem uma classe, ou seja, podemos ter &lt;code&gt;NA&lt;/code&gt; numeric, &lt;code&gt;NA&lt;/code&gt; character etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NaN&lt;/strong&gt; (Not a Number) representa indefinições matemáticas, como &lt;code&gt;0/0&lt;/code&gt; e &lt;code&gt;log(-1)&lt;/code&gt;. Um &lt;code&gt;NaN&lt;/code&gt; é um &lt;code&gt;NA&lt;/code&gt;, mas a recíproca não é verdadeira.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inf&lt;/strong&gt; (Infinito) é um número muito grande ou o limite matemático, por exemplo, &lt;code&gt;1/0&lt;/code&gt; e &lt;code&gt;10^310&lt;/code&gt;. Aceita sinal negativo &lt;code&gt;-Inf&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NULL&lt;/strong&gt; representa a ausência de informação. Conceitualmente, a diferença entre &lt;code&gt;NA&lt;/code&gt; e &lt;code&gt;NULL&lt;/code&gt; é sutil, mas, no R, o &lt;code&gt;NA&lt;/code&gt; está mais alinhado com os conceitos de estatística (ou como gostaríamos que os dados faltantes se comportassem em análise de dados) e o &lt;code&gt;NULL&lt;/code&gt; está em sintonia com comportamentos de lógica de programação.&lt;/li&gt;
&lt;li&gt;Use as funções &lt;code&gt;is.na()&lt;/code&gt;, &lt;code&gt;is.nan()&lt;/code&gt;, &lt;code&gt;is.infinite()&lt;/code&gt; e &lt;code&gt;is.null()&lt;/code&gt; para testar se um objeto é um desses valores.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(NaN, Inf, 1, 2, 3, NA)
is.na(x)
## [1]  TRUE FALSE FALSE FALSE FALSE  TRUE
is.nan(x)
## [1]  TRUE FALSE FALSE FALSE FALSE FALSE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;listas&#34;&gt;Listas&lt;/h3&gt;

&lt;p&gt;Listas são um tipo especial de vetor que aceita elementos de classes diferentes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- list(1:5, &amp;quot;Z&amp;quot;, TRUE, c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;))
x
## [[1]]
## [1] 1 2 3 4 5
## 
## [[2]]
## [1] &amp;quot;Z&amp;quot;
## 
## [[3]]
## [1] TRUE
## 
## [[4]]
## [1] &amp;quot;a&amp;quot; &amp;quot;b&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É um dos objetos mais importantes para armazenar dados e vale a pena saber manuseá-los bem. Existem muitas funções que fazem das listas objetos incrivelmente úteis.&lt;/p&gt;

&lt;p&gt;Criamos uma lista pela função &lt;code&gt;list()&lt;/code&gt;, que aceita um número arbitrário de elementos. Listas aceitam QUALQUER tipo de objeto. Podemos ter listas dentro de listas, por exemplo. Como para quase todos os objetos no R, as funções &lt;code&gt;is.list()&lt;/code&gt; e &lt;code&gt;as.list()&lt;/code&gt; também existem.&lt;/p&gt;

&lt;p&gt;Na lista &lt;code&gt;pedido&lt;/code&gt; abaixo, temos &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;character&lt;/code&gt;, vetor de &lt;code&gt;character&lt;/code&gt; e &lt;code&gt;list&lt;/code&gt; contida em uma lista:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pedido &amp;lt;- list(pedido_id = 8001406,
               pedido_registro = as.Date(&amp;quot;2016-12-12&amp;quot;),
               nome = &amp;quot;Athos&amp;quot;, 
               sobrenome = &amp;quot;Petri Damiani&amp;quot;, 
               cpf = &amp;quot;12345678900&amp;quot;, 
               email = &amp;quot;athos.damiani@gmail.com&amp;quot;, 
               qualidades = c(&amp;quot;incrível&amp;quot;, &amp;quot;impressionante&amp;quot;),
               itens = list(
                 list(descricao = &amp;quot;Ferrari&amp;quot;, 
                      frete = 0, 
                      valor = 500000),
                 list(descricao = &amp;quot;Dolly&amp;quot;, 
                      frete = 1.5, 
                      valor = 3.90)
               ), 
               endereco = list(entrega = list(logradouro = &amp;quot;Rua da Glória&amp;quot;, 
                                              numero = &amp;quot;123&amp;quot;,
                                              complemento = &amp;quot;apto 71&amp;quot;),
                               cobranca = list(logradouro = &amp;quot;Rua Jose de Oliveira Coutinho&amp;quot;,
                                               numero = &amp;quot;151&amp;quot;,
                                               complemento = &amp;quot;5o andar&amp;quot;)
               )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Utilidades&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pedido$cpf     # elemento chamado &#39;cpf&#39;
pedido[1]      # nova lista com apenas o primeiro elemento
pedido[[2]]    # segundo elemento
pedido[&amp;quot;nome&amp;quot;] # nova lista com apenas o elemento chamado &#39;nome&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Certamente você se deparará com listas quando for fazer análise de dados com o R. Nos tópicos mais aplicados, iremos aprofundar sobre o tema. O pacote &lt;a href=&#34;https://github.com/hadley/purrr&#34;&gt;purrr&lt;/a&gt; contribui com funcionalidades incríveis para listas.&lt;/p&gt;

&lt;h3 id=&#34;data-frame&#34;&gt;data.frame&lt;/h3&gt;

&lt;p&gt;Um &lt;code&gt;data.frame&lt;/code&gt; é o mesmo que uma tabela do SQL ou um spreadsheet do Excel, por isso são objetos muito importantes.&lt;/p&gt;

&lt;p&gt;Usualmente, seus dados serão importados para um objeto &lt;code&gt;data.frame&lt;/code&gt;. Em grande parte do curso, eles serão o principal objeto de estudo.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;data.frame&lt;/code&gt;&amp;rsquo;s são listas especiais em que todos os seus elementos possuem &lt;strong&gt;o mesmo comprimento&lt;/strong&gt;. Cada elemento dessa lista pode ser pensado como uma coluna da tabela. Seu comprimento representa o número de linhas.&lt;/p&gt;

&lt;p&gt;Já que são listas, essas colunas podem ser de classes diferentes. Essa é a grande diferença entre &lt;code&gt;data.frame&lt;/code&gt;&amp;rsquo;s e matrizes. Algumas funções úteis:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;head()&lt;/code&gt; - Mostra as primeiras 6 linhas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tail()&lt;/code&gt; - Mostra as últimas 6 linhas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dim()&lt;/code&gt; - Número de linhas e de colunas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;names()&lt;/code&gt; - Os nomes das colunas (variáveis).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str()&lt;/code&gt; - Estrutura do data.frame. Mostra, entre outras coisas, as classes de cada coluna.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cbind()&lt;/code&gt; - Acopla duas tabelas lado a lado.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rbind()&lt;/code&gt; - Empilha duas tabelas.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;O exemplo abaixo mostra que uma lista pode virar &lt;code&gt;data.frame&lt;/code&gt; se todos os elementos tiverem o mesmo comprimento.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;minha_lista &amp;lt;- list(x = c(1, 2, 3), y = c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;))
as.data.frame(minha_lista)
## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 3, 2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;minha_lista &amp;lt;- list(x = c(1, 2, 3), y = c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;))
as.data.frame(minha_lista)
##   x y
## 1 1 a
## 2 2 b
## 3 3 c
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;exemplo-de-data-frame-iris&#34;&gt;Exemplo de data.frame: iris {-}&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;head(iris)  
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa
str(iris)
## &#39;data.frame&#39;:	150 obs. of  5 variables:
##  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
##  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
##  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
##  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
##  $ Species     : Factor w/ 3 levels &amp;quot;setosa&amp;quot;,&amp;quot;versicolor&amp;quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;funções&#34;&gt;Funções&lt;/h2&gt;

&lt;p&gt;O R vem com muitas funções implementadas com as quais você pode fazer muitas  tarefas complicadas, como gerar números aleatórios. Geralmente, o nome das funções é bem intuitivo, por exemplo, &lt;code&gt;mean&lt;/code&gt; é a função que calcula a média, &lt;code&gt;round&lt;/code&gt; é a função que arredonda um número etc.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;round(5.634)
## [1] 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para entender melhor o funcionamento das funções no R, considere o seguinte exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;die &amp;lt;- 1:6
round(mean(die))
## [1] 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A ilustração abaixo mostra o que acontece quando você executa &lt;code&gt;round(mean(die))&lt;/code&gt; no R.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;figures/round.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Passamos dados para as funções por meio de argumentos. No R, esses argumentos estão documentados na página de ajuda de cada uma das funções, que pode ser acessada digitando &lt;code&gt;help(nome_da_funcao)&lt;/code&gt; ou &lt;code&gt;?nome_da_funcao&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;criando-suas-próprias-funções&#34;&gt;Criando suas próprias funções&lt;/h3&gt;

&lt;p&gt;Sintaxe:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;soma &amp;lt;- function(x, y = 0) {
  resposta &amp;lt;- x + y
  return(resposta)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A função acima tem:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;o nome &lt;code&gt;soma&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;os argumentos &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;o corpo &lt;code&gt;resposta &amp;lt;- x + y&lt;/code&gt;; e&lt;/li&gt;
&lt;li&gt;o valor padrão &lt;code&gt;0&lt;/code&gt; para o argumento &lt;code&gt;y&lt;/code&gt; (&lt;code&gt;y = 0&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Use-a como qualquer outra função:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;soma(2, 1) # soma de 2 + 1
## [1] 3
soma(2) # soma de 2 + 0
## [1] 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O argumento &lt;code&gt;y&lt;/code&gt; possui o valor padrão &lt;code&gt;0&lt;/code&gt;. Isso quer dizer que ele valerá zero caso o usuário não passe um valor explicitamente.&lt;/p&gt;

&lt;p&gt;O &lt;a href=&#34;http://adv-r.had.co.nz/&#34;&gt;Advanced-R&lt;/a&gt; é um excelente livro para quem quiser masterizar a arte de se fazer funções.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;gráficos-base&#34;&gt;Gráficos (base)&lt;/h2&gt;

&lt;p&gt;O R já vem com funções básicas que fazem gráficos estatísticos de todas as naturezas.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Vantagens: são rápidas e simples.&lt;/li&gt;
&lt;li&gt;Desvantagens: são feias e difíceis para gerar gráficos complexos.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;gráfico-de-dispersão&#34;&gt;Gráfico de dispersão&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Funçăo&lt;/strong&gt; &lt;code&gt;plot()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Parâmetros principais (ver &lt;code&gt;help(hist)&lt;/code&gt; para mais detalhes):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; - Vetores para representarem os eixos x e y.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt; -  Tipo de gráfico. Pode ser pontos, linhas, escada etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Atenção!
&lt;/p&gt;
&lt;p&gt; 
Além de gerar gráficos de dispersão, tentar chamar a função &lt;b&gt;plot(objeto_diferentao)&lt;b&gt; para qualquer tipo de objeto do R geralmente sai um gráfico interessante! Sempre tente fazer isso, a menos que seu objeto seja um &lt;b&gt;data.frame&lt;b&gt; com milhares de colunas!!!
&lt;/p&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;n &amp;lt;- 100
x &amp;lt;- 1:n
y &amp;lt;- 5 + 2 * x + rnorm(n, sd = 30)
plot(x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-58-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-58&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O parâmetro &lt;code&gt;type = &amp;quot;l&amp;quot;&lt;/code&gt; indica que queremos que os pontos sejam interligados por linhas.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot(x, y, type = &amp;quot;l&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-59-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-59&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;histograma&#34;&gt;Histograma&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Funçăo&lt;/strong&gt; &lt;code&gt;hist()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Parâmetros principais (ver &lt;code&gt;help(hist)&lt;/code&gt; para mais detalhes):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; - O vetor numérico pra histogramar.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;breaks&lt;/code&gt; - O número (aproximado) de retângulos.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;hist(rnorm(1000))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-60-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-60&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;boxplot&#34;&gt;Boxplot&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Função&lt;/strong&gt; &lt;code&gt;boxplot()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Parâmetros principais (ver &lt;code&gt;help(boxplot)&lt;/code&gt; para mais detalhes):&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Uma variável&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;boxplot(InsectSprays$count, col = &amp;quot;lightgray&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-61-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-61&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Duas variáveis&lt;/strong&gt; - Usamos fórmula e o parâmetro &lt;code&gt;data&lt;/code&gt;!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;boxplot(count ~ spray, data = InsectSprays, col = &amp;quot;lightgray&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-62-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-62&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;gráfico-de-barras&#34;&gt;Gráfico de barras&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Função&lt;/strong&gt; &lt;code&gt;table()&lt;/code&gt;, &lt;code&gt;barplot()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Primeiro crie uma tabela de frequências (ou qualquer outro sumário). Então crie o gráfico com &lt;code&gt;barplot()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tabela com uma variável&lt;/strong&gt; usando &lt;code&gt;table()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;data(diamonds, package = &amp;quot;ggplot2&amp;quot;)
tabela &amp;lt;- table(diamonds$color)
tabela
## 
##     D     E     F     G     H     I     J 
##  6775  9797  9542 11292  8304  5422  2808
barplot(tabela)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-63-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-63&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tabela com duas variáveis&lt;/strong&gt; em uma tabela de dupla entrada.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;VADeaths
##       Rural Male Rural Female Urban Male Urban Female
## 50-54       11.7          8.7       15.4          8.4
## 55-59       18.1         11.7       24.3         13.6
## 60-64       26.9         20.3       37.0         19.3
## 65-69       41.0         30.9       54.6         35.1
## 70-74       66.0         54.3       71.1         50.0
barplot(VADeaths) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-64-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-64&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;fórmulas&#34;&gt;Fórmulas&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;formula &amp;lt;- y ~ x1 + x2
class(formula)
## [1] &amp;quot;formula&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fórmulas são coisas do tipo &lt;code&gt;y ~ x&lt;/code&gt;. As funções as usam de maneiras diversas, mas o exemplo mais emblemático vem da modelagem estatística.&lt;/p&gt;

&lt;p&gt;A função &lt;code&gt;lm()&lt;/code&gt; é a que ajusta uma regressão linear no R, e &lt;code&gt;lm(y ~ x)&lt;/code&gt; lê-se &amp;ldquo;regressão linear de y explicada por x&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;minha_formula &amp;lt;- Sepal.Width ~ Petal.Length + Petal.Width
class(minha_formula)
## [1] &amp;quot;formula&amp;quot;
lm(minha_formula, data = iris)
## 
## Call:
## lm(formula = minha_formula, data = iris)
## 
## Coefficients:
##  (Intercept)  Petal.Length   Petal.Width  
##       3.5870       -0.2571        0.3640
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No caso específico das regressões lineares, são nas fórmulas que conseguimos descrever as variáveis explicativas e suas interações. A fórmula &lt;code&gt;y ~ x1 * x2&lt;/code&gt; significa &amp;ldquo;y regredido por x1, x2 e a interação entre x1 e x2&amp;rdquo;. Fórmulas aparecem frequentemente em tarefas de modelagem.&lt;/p&gt;

&lt;p&gt;Demais usos de fórmulas aparecerão em outras funções (como o &lt;code&gt;ggplot&lt;/code&gt;) com outros significados, e a documentação nos dirá como usá-las.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;miscelâneas&#34;&gt;Miscelâneas&lt;/h2&gt;

&lt;h3 id=&#34;vetor-de-letras-do-alfabeto&#34;&gt;Vetor de letras do alfabeto&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;letters
##  [1] &amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot; &amp;quot;d&amp;quot; &amp;quot;e&amp;quot; &amp;quot;f&amp;quot; &amp;quot;g&amp;quot; &amp;quot;h&amp;quot; &amp;quot;i&amp;quot; &amp;quot;j&amp;quot; &amp;quot;k&amp;quot; &amp;quot;l&amp;quot; &amp;quot;m&amp;quot; &amp;quot;n&amp;quot; &amp;quot;o&amp;quot; &amp;quot;p&amp;quot; &amp;quot;q&amp;quot;
## [18] &amp;quot;r&amp;quot; &amp;quot;s&amp;quot; &amp;quot;t&amp;quot; &amp;quot;u&amp;quot; &amp;quot;v&amp;quot; &amp;quot;w&amp;quot; &amp;quot;x&amp;quot; &amp;quot;y&amp;quot; &amp;quot;z&amp;quot;
LETTERS
##  [1] &amp;quot;A&amp;quot; &amp;quot;B&amp;quot; &amp;quot;C&amp;quot; &amp;quot;D&amp;quot; &amp;quot;E&amp;quot; &amp;quot;F&amp;quot; &amp;quot;G&amp;quot; &amp;quot;H&amp;quot; &amp;quot;I&amp;quot; &amp;quot;J&amp;quot; &amp;quot;K&amp;quot; &amp;quot;L&amp;quot; &amp;quot;M&amp;quot; &amp;quot;N&amp;quot; &amp;quot;O&amp;quot; &amp;quot;P&amp;quot; &amp;quot;Q&amp;quot;
## [18] &amp;quot;R&amp;quot; &amp;quot;S&amp;quot; &amp;quot;T&amp;quot; &amp;quot;U&amp;quot; &amp;quot;V&amp;quot; &amp;quot;W&amp;quot; &amp;quot;X&amp;quot; &amp;quot;Y&amp;quot; &amp;quot;Z&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;operadores-aritméticos&#34;&gt;Operadores aritméticos&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Operador&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descrição&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x + y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Adição de x com y.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x - y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Subtração de y em x.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x * y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Multiplicaçăo de x e y.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x / y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Divisão de x por y.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x^y ou x**y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;x elevado a y-ésima potência.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x%%y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Resto da divisão de x por y (módulo).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x%/%y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Parte inteira da divisão de x por y.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;operadores-lógicos&#34;&gt;Operadores lógicos&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Operador&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descrição&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x &amp;lt; y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;x menor que y?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x &amp;lt;= y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;x menor ou igual a y?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x &amp;gt; y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;x maior que y?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x &amp;gt;= y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;x maior ou igual a y?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x == y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;x igual a y?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x != y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;x diferente de y?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;!x&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Negativa de x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x &amp;#124; y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;x ou y são verdadeiros?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x &amp;amp; y&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;x e y são verdadeiros?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;xor(x, y)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;x ou y são verdadeiros (apenas um deles)?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;ol&gt;
&lt;li&gt;Calcule o número de ouro no R.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$$ \frac{1 + \sqrt{5}}{2} $$&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIERpZ2l0ZSBhIGV4cHJlc3NcdTAwZTNvIHF1ZSBjYWxjdWxhIG8gblx1MDBmYW1lcm8gZGUgb3Vyby4iLCJzb2x1dGlvbiI6IiMgRGlnaXRlIGEgZXhwcmVzc1x1MDBlM28gcXVlIGNhbGN1bGEgbyBuXHUwMGZhbWVybyBkZSBvdXJvLlxuKDEgKyBzcXJ0KDUpKS8yIiwic2N0IjoidGVzdF9vdXRwdXRfY29udGFpbnMoXCIxLjYxODAzNFwiLCBpbmNvcnJlY3RfbXNnID0gXCJUZW0gY2VydGV6YSBkZSBxdWUgaW5kaWNvdSBhIGV4cHJlc3NcdTAwZTNvIGNvcnJldGFtZW50ZT9cIilcbnN1Y2Nlc3NfbXNnKFwiQ29ycmV0byFcIikifQ==&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;O que dá divisão de 1 por 0 no R? E -1 por 0?&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIgMS8wXG4tMS8wIiwic2N0IjoidGVzdF9vdXRwdXRfY29udGFpbnMoXCJJbmZcIiwgaW5jb3JyZWN0X21zZyA9IFwiVGVtIGNlcnRlemEgZGUgcXVlIGluZGljb3UgYSBleHByZXNzXHUwMGUzbyBjb3JyZXRhbWVudGU/XCIpXG50ZXN0X291dHB1dF9jb250YWlucyhcIi1JbmZcIiwgaW5jb3JyZWN0X21zZyA9IFwiVGVtIGNlcnRlemEgZGUgcXVlIGluZGljb3UgYSBleHByZXNzXHUwMGUzbyBjb3JyZXRhbWVudGU/XCIpXG5zdWNjZXNzX21zZyhcIkNvcnJldG8hXCIpIn0=&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;Quais as diferenças entre &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;NA&lt;/code&gt; e &lt;code&gt;Inf&lt;/code&gt;? Digite expressões que
retornam cada um desses resultados.&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIE5hTlxuXG4jIE5VTExcblxuIyBOQVxuXG4jIEluZlxuIiwic29sdXRpb24iOiIjIE5hTiBcdTAwZTkgbyByZXN1bHRhZG8gZGUgdW1hIG9wZXJhXHUwMGU3XHUwMGUzbyBtYXRlbVx1MDBlMXRpY2EgaW52XHUwMGUxbGlkYS4gU2lnbmlmaWNhIE5vdCBBIE51bWJlclxuMC8wXG4jIE5VTEwgXHUwMGU5IG8gdmF6aW8gZG8gUi4gXHUwMGM5IGNvbW8gc2UgbyBvYmpldG8gblx1MDBlM28gZXhpc3Rpc3NlXG5OVUxMXG5hID0gTlVMTFxuaXMubnVsbChpbnRlZ2VyKGxlbmd0aCA9IDApKSAjIHZlamEgcXVlIHVtIHZldG9yLCBtZXNtbyBzZW0gZWxlbWVudG9zIG5cdTAwZTNvIFx1MDBlOSBOVUxMXG4jIE5BIFx1MDBlOSB1bWEgY29uc3RhbnRlIGxcdTAwZjNnaWNhIGRvIFIuIFNpZ2luaWZpY2EgTm90IEF2YWlsbGFibGUuIE5BIHBvZGUgc2VyIFxuIyBjb252ZXJ0aWRvIHBhcmEgcXVhc2UgdG9kb3Mgb3MgdGlwb3MgZGUgdmV0b3JlcyBkbyBSLiBcdTAwYzkgdXNhZG8gcHJpbmNpcGFsbWVudGUgcGFyYVxuIyBpbmRpY2FyIHZhbG9yZXMgZmFsdGFudGVzLlxuTkFcbiMgSW5mIFx1MDBlOSBzaWduaWZpY2EgaW5maW5pdG8uIFx1MDBjOSBvIHJlc3VsdGFkbyBkZSBvcGVyYVx1MDBlN1x1MDBmNWVzIG1hdGVtXHUwMGUxdGljYXMgY3VqbyBsaW1pdGUgXHUwMGU5IGluZmluaXRvLlxuMS8wXG4xL0luZiJ9&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Tente mentalmente calcular o que dá a conta &lt;code&gt;5 + 3 * 10 %/% 3 == 15&lt;/code&gt; no R, sem rodar.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Adicionando apenas parênteses, faça a expressão acima retornar o resultado contrário.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI1ICsgMyAqIDEwICUvJSAzID09IDE1Iiwic29sdXRpb24iOiI1ICsgKDMgKiAxMCkgJS8lIDMgPT0gMTUiLCJzY3QiOiJ0ZXN0X291dHB1dF9jb250YWlucyhcIlRSVUVcIiwgaW5jb3JyZWN0X21zZyA9IFwiVGVtIGNlcnRlemEgZGUgcXVlIGluZGljb3UgYSBleHByZXNzXHUwMGUzbyBjb3JyZXRhbWVudGU/XCIpXG5zdWNjZXNzX21zZyhcIkNvcnJldG8hXCIpIn0=&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;O que acontece se você rodar:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 4
if(x = 4) {
  &#39;isso aqui apareceu&#39;
}
x
&lt;/code&gt;&lt;/pre&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIDRcbmlmKHggPSA0KSB7XG4gICdpc3NvIGFxdWkgYXBhcmVjZXUnXG59XG54In0=&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;Como você faria para que o código da pergunta anterior fizesse com que &lt;code&gt;&#39;isso aqui apareceu&#39;&lt;/code&gt; fosse impresso no console, mas nenhum erro aparecesse?&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIDRcbmlmKHggPSA0KSB7XG4gICdpc3NvIGFxdWkgYXBhcmVjZXUnXG59XG54Iiwic29sdXRpb24iOiJ4IDwtIDRcbmlmKHggPT0gNCkge1xuICAnaXNzbyBhcXVpIGFwYXJlY2V1J1xufVxueCIsInNjdCI6InRlc3Rfb3V0cHV0X2NvbnRhaW5zKFwiaXNzbyBhcXVpIGFwYXJlY2V1XCIsIGluY29ycmVjdF9tc2cgPSBcIlRlbSBjZXJ0ZXphIGRlIHF1ZSBpbmRpY291IGEgZXhwcmVzc1x1MDBlM28gY29ycmV0YW1lbnRlP1wiKVxudGVzdF9lcnJvcigpXG5zdWNjZXNzX21zZyhcIkNvcnJldG8hXCIpIn0=&lt;/div&gt;

&lt;hr /&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIoMSArIHNxcnQoNSkpLzIifQ==&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIxLzBcbi0xLzAifQ==&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIE5hTiBcdTAwZTkgbyByZXN1bHRhZG8gZGUgdW1hIG9wZXJhXHUwMGU3XHUwMGUzbyBtYXRlbVx1MDBlMXRpY2EgaW52XHUwMGUxbGlkYS4gU2lnbmlmaWNhIE5vdCBBIE51bWJlclxuMC8wXG4jIE5VTEwgXHUwMGU5IG8gdmF6aW8gZG8gUi4gXHUwMGM5IGNvbW8gc2UgbyBvYmpldG8gblx1MDBlM28gZXhpc3Rpc3NlXG5OVUxMXG5hID0gTlVMTFxuaXMubnVsbChpbnRlZ2VyKGxlbmd0aCA9IDApKSAjIHZlamEgcXVlIHVtIHZldG9yLCBtZXNtbyBzZW0gZWxlbWVudG9zIG5cdTAwZTNvIFx1MDBlOSBOVUxMXG4jIE5BIFx1MDBlOSB1bWEgY29uc3RhbnRlIGxcdTAwZjNnaWNhIGRvIFIuIFNpZ2luaWZpY2EgTm90IEF2YWlsbGFibGUuIE5BIHBvZGUgc2VyIFxuIyBjb252ZXJ0aWRvIHBhcmEgcXVhc2UgdG9kb3Mgb3MgdGlwb3MgZGUgdmV0b3JlcyBkbyBSLiBcdTAwYzkgdXNhZG8gcHJpbmNpcGFsbWVudGUgcGFyYVxuIyBpbmRpY2FyIHZhbG9yZXMgZmFsdGFudGVzLlxuTkFcbiMgSW5mIFx1MDBlOSBzaWduaWZpY2EgaW5maW5pdG8uIFx1MDBjOSBvIHJlc3VsdGFkbyBkZSBvcGVyYVx1MDBlN1x1MDBmNWVzIG1hdGVtXHUwMGUxdGljYXMgY3VqbyBsaW1pdGUgXHUwMGU5IGluZmluaXRvLlxuMS8wXG4xL0luZiJ9&lt;/div&gt;

&lt;p&gt;4.&lt;/p&gt;

&lt;p&gt;5.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI1ICsgKDMgKiAxMCkgJS8lIDMgPT0gMTUifQ==&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI+IHggPC0gNFxuPiBpZih4ID0gNCkge1xuRXJybzogJz0nIGluZXNwZXJhZG8gaW4gXCJpZih4ID1cIlxuPiAgICdpc3NvIGFxdWkgYXBhcmVjZXUnXG5bMV0gXCJpc3NvIGFxdWkgYXBhcmVjZXVcIlxuPiB9XG5FcnJvOiAnfScgaW5lc3BlcmFkbyBpbiBcIn1cIlxuPiB4XG5bMV0gNCJ9&lt;/div&gt;

&lt;p&gt;7.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIDRcbmlmKHggPT0gNCkge1xuICAnaXNzbyBhcXVpIGFwYXJlY2V1J1xufVxueCJ9&lt;/div&gt;

&lt;p&gt;8.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmb3IgKGkgaW4gMTo0KXtcbiAgaWYoaSAlJSAyID09IDApe1xuICAgIHByaW50KHBhc3RlKGksIFwiZWxlZmFudGUocylcIiwgcGFzdGUocmVwKFwiaW5jb21vZGEobSlcIiwgdGltZXMgPSBpKSwgY29sbGFwc2UgPSBcIiBcIiksIFwibXVpdG8gbWFpc1wiKSlcbiAgfSBlbHNlIHtcbiAgIHByaW50KHBhc3RlKGksIFwiZWxlZmFudGUocykgaW5jb21vZGEobSkgbXVpdGEgZ2VudGVcIikpIFxuICB9XG59In0=&lt;/div&gt;

&lt;p&gt;9.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIGMoMSwgMjAsIDQwLCA1MCwgNjApIn0=&lt;/div&gt;

&lt;p&gt;10.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIHJ1bmlmKDEwMCkifQ==&lt;/div&gt;

&lt;p&gt;11.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtZWFuKHgpIn0=&lt;/div&gt;

&lt;p&gt;12.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIGMocnVuaWYoOTkpLCBOQSlcbm1lYW4oeCwgbmEucm0gPSBUKSJ9&lt;/div&gt;

&lt;p&gt;13.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtZWRpYSA8LSBmdW5jdGlvbih4KXtcbiAgaSA8LSAxXG4gIHRhbWFuaG8gPC0gbGVuZ3RoKHgpXG4gIHNvbWEgPC0gMFxuICBmb3IoaSBpbiAxOnRhbWFuaG8pe1xuICAgIHNvbWEgPC0gc29tYSArIHhbaV1cbiAgfVxuICByZXR1cm4oc29tYS90YW1hbmhvKVxufSJ9&lt;/div&gt;

&lt;p&gt;14.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYWRvIDwtIGZ1bmN0aW9uKCl7XG4gIHNhbXBsZSgxOjYsIDEpXG59In0=&lt;/div&gt;

&lt;p&gt;15.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzb21hX2RhZG9zIDwtIGZ1bmN0aW9uKG4pe1xuICBzb21hIDwtIDBcbiAgZm9yKGkgaW4gMTpuKXtcbiAgICBzb21hIDwtIHNvbWEgKyBzYW1wbGUoMTo2LCAxKVxuICB9XG4gIHJldHVybihzb21hKVxufSJ9&lt;/div&gt;

&lt;p&gt;16.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyZXN1bHRhZG9zIDwtIGludGVnZXIobGVuZ3RoID0gMTAwMClcbmZvcihpIGluIDE6MTAwMCl7XG4gIHJlc3VsdGFkb3NbaV0gPC0gc29tYV9kYWRvcygzKVxufVxuaGlzdChyZXN1bHRhZG9zKSJ9&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Stringr</title>
      <link>/stringr/</link>
      <pubDate>Fri, 03 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/stringr/</guid>
      <description>

&lt;p&gt;Variáveis do tipo texto são muito comuns nos bancos de dados e geralmente são
colunas que dão bastante trabalho para serem manipuladas. É muito comun encontrar
bancos de dados em que os textos de uma coluna não estão padronizados, por exemplo, uma coluna &lt;code&gt;Estado&lt;/code&gt; com &amp;ldquo;SP&amp;rdquo;, &amp;ldquo;sp&amp;rdquo;, &amp;ldquo;Sao Paulo&amp;rdquo;, &amp;ldquo;São Paulo&amp;rdquo; etc, todas as variações indicando o mesmo estado.&lt;/p&gt;

&lt;p&gt;Para manipular esses textos, o R possui diversas funções para manipular textos. No entanto, as funções do &lt;code&gt;base&lt;/code&gt; não possuem uma interface consistente e cada uma tem a sua forma de passar os parâmetros, dificultando a programação durante a análise.&lt;/p&gt;

&lt;p&gt;Por isso, é recomendado usar o pacote &lt;code&gt;stringr&lt;/code&gt;, que possui uma sintaxe consistente, permitindo que o usuário realize qualquer manipulação com textos com maior facilidade.&lt;/p&gt;

&lt;h3 id=&#34;vantagens-do-stringr-em-relação-ao-base&#34;&gt;Vantagens do stringr em relação ao base&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Sintaxe unificada, o que auxilia na memorização e leitura do código.&lt;/li&gt;
&lt;li&gt;Todas as funções são vetorizadas.&lt;/li&gt;
&lt;li&gt;Construído sobre a &lt;a href=&#34;http://site.icu-project.org/&#34;&gt;biblioteca ICU&lt;/a&gt;, implementada em &lt;code&gt;C&lt;/code&gt; e &lt;code&gt;C++&lt;/code&gt;, apresentando resultados rápidos e confiáveis.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;regras-básicas-do-pacote&#34;&gt;Regras básicas do pacote&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;As funções de manipulação de texto começam com &lt;code&gt;str_&lt;/code&gt;. Caso esqueça o nome de uma função, basta digitar &lt;code&gt;stringr::str_&lt;/code&gt; e apertar &lt;code&gt;TAB&lt;/code&gt; para ver quais são as opções.&lt;/li&gt;
&lt;li&gt;O primeiro argumento da função é sempre uma &lt;code&gt;string&lt;/code&gt; ou um vetor de &lt;code&gt;strings&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;curiosidade&#34;&gt;Curiosidade&lt;/h3&gt;

&lt;p&gt;Inicialmente, o &lt;code&gt;stringr&lt;/code&gt; era um &lt;em&gt;wrapper&lt;/em&gt; de funções do &lt;code&gt;base&lt;/code&gt;. Depois disso,
surgiu um novo pacote &lt;code&gt;stringi&lt;/code&gt;, com sintaxe similar ao &lt;code&gt;stringr&lt;/code&gt;, mas funcionando como
&lt;em&gt;wrapper&lt;/em&gt; da biblioteca ICU. Wickham gostou tanto do pacote &lt;code&gt;stringi&lt;/code&gt;
que decidiu reescrever o &lt;code&gt;stringr&lt;/code&gt; como um &lt;em&gt;wrapper&lt;/em&gt; do &lt;code&gt;stringi&lt;/code&gt;.
Veja &lt;a href=&#34;https://github.com/tidyverse/stringr/blob/master/NEWS.md&#34;&gt;essa página&lt;/a&gt; para detalhes.&lt;/p&gt;

&lt;h2 id=&#34;conceitos-básicos&#34;&gt;Conceitos básicos&lt;/h2&gt;

&lt;p&gt;Todas as funções do &lt;code&gt;stringr&lt;/code&gt; começam com o prefixo &lt;code&gt;str&lt;/code&gt;. Isso ajuda na hora de
encontrar a função que você está procurando. No Rstudio, digite &lt;code&gt;str_&lt;/code&gt; e
aperte &lt;em&gt;tab&lt;/em&gt; para visualizar a lista de funções com esse prefixo. Você pode verificar o que cada função faz até encontrar a que atende às suas necessidades.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;figures/str_tab.png&#34; alt=&#34;str_tab&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nesta sessão, vamos utilizar as funções mais simples do &lt;code&gt;stringr&lt;/code&gt;. Depois vamos
ensinar um pouco de Regex e, em seguida, veremos as funções mais avançadas do
pacote.&lt;/p&gt;

&lt;h3 id=&#34;str-length&#34;&gt;str_length&lt;/h3&gt;

&lt;p&gt;A função mais simples do &lt;code&gt;stringr&lt;/code&gt; é a função &lt;code&gt;str_length&lt;/code&gt;. Esta função recebe
apenas uma string como argumento e retorna o número de caracteres. Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(stringr)
str_length(&amp;quot;olá&amp;quot;)
## [1] 3
length(&amp;quot;olá&amp;quot;)
## [1] 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja: &lt;code&gt;str_length&lt;/code&gt; é diferente de &lt;code&gt;length&lt;/code&gt;. O primeiro retorna o número de caracteres
e o segundo retorna o comprimento do objeto. Isso fica mais claro no seguinte exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s &amp;lt;- c(&amp;quot;olá mundo&amp;quot;, &amp;quot;olá universo&amp;quot;)
str_length(s)
## [1]  9 12
length(s)
## [1] 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora, o &lt;code&gt;str_length&lt;/code&gt; retornou um vetor com o número de caracteres de cada elemento do vetor &lt;code&gt;s&lt;/code&gt; e o &lt;code&gt;length&lt;/code&gt; retornou o comprimento do vetor &lt;code&gt;s&lt;/code&gt;. Note que espaço é considerado como um caractere.&lt;/p&gt;

&lt;h3 id=&#34;str-trim&#34;&gt;str_trim&lt;/h3&gt;

&lt;p&gt;É muito comum encontrar textos que vêm com espaços a mais, principalmente de dados
provenientes de formulários em que cada usuário escreve da forma que prefere.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;string &amp;lt;- &#39;\nessa      string é muito suja       \n&#39;
str_trim(string)
## [1] &amp;quot;essa      string é muito suja&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A função &lt;code&gt;str_trim&lt;/code&gt; ajuda removendo os espaços excedetes antes e depois da string.&lt;/p&gt;

&lt;h3 id=&#34;str-sub&#34;&gt;str_sub&lt;/h3&gt;

&lt;p&gt;Às vezes você precisa obter alguma parte fixa de uma string, como, por exemplo, encontrar variáveis com valores da forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s &amp;lt;- c(&amp;quot;01-Feminino&amp;quot;, &amp;quot;02-Masculino&amp;quot;, &amp;quot;03-Indefinido&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Você pode querer manipular essa string para obter apenas a parte final da string.
Neste caso, pode usar a função &lt;code&gt;str_sub&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_sub(s, start = 4) # pegar do quarto até o último caractere
## [1] &amp;quot;Feminino&amp;quot;   &amp;quot;Masculino&amp;quot;  &amp;quot;Indefinido&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Também é possível obter apenas os números:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_sub(s, end = 2) # pegar apenas os dois primeiros caracteres
## [1] &amp;quot;01&amp;quot; &amp;quot;02&amp;quot; &amp;quot;03&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Em outros casos você precisa obter os últimos 2 caracteres.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s &amp;lt;- c(&amp;quot;Feminino-01&amp;quot;, &amp;quot;Masculino-02&amp;quot;, &amp;quot;Indefinido-03&amp;quot;)
str_sub(s, end = -4)
## [1] &amp;quot;Feminino&amp;quot;   &amp;quot;Masculino&amp;quot;  &amp;quot;Indefinido&amp;quot;
str_sub(s, start = -2)
## [1] &amp;quot;01&amp;quot; &amp;quot;02&amp;quot; &amp;quot;03&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É possível usar os argumentos &lt;code&gt;start&lt;/code&gt; e &lt;code&gt;end&lt;/code&gt; conjuntamente.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s &amp;lt;- c(&amp;quot;__SP__&amp;quot;, &amp;quot;__MG__&amp;quot;, &amp;quot;__RJ__&amp;quot;)
str_sub(s, 3, 4)
## [1] &amp;quot;SP&amp;quot; &amp;quot;MG&amp;quot; &amp;quot;RJ&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-to-upper-str-to-lower-str-to-title&#34;&gt;str_to_upper, str_to_lower, str_to_title&lt;/h3&gt;

&lt;p&gt;Essas funções servem para modificar a caixa das letras. Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s &amp;lt;- &amp;quot;Olá, tudo bem?&amp;quot;
str_to_lower(s)
## [1] &amp;quot;olá, tudo bem?&amp;quot;
str_to_upper(s)
## [1] &amp;quot;OLÁ, TUDO BEM?&amp;quot;
str_to_title(s)
## [1] &amp;quot;Olá, Tudo Bem?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essas são as funções mais simples do pacote &lt;code&gt;stringr&lt;/code&gt; e não exigem nenhum conhecimento de regex. Note que nenhuma delas possui o parâmetro &lt;code&gt;pattern&lt;/code&gt;. Você verá como especificar esse parâmetros nas próximas sessões.&lt;/p&gt;

&lt;h2 id=&#34;expressões-regulares&#34;&gt;Expressões Regulares&lt;/h2&gt;

&lt;p&gt;Trabalhar com textos exige um certo conhecimento de expressões regulares (&lt;em&gt;regex&lt;/em&gt;). &lt;a href=&#34;https://pt.wikipedia.org/wiki/Express%C3%A3o_regular&#34;&gt;Expressões regulares&lt;/a&gt; permitem identificar conjuntos de caracteres, palavras e outros padrões por meio de uma sintaxe concisa.&lt;/p&gt;

&lt;p&gt;O &lt;code&gt;stringr&lt;/code&gt; utiliza regex da forma descrita &lt;a href=&#34;http://www.gagolewski.com/software/stringi/manual/?manpage=stringi-search-regex&#34;&gt;neste documento&lt;/a&gt;. A própria &lt;a href=&#34;https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html&#34;&gt;definição&lt;/a&gt; de regex do R é um ótimo manual.&lt;/p&gt;

&lt;p&gt;Vamos estudar expressões regulares por meio de exemplos e da função &lt;code&gt;str_detect()&lt;/code&gt;. Ela retorna &lt;code&gt;TRUE&lt;/code&gt; se uma string atende a uma expressão regular e &lt;code&gt;FALSE&lt;/code&gt; caso contrário.&lt;/p&gt;

&lt;p&gt;Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(stringr)
str_detect(&amp;quot;sao paulo&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)
## [1] TRUE
str_detect(&amp;quot;sao paulo sp&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)
## [1] FALSE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A regex/pattern &amp;ldquo;paulo\$&amp;rdquo; indica que o texto deve ser terminado em &amp;ldquo;paulo&amp;rdquo;. Existem diversos de caracteres auxiliares que vão auxiliar na manipulação dos textos, assim como o &amp;ldquo;\$&amp;ldquo;. Importante: o valor passado para o argumento &lt;code&gt;pattern&lt;/code&gt; de qualquer função do pacote &lt;code&gt;stringr&lt;/code&gt; será entendido como uma regex.&lt;/p&gt;

&lt;p&gt;A tabela abaixo mostra a aplicação de seis &lt;code&gt;regex&lt;/code&gt; em seis strings distintas.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;testes&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;^ban&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;b ?an&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;ban&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;BAN&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;ban$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;abandonado&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ban&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;banana&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;BANANA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ele levou ban&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pranab anderson&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;quantificadores&#34;&gt;Quantificadores&lt;/h3&gt;

&lt;p&gt;Os caracteres &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; e &lt;code&gt;{x,y}&lt;/code&gt; indicam quantas vezes um padrão se repete:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ey+&lt;/code&gt; significa &lt;code&gt;e&lt;/code&gt; e depois &lt;code&gt;y&lt;/code&gt; &amp;ldquo;&lt;strong&gt;uma vez&lt;/strong&gt; ou mais&amp;rdquo;. Por exemplo, reconhece &lt;code&gt;hey&lt;/code&gt;, &lt;code&gt;heyy&lt;/code&gt;, &lt;code&gt;a eyyy&lt;/code&gt;, mas não reconhece &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; nem &lt;code&gt;yy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey*&lt;/code&gt; significa &amp;ldquo;&lt;strong&gt;nenhuma vez&lt;/strong&gt; ou mais&amp;rdquo;. Por exemplo, reconhece &lt;code&gt;hey&lt;/code&gt;, &lt;code&gt;heyy&lt;/code&gt;, &lt;code&gt;a eyyy&lt;/code&gt; e &lt;code&gt;e&lt;/code&gt;, mas não reconhece &lt;code&gt;y&lt;/code&gt; nem &lt;code&gt;yy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey{3}&lt;/code&gt; significa &amp;ldquo;exatamente três vezes&amp;rdquo;. Por exemplo, reconhece &lt;code&gt;eyyy&lt;/code&gt; e &lt;code&gt;eyyyy&lt;/code&gt;, mas não reconhece &lt;code&gt;eyy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey{1,3}&lt;/code&gt; significa &amp;ldquo;entre uma e três vezes&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para aplicar um quantificador a um conjunto de caracteres, use parênteses. Por exemplo, &lt;code&gt;(ey )+&lt;/code&gt; reconhece &lt;code&gt;ey ey&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;conjuntos&#34;&gt;Conjuntos&lt;/h3&gt;

&lt;p&gt;Colocando caracteres dentro de &lt;code&gt;[]&lt;/code&gt;, reconhecemos quaisquer caracteres desse conjunto. Alguns exemplos práticos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[Cc]asa&lt;/code&gt; para reconhecer &amp;ldquo;casa&amp;rdquo; em maiúsculo ou minúsculo.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt; para reconhecer somente números. O mesmo vale para letras &lt;code&gt;[a-z]&lt;/code&gt;, &lt;code&gt;[A-Z]&lt;/code&gt;, &lt;code&gt;[a-zA-Z]&lt;/code&gt; etc.&lt;/li&gt;
&lt;li&gt;O símbolo &lt;code&gt;^&lt;/code&gt; dentro do colchete significa negação. Por exemplo, &lt;code&gt;[^0-9]&lt;/code&gt; significa pegar tudo o que não é número.&lt;/li&gt;
&lt;li&gt;O símbolo &lt;code&gt;.&lt;/code&gt; fora do colchete indica &amp;ldquo;qualquer caractere&amp;rdquo;, mas dentro do colchete é apenas ponto.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;[[:space:]]+&lt;/code&gt; para reconhecer espaços e &lt;code&gt;[[:punct:]]+&lt;/code&gt; para reconhecer pontuações.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;miscelânea&#34;&gt;Miscelânea&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;abjutils::rm_accent()&lt;/code&gt; para retirar os acentos de um texto.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;|&lt;/code&gt; para opções, por exemplo &lt;code&gt;desfavor|desprov&lt;/code&gt; reconhece tanto &amp;ldquo;desfavorável&amp;rdquo; quanto &amp;ldquo;desprovido&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\n&lt;/code&gt; pula linha, &lt;code&gt;\f&lt;/code&gt; é final da página, &lt;code&gt;\t&lt;/code&gt; é tab. Use &lt;code&gt;\&lt;/code&gt; para transformar caracteres especiais em literais.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tolower()&lt;/code&gt; e &lt;code&gt;toupper()&lt;/code&gt; para mudar o case de uma string.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A lista de possibilidades com expressões regulares é extensa.
Um bom lugar para testar o funcionamento de expressões regulares é o &lt;a href=&#34;https://regex101.com/&#34;&gt;regex101&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;funções-avançadas&#34;&gt;Funções avançadas&lt;/h2&gt;

&lt;p&gt;Agora que já vimos as funções básicas do &lt;code&gt;stringr&lt;/code&gt; e aprendemos um pouco de regex, vamos às funções mais avançadas. Basicamante, essas funções buscarão &lt;code&gt;patterns&lt;/code&gt; emum vetor de strings e farão alguma coisa quando encontrá-lo.&lt;/p&gt;

&lt;p&gt;Como já vimos na sessão sobre regex, a função mais simples que possui o argumento
&lt;code&gt;pattern&lt;/code&gt; é a &lt;code&gt;str_detect&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;str-detect&#34;&gt;str_detect()`&lt;/h3&gt;

&lt;p&gt;Retorna &lt;code&gt;TRUE&lt;/code&gt; se a regex é compatível com a string e &lt;code&gt;FALSE&lt;/code&gt; caso contrário.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(stringr)
str_detect(&amp;quot;sao paulo&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)
## [1] TRUE
str_detect(&amp;quot;sao paulo sp&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)
## [1] FALSE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-replace-e-str-replace-all&#34;&gt;str_replace() e str_replace_all()&lt;/h3&gt;

&lt;p&gt;Substituem um padrão (ou todos) encontrado para um outro padrão.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;frutas &amp;lt;- c(&amp;quot;uma maçã&amp;quot;, &amp;quot;duas pêras&amp;quot;, &amp;quot;três bananas&amp;quot;)
str_replace(frutas, &amp;quot;[aeiou]&amp;quot;, &amp;quot;-&amp;quot;) # substitui a primeira vogal de cada string por &amp;quot;-&amp;quot;
## [1] &amp;quot;-ma maçã&amp;quot;     &amp;quot;d-as pêras&amp;quot;   &amp;quot;três b-nanas&amp;quot;
str_replace_all(frutas, &amp;quot;[aeiou]&amp;quot;, &amp;quot;-&amp;quot;) # substitui todas as vogais por &amp;quot;-&amp;quot;
## [1] &amp;quot;-m- m-çã&amp;quot;     &amp;quot;d--s pêr-s&amp;quot;   &amp;quot;três b-n-n-s&amp;quot;

yyyy &amp;lt;- &amp;quot;yyyyy yyyyy ll zz&amp;quot;
str_replace(yyyy, &#39;y+&#39;, &#39;x&#39;) # substitui o primeiro y ou y&#39;s por x
## [1] &amp;quot;x yyyyy ll zz&amp;quot;
str_replace_all(yyyy, &#39;y+&#39;, &#39;x&#39;) # substitui todos os y ou y&#39;s por somente um x
## [1] &amp;quot;x x ll zz&amp;quot;
str_replace_all(yyyy, &#39;y&#39;, &#39;x&#39;) # substitui y por x
## [1] &amp;quot;xxxxx xxxxx ll zz&amp;quot;

str_replace_all(&#39;string     com    muitos espaços&#39;, &#39; +&#39;, &#39; &#39;) # tirar espaços extras
## [1] &amp;quot;string com muitos espaços&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muitas vezes queremos remover alguns caracteres especiais de um texto, mas esses
caracteres fazem parte de comandos de regex, por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;string &amp;lt;- &amp;quot;1 + 2 + 5&amp;quot;
str_replace_all(string, &amp;quot;+&amp;quot;, &amp;quot;-&amp;quot;)
## Error in stri_replace_all_regex(string, pattern, fix_replacement(replacement), : Syntax error in regexp pattern. (U_REGEX_RULE_SYNTAX)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essa forma retorna um erro, pois a função tenta montar uma regex. Você poderia
tentar de outras formas, que não retornariam erro, mas também não retornariam o
resultado esperado.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_replace_all(string, &amp;quot; + &amp;quot;, &amp;quot; - &amp;quot;)
## [1] &amp;quot;1 + 2 + 5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse caso, use a função &lt;code&gt;fixed&lt;/code&gt; para indicar para o &lt;code&gt;stringr&lt;/code&gt; que você não deseja
que o parâmetro seja reconhecido como uma regex.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_replace_all(string, fixed(&amp;quot;+&amp;quot;), &amp;quot;-&amp;quot;)
## [1] &amp;quot;1 - 2 - 5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-extract-e-str-extract-all&#34;&gt;str_extract() e str_extract_all()&lt;/h3&gt;

&lt;p&gt;Extraem padrões de uma string. Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;r_core_group &amp;lt;- c(
  &#39;Douglas Bates&#39;, &#39;John Chambers&#39;, &#39;Peter Dalgaard&#39;,
  &#39;Robert Gentleman&#39;, &#39;Kurt Hornik&#39;, &#39;Ross Ihaka&#39;, &#39;Tomas Kalibera&#39;,
  &#39;Michael Lawrence&#39;, &#39;Friedrich Leisch&#39;, &#39;Uwe Ligges&#39;, &#39;...&#39;
)
sobrenomes &amp;lt;- str_extract(r_core_group, &#39;[:alpha:]+$&#39;)
sobrenomes
##  [1] &amp;quot;Bates&amp;quot;     &amp;quot;Chambers&amp;quot;  &amp;quot;Dalgaard&amp;quot;  &amp;quot;Gentleman&amp;quot; &amp;quot;Hornik&amp;quot;   
##  [6] &amp;quot;Ihaka&amp;quot;     &amp;quot;Kalibera&amp;quot;  &amp;quot;Lawrence&amp;quot;  &amp;quot;Leisch&amp;quot;    &amp;quot;Ligges&amp;quot;   
## [11] NA
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-match-e-str-match-all&#34;&gt;str_match() e str_match_all()&lt;/h3&gt;

&lt;p&gt;Extrai pedaços da string identificados pela regex. Caso queira extrair
somente a parte identificada, use parênteses.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Exemplo de pergunta SOPt: http://pt.stackoverflow.com/q/150024/6036
presidentes &amp;lt;- c(&amp;quot;da Fonseca, DeodoroDeodoro da Fonseca&amp;quot;, 
&amp;quot;Peixoto, FlorianoFloriano Peixoto&amp;quot;, &amp;quot;de Morais, PrudentePrudente de Morais&amp;quot;, 
&amp;quot;Sales, CamposCampos Sales&amp;quot;)
nomes_presidentes &amp;lt;- str_match(presidentes, &#39;(.*), ([a-zA-Z]{1,})[A-Z]{1}&#39;)
nomes_presidentes
##      [,1]                   [,2]         [,3]      
## [1,] &amp;quot;da Fonseca, DeodoroD&amp;quot; &amp;quot;da Fonseca&amp;quot; &amp;quot;Deodoro&amp;quot; 
## [2,] &amp;quot;Peixoto, FlorianoF&amp;quot;   &amp;quot;Peixoto&amp;quot;    &amp;quot;Floriano&amp;quot;
## [3,] &amp;quot;de Morais, PrudenteP&amp;quot; &amp;quot;de Morais&amp;quot;  &amp;quot;Prudente&amp;quot;
## [4,] &amp;quot;Sales, CamposC&amp;quot;       &amp;quot;Sales&amp;quot;      &amp;quot;Campos&amp;quot;
str_c(nomes_presidentes[,3], nomes_presidentes[,2], sep = &#39; &#39;)
## [1] &amp;quot;Deodoro da Fonseca&amp;quot; &amp;quot;Floriano Peixoto&amp;quot;   &amp;quot;Prudente de Morais&amp;quot;
## [4] &amp;quot;Campos Sales&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-split-e-str-split-fixed&#34;&gt;str_split() e str_split_fixed()&lt;/h3&gt;

&lt;p&gt;Separa uma string em várias de acordo com um separador.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;string &amp;lt;- &#39;Durante um longo período de tempo o &amp;quot;R&amp;quot; foi escrito &amp;quot;P&amp;quot; como no alfabeto cirílico. O seu nome no alfabeto fenício era &amp;quot;rech&amp;quot;. Seu significado era o de uma cabeça, representada pela adaptação do hieróglifo egípcio de uma cabeça. Transformou-se no &amp;quot;rô&amp;quot; dos gregos. Os romanos modificaram o rô acrescentando um pequeno traço para diferenciá-lo do no nosso P.&#39;
str_split(string, fixed(&#39;.&#39;))
## [[1]]
## [1] &amp;quot;Durante um longo período de tempo o \&amp;quot;R\&amp;quot; foi escrito \&amp;quot;P\&amp;quot; como no alfabeto cirílico&amp;quot;                
## [2] &amp;quot; O seu nome no alfabeto fenício era \&amp;quot;rech\&amp;quot;&amp;quot;                                                         
## [3] &amp;quot; Seu significado era o de uma cabeça, representada pela adaptação do hieróglifo egípcio de uma cabeça&amp;quot;
## [4] &amp;quot; Transformou-se no \&amp;quot;rô\&amp;quot; dos gregos&amp;quot;                                                                 
## [5] &amp;quot; Os romanos modificaram o rô acrescentando um pequeno traço para diferenciá-lo do no nosso P&amp;quot;         
## [6] &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O &lt;code&gt;str_split_fixed&lt;/code&gt; faz o mesmo que &lt;code&gt;str_split()&lt;/code&gt;, mas separa apenas &lt;code&gt;n&lt;/code&gt; vezes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_split_fixed(string, fixed(&#39;.&#39;), 3)
##      [,1]                                                                                   
## [1,] &amp;quot;Durante um longo período de tempo o \&amp;quot;R\&amp;quot; foi escrito \&amp;quot;P\&amp;quot; como no alfabeto cirílico&amp;quot;
##      [,2]                                          
## [1,] &amp;quot; O seu nome no alfabeto fenício era \&amp;quot;rech\&amp;quot;&amp;quot;
##      [,3]                                                                                                                                                                                                                                      
## [1,] &amp;quot; Seu significado era o de uma cabeça, representada pela adaptação do hieróglifo egípcio de uma cabeça. Transformou-se no \&amp;quot;rô\&amp;quot; dos gregos. Os romanos modificaram o rô acrescentando um pequeno traço para diferenciá-lo do no nosso P.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-subset&#34;&gt;str_subset()&lt;/h3&gt;

&lt;p&gt;Retorna somente as strings compatíveis com a regex.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;frases &amp;lt;- c(&#39;a roupa do rei&#39;, &#39;de roma&#39;, &#39;o rato roeu&#39;)
str_subset(frases, &#39;d[eo]&#39;)
## [1] &amp;quot;a roupa do rei&amp;quot; &amp;quot;de roma&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É o mesmo que fazer o subset do R e a função &lt;code&gt;str_detect&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;frases[str_detect(frases, &amp;quot;d[eo]&amp;quot;)]
## [1] &amp;quot;a roupa do rei&amp;quot; &amp;quot;de roma&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;exercícios&#34;&gt;Exercícios&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Faça uma regex que capture múltiplas versões da palavra &amp;lsquo;casa&amp;rsquo;. Ela deve funcionar
com as palavras &amp;lsquo;Casa&amp;rsquo;, &amp;lsquo;CASA&amp;rsquo;, &amp;lsquo;CaSa&amp;rsquo;, &amp;lsquo;CAsa&amp;rsquo;. Teste-a usando a função &lt;code&gt;str_detect&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;palavras &amp;lt;- c(&#39;Casa&#39;, &#39;CASA&#39;, &#39;CaSa&#39;, &#39;CAsa&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Imagine que você possui a seguinte string que é a parte final de uma URL:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/ac/rio-branco/xpto-xyz-1-0-1fds2396-5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Você precisa transformá-la em &amp;lsquo;AC - Rio Branco&amp;rsquo;. &lt;strong&gt;Dica&lt;/strong&gt;: Use a função &lt;code&gt;str_split&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;url &amp;lt;- c(&#39;/ac/rio-branco/xpto-xyz-1-0-1fds2396-5&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; Você possui o seguinte vetor de caracteres: &lt;code&gt;x &amp;lt;- c(&#39;Alto&#39;, &#39;Médio&#39;, &#39;Baixo&#39;)&lt;/code&gt;. A partir desse vetor,
crie um vetor com os valores `&amp;lsquo;03 - Alto&amp;rsquo;, &amp;lsquo;02 - Médio&amp;rsquo; e &amp;lsquo;03 - Baixo&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; Crie uma função que retorna &lt;code&gt;TRUE&lt;/code&gt; quando a string é um &lt;a href=&#34;https://pt.wikipedia.org/wiki/Pal%C3%ADndromo&#34;&gt;palíndromo&lt;/a&gt; e &lt;code&gt;FALSO&lt;/code&gt; caso não seja.
&lt;em&gt;Palíndromo&lt;/em&gt; é uma sequência que é lida da mesma forma tanto da direita pra esquerda quanto
da esquerda para a direita. O nome &amp;lsquo;Ana&amp;rsquo;, por exemplo, é um palíndromo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; De acordo com as regras da língua portuguesa, antes de “P” ou “B” devemos usar a letra “M”. Em outras palavras, com outras consoantes, usamos a letra “N”. Suponha que você tem o seguinte
texto com erros gramaticais.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;texto &amp;lt;- &#39;Nós chamamos os bonbeiros quando começou o incêndio.&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Crie uma função para corrigí-lo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt; O CPF é um número de 11 dígitos, por exemplo: 54491651884. No entanto para facilitar
a visualização costumamos mostrá-lo com separadores a cada 3 casas: 544.916.518-84.
Crie uma função que transforma um número de 11 dígitos em uma string com as separações, como um CPF.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.&lt;/strong&gt; Considere o seguinte texto&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;txt &amp;lt;- &amp;quot;A função mais importante para leitura de dados no `lubridate` é a `ymd`. Essa função serve para ler qualquer data de uma `string` no formato `YYYY-MM-DD`. Essa função é útil pois funciona com qualquer separador entre os elementos da data e também porque temos uma função para cada formato (`mdy`, `dmy`, `dym`, `myd`, `ydm`).&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extraia todas as combinações da função &lt;code&gt;ymd&lt;/code&gt;, sem repetições.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.&lt;/strong&gt; Considere os textos abaixo&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;txts &amp;lt;- c(
  &#39;o produto é muito bom&#39;,
  &#39;o produto não é bom&#39;,
  &#39;o produto não é muito bom&#39;,
  &#39;o produto não é ruim&#39;,
  &#39;o produto não é não bom&#39;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Crie uma regra para identificar se o texto refere-se a um feedback positivo ou negativo sobre o produto (considera não bom = ruim e vice-versa). Retorne um vetor lógico que vale &lt;code&gt;TRUE&lt;/code&gt; se o feedback é positivo e &lt;code&gt;FALSE&lt;/code&gt; caso contrário.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introdução</title>
      <link>/lubridate/</link>
      <pubDate>Sun, 29 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/lubridate/</guid>
      <description>

&lt;h2 id=&#34;lubridate&#34;&gt;Lubridate&lt;/h2&gt;

&lt;p&gt;O pacote lubridate faz o trabalho com datas ser muito mais fácil. Ela foi criada por Garrett Grolemund e Hadley Wickham.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(lubridate)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Loading required package: methods
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;lubridate&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## The following object is masked from &#39;package:base&#39;:
## 
##     date
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(magrittr)
library(dplyr)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;dplyr&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:lubridate&#39;:
## 
##     intersect, setdiff, union
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Resumo do que aprenderemos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;transformar character de diversos formatos em data.&lt;/li&gt;
&lt;li&gt;transformar data em character de diversos formatos.&lt;/li&gt;
&lt;li&gt;extrair informações das datas &lt;code&gt;y m d h m s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;funções úteis (&lt;code&gt;today()&lt;/code&gt;, &lt;code&gt;now()&lt;/code&gt;, etc)&lt;/li&gt;
&lt;li&gt;timezones&lt;/li&gt;
&lt;li&gt;operações aritméticas com datas&lt;/li&gt;
&lt;li&gt;gerar datas&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vamos usar o banco de dados &lt;code&gt;lakers&lt;/code&gt; para os exemplos.&lt;/p&gt;

&lt;h2 id=&#34;transformar-character-em-date&#34;&gt;Transformar &lt;code&gt;character&lt;/code&gt; em &lt;code&gt;date&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df &amp;lt;- data_frame(`entrada` = c(&amp;quot;&amp;quot;)
                 , `função` = c(&amp;quot;&amp;quot;)
                 , `saída` = c(&amp;quot;&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exemplos com datas&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lakers %&amp;gt;% 
  select(date) %&amp;gt;% 
  mutate(`date %&amp;gt;% ymd` = date %&amp;gt;% ymd,
         `date %&amp;gt;% ymd_hm` = date %&amp;gt;% ymd_hm) %&amp;gt;% 
  head %&amp;gt;%
  knitr::kable()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Warning: All formats failed to parse. No formats found.
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;date&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;date %&amp;gt;% ymd&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;date %&amp;gt;% ymd_hm&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Exemplos com datas e horas&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lakers %&amp;gt;% 
  select(date, time) %&amp;gt;% 
  mutate(`paste(date, time) %&amp;gt;% ymd` = paste(date, time) %&amp;gt;% ymd,
         `paste(date, time) %&amp;gt;% ymd_hm` = paste(date, time) %&amp;gt;% ymd_hm,
         `time %&amp;gt;% hm` = time %&amp;gt;% hm,
         `time %&amp;gt;% hms` = time %&amp;gt;% hms
         ) %&amp;gt;% 
  head %&amp;gt;%
  knitr::kable()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Warning: All formats failed to parse. No formats found.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Warning in .parse_hms(..., order = &amp;quot;HMS&amp;quot;, quiet = quiet): Some strings
## failed to parse
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;date&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;time&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;paste(date, time) %&amp;gt;% ymd&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;paste(date, time) %&amp;gt;% ymd_hm&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;time %&amp;gt;% hm&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;time %&amp;gt;% hms&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;12:00&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28 12:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12H 0M 0S&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;11:39&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28 11:39:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11H 39M 0S&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;11:37&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28 11:37:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11H 37M 0S&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;11:25&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28 11:25:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11H 25M 0S&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;11:23&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28 11:23:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11H 23M 0S&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;20081028&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;11:22&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2008-10-28 11:22:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11H 22M 0S&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;transformar-date-em-character&#34;&gt;Transformar &lt;code&gt;date&lt;/code&gt; em &lt;code&gt;character&lt;/code&gt;&lt;/h2&gt;

&lt;h2 id=&#34;extrair-informações-de-datas&#34;&gt;Extrair informações de datas&lt;/h2&gt;

&lt;h2 id=&#34;funções-úteis&#34;&gt;Funções úteis&lt;/h2&gt;

&lt;h2 id=&#34;operações-aritméticas-entre-datas&#34;&gt;Operações aritméticas entre datas&lt;/h2&gt;

&lt;h2 id=&#34;gerar-datas&#34;&gt;Gerar datas&lt;/h2&gt;
</description>
    </item>
    
  </channel>
</rss>